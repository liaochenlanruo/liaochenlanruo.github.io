{"total":149,"pageSize":10,"pageCount":15,"data":[{"title":"基因组试金石：在中心法则背景下对基因组语言模型进行基准测试","slug":"基因组试金石：在中心法则背景下对基因组语言模型进行基准测试","date":"2025-11-16T08:19:58.000Z","updated":"2025-11-16T08:23:32.590Z","comments":true,"path":"api/articles/基因组试金石：在中心法则背景下对基因组语言模型进行基准测试.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F1.large.jpg","content":"<p>2025年6月，香港科技大学计算机科学与工程系的Yihui Wang、Zhiyuan Cai及Hao Chen（通讯作者）等研究者在bioRxiv预印本发表了题为“Genomic Touchstone: Benchmarking Genomic Language Models in the Context of the Central Dogma”的学术文章。该文章报道了其开发的“Genomic Touchstone”综合基准测试框架，在基因组语言模型（gLMs）评估领域具有建立统一评估标准、指导模型设计与实际应用选择的重要意义。下面我将对文章进行解读。</p>\n<h1 id=\"1-摘要\"><a href=\"#1-摘要\" class=\"headerlink\" title=\"1 摘要\"></a>1 摘要</h1><p>基因组语言模型（gLMs）的出现革新了基因组序列分析，但现有评估缺乏覆盖中心法则全链条的整体框架。本研究提出<code>Genomic Touchstone</code>基准测试框架，涵盖36个任务、88个数据集，包含53.4亿碱基对的基因组序列，跨越<code>DNA</code>、<code>RNA</code>、<code>蛋白质</code>三种分子模态。通过评估34种代表性模型（含Transformer、CNN及Hyena、Mamba等高效架构），得出四大核心发现：<strong>（1）</strong> gLMs在RNA和蛋白质任务上表现比肩甚至优于专门预训练的模型；<strong>（2）</strong> Transformer模型整体领先，但高效序列模型在特定任务中潜力显著；<strong>（3）</strong> gLMs的缩放规律尚未完全明确，更长输入序列和多样化预训练数据持续提升性能，但模型规模增大未必带来更好结果；<strong>（4）</strong> 预训练策略（训练目标、语料组成）对下游泛化能力影响显著。该框架为人类基因组学领域的gLMs评估提供了统一标准，为模型设计和泛化能力研究奠定基础。</p>\n<h1 id=\"2-引言\"><a href=\"#2-引言\" class=\"headerlink\" title=\"2 引言\"></a>2 引言</h1><h2 id=\"2-1-研究背景\"><a href=\"#2-1-研究背景\" class=\"headerlink\" title=\"2.1 研究背景\"></a>2.1 研究背景</h2><p>大型语言模型（LLMs）已革新自然语言处理，受基因组生物代码与人类语言的相似性启发，研究者将LLM框架扩展至生物序列分析，AlphaFold、ESM、DNABERT等模型的成功证明了其潜力。gLMs的设计围绕DNA序列的统计和功能特性展开，但现有评估存在诸多局限：任务覆盖有限，多聚焦分类问题且偏离真实生物分布；缺乏跨中心法则的全面评估，大多仅关注DNA任务；评估协议缺乏区分度，难以指导模型选择。</p>\n<h2 id=\"2-2-研究目标\"><a href=\"#2-2-研究目标\" class=\"headerlink\" title=\"2.2 研究目标\"></a>2.2 研究目标</h2><p>开发一个基于中心法则、一致且具有区分度的综合基准测试框架Genomic Touchstone，系统评估gLMs在DNA、RNA、蛋白质多模态任务中的性能，为生物研究者提供模型选择参考，同时指导未来gLMs的设计与优化。</p>\n<h1 id=\"3-研究结果\"><a href=\"#3-研究结果\" class=\"headerlink\" title=\"3 研究结果\"></a>3 研究结果</h1><h2 id=\"3-1-Genomic-Touchstone框架概述\"><a href=\"#3-1-Genomic-Touchstone框架概述\" class=\"headerlink\" title=\"3.1 Genomic Touchstone框架概述\"></a>3.1 Genomic Touchstone框架概述</h2><h3 id=\"基因组基准框架（Genomic-Touchstone）概述\"><a href=\"#基因组基准框架（Genomic-Touchstone）概述\" class=\"headerlink\" title=\"基因组基准框架（Genomic Touchstone）概述\"></a>基因组基准框架（Genomic Touchstone）概述</h3><p>基因组基准框架（Genomic Touchstone）是一个全面的基准测试框架，旨在对基因组语言模型（gLMs）应对以人为中心的实际生物学挑战的能力进行全面且公正的评估。受中心法则启发——该法则描述了遗传信息从DNA到RNA再到蛋白质的顺畅流动，Genomic Touchstone是首个涵盖跨越DNA、RNA和蛋白质序列模态任务的基准测试（图1），用于严格评估当前基因组语言模型的性能与通用性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F1.large.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F1.large.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1 Genomic Touchstone 概述\"></p>\n<p><font size=2 color='gray'>a：数据整合流程，从组学数据库收集原始资源，经清洗后将DNA、RNA和蛋白质序列转换为统一格式；b：基准测试组成，含36个任务和88个数据集，左侧为9大任务类别，右侧为各模态任务分布；c：基准测试任务覆盖的中心法则核心流程；d-g：基准测试框架 pipeline，包括预训练数据组成、分词策略、模型架构和下游任务分组。</font></p>\n<h3 id=\"基因组层面的核心挑战\"><a href=\"#基因组层面的核心挑战\" class=\"headerlink\" title=\"基因组层面的核心挑战\"></a>基因组层面的核心挑战</h3><p><strong>这些挑战的核心在于基因组本身的复杂性</strong>。DNA是生命的基本分子，承载着细胞功能、发育和进化所需的遗传指令。它包含蛋白质编码基因、非编码RNA以及各种调控基序等多种元件（图1c）。基因组功能注释致力于识别和分类这些元件，以揭示它们在细胞过程中的作用。性能优异的基因组语言模型能够利用从大型基因组数据集获得的知识，检测复杂的序列模式。这种能力可绘制出全面的功能元件图谱，对推进理论基因组学发展和疾病诊断等实际应用都至关重要。</p>\n<p><strong>基因表达受包含启动子、增强子和其他元件的复杂调控网络控制</strong>。准确建模这些机制需要基因组语言模型<code>捕捉长程依赖关系</code>和<code>上下文特异性相互作用</code>，这对于理解基因在不同细胞环境中如何被激活或沉默至关重要。同时，DNA序列中的变异（即使是单核苷酸层面的变异）也可能对基因功能产生深远影响并引发疾病，因此预测这些遗传变异的影响，对于理解发病机制和开发靶向治疗具有重要意义。</p>\n<p>在该领域表现出色的基因组语言模型应能分析突变带来的细微差异，揭示其对基因调控和表型的潜在影响，进而提供关键的预测能力，助力将计算基因组学的见解转化为可行的临床策略。因此，我们对基因组语言模型在DNA层面的评估聚焦于三个类别：<code>基因组功能注释</code>、<code>调控机制建模</code>和<code>遗传变异影响预测</code>（图1b）。这三个类别共包含15项任务，旨在考验模型准确解读和阐释基因组信息多方面特征的能力。</p>\n<hr>\n<h3 id=\"RNA层面的任务设计\"><a href=\"#RNA层面的任务设计\" class=\"headerlink\" title=\"RNA层面的任务设计\"></a>RNA层面的任务设计</h3><p>与主要作为遗传信息储存库的DNA不同，RNA主动将这些指令转化为功能蛋白，调控基因表达并调节细胞对内外刺激的反应（图1c）。作为DNA和蛋白质之间的关键中介，RNA在<code>蛋白质合成</code>、<code>酶活性</code>和<code>基因调控</code>等众多生物学过程中发挥着核心作用。因此，揭示RNA的多样功能，对于理解细胞复杂性和疾病潜在机制至关重要。</p>\n<p>从语言学角度看，<u>RNA和DNA的“词汇表”仅相差一个“字母”：RNA中的尿嘧啶（U）取代了DNA中的胸腺嘧啶（T）</u>。但尿嘧啶和胸腺嘧啶均为与腺嘌呤配对的嘧啶类碱基，结构相似，这表明它们功能相近。基于这种相似性，我们推测RNA和DNA可能处于统一的语义空间中。这意味着<u>基于DNA预训练的基因组语言模型，或许能有效泛化到RNA相关任务</u>。</p>\n<p>受BEACON的启发，我们收集了三类主要的RNA任务：<code>RNA功能研究</code>、<code>转录后调控</code>及<code>RNA工程应用</code>（图1b）。RNA功能研究分析RNA如何调控基因表达并参与疾病发生，为治疗干预提供机制层面的见解；转录后调控聚焦转录后发生的RNA加工、稳定性调控及修饰事件，这些过程共同决定RNA的寿命和调控效果；RNA工程应用则探索RNA在合成生物学中的潜力，以提升其在生物技术和医学领域的应用价值，应对复杂的生物学挑战。</p>\n<hr>\n<h3 id=\"蛋白质层面的评估逻辑\"><a href=\"#蛋白质层面的评估逻辑\" class=\"headerlink\" title=\"蛋白质层面的评估逻辑\"></a>蛋白质层面的评估逻辑</h3><p>通过分子生物学中心法则，蛋白质与DNA紧密相连——该法则描述了遗传信息从DNA到RNA，最终到蛋白质的传递过程。在这一过程中，DNA作为稳定的遗传指令储存库，先转录为信使RNA（mRNA），再翻译为蛋白质。而蛋白质则执行从催化、结构支撑到信号传导和调控的关键细胞功能。这种顺畅的信息传递支撑着所有生物学过程，也体现了基因组序列与其编码的蛋白质组之间的内在联系（图1c）。</p>\n<p>由于基因组（尤其是编码DNA序列CDS）编码了所有蛋白质，基于基因组数据预训练的基因组语言模型不仅能预测DNA序列特征，还能预测蛋白质特性。为评估基因组语言模型处理蛋白质相关任务的能力，我们筛选了一系列涵盖蛋白质生物学多个方面的任务。<u>通过提取每种蛋白质对应的编码DNA序列（CDS），将蛋白质水平的数据集转换为基于DNA的格式</u>。序列获取的具体流程详见方法部分。</p>\n<p>具体而言，我们的任务套件包含三个不同类别（图1b）：<u><strong>首先</strong>是结构分析与预测，评估基因组语言模型直接从序列数据中推断蛋白质二级和三级结构的能力；<strong>其次</strong>是蛋白质功能注释，考察模型根据蛋白质的序列特征识别并赋予其生物学功能的效果；<strong>最后</strong>是蛋白质特性预测，聚焦于预测稳定性、溶解性和结合亲和力等关键理化属性，以此展现模型预测序列变异对蛋白质功能影响的能力</u>。</p>\n<hr>\n<h3 id=\"模型选择与评估设计\"><a href=\"#模型选择与评估设计\" class=\"headerlink\" title=\"模型选择与评估设计\"></a>模型选择与评估设计</h3><p>基于精心筛选的数据集，我们选取了多种基因组语言模型，以及两种基准模型（卷积神经网络CNN和长短期记忆网络LSTM），评估它们在与人类相关任务中的性能。为确保评估全面且具有生物学意义，我们重点关注基于人类基因组数据预训练的模型——包括仅在人类参考基因组上训练的模型，以及使用包含大量人类序列的多物种语料库训练的模型（详见方法部分）。</p>\n<p>所选模型涵盖多种架构，从传统的<code>CNN</code>、<code>LSTM</code>，到基于<code>Transformer</code>的模型，再到<code>BigBird</code>、<code>Hyena</code>和<code>Mamba</code>等新兴架构，每种模型均搭配不同的分词策略（如<code>字符级</code>、<code>k-mer</code>和字节对编码<code>BPE</code>）。模型规模从数百万参数的小型架构到高达25亿参数的大规模模型不等，使我们能够探究模型容量对生物序列建模的影响。</p>\n<p>这一系列基于人类数据预训练的模型，让我们得以系统评估架构选择、分词方案和预训练数据对下游人类功能基因组学任务性能的影响。通过在统一的基准测试集（涵盖DNA、RNA和蛋白质层面的任务）上对所有模型进行微调，我们分离出<code>架构设计</code>、<code>预训练策略</code>和<code>参数规模</code>等特定建模因素的影响。纳入RNA和蛋白质语言模型，进一步使我们能够探索这些模型跨分子模态的泛化能力。</p>\n<p>值得注意的是，<strong>没有任何单一模型在所有任务中持续优于其他模型</strong>（图2a）；即使是表现最佳的模型，平均排名也仅为7.3，这凸显了当前基因组模型固有的权衡取舍和专门化特性。这种差异性强调了多维度评估的重要性，也表明不同任务可能受益于不同的归纳偏好。最后，我们扩展分析以验证大语言模型（LLM）中观察到的缩放定律是否适用于基因组领域，探究模型容量和数据构成如何共同影响在健康相关及更广泛生物学场景中的泛化能力。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F2.large.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F2.large.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2 gLMs基准测试结果分析\"></p>\n<p><font color='grey' size=2> a. 基于整体性能的模型平均排名。每个圆圈代表一个模型，颜色深浅对应排名（颜色越深表示性能越优），中心位置显示数字排名。b-d. 各模型在DNA(b)、RNA(c)和蛋白质(d)基准测试中的任务特定性能分布（点状图）与平均性能分布（黑色菱形）。各模态中排名前五的模型以红色高亮显示，其余模型则以蓝色标注。</font></p>\n<h2 id=\"3-2-DNA相关任务性能\"><a href=\"#3-2-DNA相关任务性能\" class=\"headerlink\" title=\"3.2 DNA相关任务性能\"></a>3.2 DNA相关任务性能</h2><p>DNA任务分为<code>基因组功能注释</code>、<code>调控机制建模</code>、<code>遗传变异效应预测</code>三类，核心结果如下：</p>\n<ul>\n<li><strong>基因组功能注释</strong>：<code>剪接位点预测</code>（SpliceBERT的F1分数0.918）和<code>CpG甲基化预测</code>（NTv2-500m-Multi的F1分数0.957）任务表现优异；<code>表观遗传标记预测</code>难度最高（顶级模型F1分数仅0.380）；<u>输入序列长度提升显著改善物种分类等任务性能，长上下文模型（如Hyena-Large）在8192碱基对以上序列中表现突出</u>。</li>\n<li><strong>调控机制建模</strong>：<code>增强子-启动子相互作用</code>预测表现较好（DNABERT2的F1分数0.941）；<code>基因表达预测</code>（Generator-1.2b的$R^2$&#x3D;0.548）和<code>增强子活性预测</code>（NT-2.5b-1000g的Spearman分数0.317）性能中等，模型差异显著。</li>\n<li><strong>遗传变异效应预测</strong>：<code>BRCA1/2 SNV功能影响分类</code>任务表现最佳（NT-2.5b-1000g的F1分数0.893）；<code>致病性分类</code>整体难度高（顶级模型F1分数仅0.391）；<code>GPN</code>在遗传疾病分类中领先（F1分数0.725）。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F3.large.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F3.large.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3 基因组功能注释任务模型性能\"></p>\n<p><font size=2 color='gray'>a：6项代表性基因组功能注释基准测试中前20个模型的F1分数（***: P&lt;0.001, *: P&lt;0.05），不同模型在不同任务中表现各异；b：不同输入序列长度下的物种分类性能，左图为多个模型在不同序列长度下的平均F1分数分布及趋势线，右图显示长序列长度显著提升F1分数，长上下文模型在8192碱基对以上序列中独占优势。</font></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F4.large.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F4.large.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图4. 模型在调控机制建模任务与基因变异效应预测任务中的表现\"></p>\n<p><font size=2 color='gray'>a. 调控机制建模任务的前20个模型，涵盖调控活性预测、增强子活性预测、增强子-启动子相互作用预测及基因表达预测（***：P &lt; 0.001）。b. 基因变异效应预测任务的表现，包括遗传疾病分类、致病性分类、剪接变异效应预测以及BRCA1&#x2F;2 SNV 功能影响分类（***：P &lt; 0.001）。</font></p>\n<h2 id=\"3-3-RNA相关任务性能\"><a href=\"#3-3-RNA相关任务性能\" class=\"headerlink\" title=\"3.3 RNA相关任务性能\"></a>3.3 RNA相关任务性能</h2><p>RNA任务分为<code>RNA功能研究</code>、<code>转录后调控</code>、<code>RNA工程应用</code>三类，核心发现：</p>\n<ul>\n<li><u>DNA预训练gLMs在几乎所有RNA任务中优于RNA预训练模型</u>，即使参数规模相当（如DNABERT2、NTv2-100m-Multi vs RNAErnie、RNAFM）。</li>\n<li><code>非编码RNA分类</code>（Caduceus-Ps的F1分数0.960）和<code>APA异构体预测</code>（Caduceus-Ps的Spearman分数0.929）表现突出；<code>平均核糖体负载</code>预测（Hyena-Medium的Spearman分数0.812）和<code>mRNA稳定性</code>预测（Generator-1.2b的Spearman分数0.554）呈现模型差异。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F5.large.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F5.large.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图5 RNA水平任务模型性能\"></p>\n<p><font size=2 color='gray'>a：RNA序列转换为DNA输入的示意图，尿嘧啶（U）替换为胸腺嘧啶（T）后进行分词和模型输入；b：RNA预训练与DNA预训练模型在RNA任务上的性能对比，DNA模型（蓝色）显著优于RNA模型（红色）（***: P &lt; 0.001）；c-e：不同RNA任务类别中前20个模型的性能，包括RNA功能研究（c）、转录后调控（d）和RNA工程应用（e）（***: P&lt;0.001, **: P &lt; 0.01, *: P &lt; 0.05）。</font></p>\n<h2 id=\"3-4-蛋白质相关任务性能\"><a href=\"#3-4-蛋白质相关任务性能\" class=\"headerlink\" title=\"3.4 蛋白质相关任务性能\"></a>3.4 蛋白质相关任务性能</h2><p>蛋白质任务分为<code>结构分析与预测</code>、<code>功能注释</code>、<code>性质预测</code>三类，核心结果：</p>\n<ul>\n<li><u>DNA预训练gLMs在多数蛋白质任务中优于蛋白质预训练模型</u>（如NTv2-500m-Multi在7&#x2F;10项任务中超越ESM-2）。</li>\n<li>蛋白质<code>结构域分类</code>（NTv2-500m-Multi的F1分数1.0）和<code>跨膜区域</code>预测（Generator-1.2b的F1分数0.782）表现优异；<code>酶分类</code>任务整体难度较高（Generator-1.2b的F1分数0.423）；<code>蛋白质稳定性</code>预测中ESM-1b领先（Spearman分数0.762）。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F6.large.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F6.large.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图6 模型在精选蛋白质水平基准测试中的表现\"></p>\n<p><font size=2 color='gray'>a. 密集式蛋白质层面基准测试模型性能。密码子数据集构建流程：蛋白质分子经计算机模拟消化为多肽，翻译为氨基酸序列，再逆向翻译为核苷酸（密码子）序列，经过过滤和注释后生成任务就绪数据集。b. 蛋白质与DNA预训练模型在蛋白质任务上的性能对比。DNA模型（蓝色）显著优于蛋白质模型（绿色），统计学显著性高（*P&lt;0.05）。为确保公平比较，我们选取了参数量相近的模型：DNA模型采用NTv2-500m-Multi和NT-500m-1000G，蛋白质模型采用 ESM -1b和 ESM -2——所有模型参数量均约5亿。c. 结构分析与预测任务前20名模型表现，包括二级结构分析和跨膜区域预测（***：P&lt;0.001，*：P&lt;0.05）。d. 蛋白质功能注释任务前20名模型表现，涵盖蛋白质变体分类、翻译后修饰预测、蛋白质结构域分类及酶分类（***：P&lt;0.001）。e. 蛋白质性质预测任务前20名模型表现，包括β-内酰胺酶活性预测、荧光预测、蛋白质稳定性预测及熔点预测（***：P&lt;0.001）。</font></p>\n<h2 id=\"3-5-模型架构、缩放规律与预训练策略洞察\"><a href=\"#3-5-模型架构、缩放规律与预训练策略洞察\" class=\"headerlink\" title=\"3.5 模型架构、缩放规律与预训练策略洞察\"></a>3.5 模型架构、缩放规律与预训练策略洞察</h2><ul>\n<li><strong>架构影响</strong>：Transformer 模型占据前15名中的14个，整体性能领先，但SSM-based模型（如Caduceus、Hyena）在长序列任务中具有潜力，线性时间复杂度优势显著。</li>\n<li><strong>缩放规律</strong>：NT系列模型呈现明确缩放趋势（参数增加、预训练数据多样化提升性能），但其他模型未表现出一致规律，短序列预训练限制了模型潜力发挥。</li>\n<li><strong>预训练策略</strong>：多物种预训练数据（如NT-2.5b-Multi）、长输入序列预训练显著提升模型泛化能力；融入生物先验的预训练目标（如Generator模型）带来性能增益。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F7.large.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/F7.large.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图7 模型与任务的基准测试洞察\"><br><font size=2 color='gray'>a：模型参数与平均基准测试性能的关系，每个点代表一个预训练模型，x轴为参数规模（对数尺度），y轴为平均评估分数；b：多物种预训练与单一人类数据预训练模型的性能分布对比；c：不同架构模型的性能对比，Transformer架构仍是主流，SSM-based模型具有潜力；d：输入序列长度达32768碱基对时的模型F1分数，长上下文窗口模型随序列长度增加增益显著。</font></p>\n<h1 id=\"4-讨论\"><a href=\"#4-讨论\" class=\"headerlink\" title=\"4 讨论\"></a>4 讨论</h1><h2 id=\"4-1-核心结论\"><a href=\"#4-1-核心结论\" class=\"headerlink\" title=\"4.1 核心结论\"></a>4.1 核心结论</h2><p>Genomic Touchstone建立了首个覆盖中心法则全链条的gLMs评估框架，证实了DNA预训练gLMs在跨模态任务中的泛化能力；Transformer模型整体表现最优，但高效架构在特定场景具有应用价值；<u>模型性能受架构设计、缩放策略和预训练配置的共同影响，多物种、长序列预训练是关键优化方向</u>。</p>\n<h2 id=\"4-2-研究局限与未来方向\"><a href=\"#4-2-研究局限与未来方向\" class=\"headerlink\" title=\"4.2 研究局限与未来方向\"></a>4.2 研究局限与未来方向</h2><ul>\n<li><strong>局限包括</strong>：未开展从头预训练的对照实验、未涵盖生成式任务、以人类数据为中心、缺乏湿实验验证任务。</li>\n<li><strong>未来方向</strong>：开发兼顾性能与效率的新型架构、构建条件生成模型、扩展多物种评估框架、开发gLMs驱动的交互式AI实验辅助工具。</li>\n</ul>\n<h1 id=\"5-研究方法\"><a href=\"#5-研究方法\" class=\"headerlink\" title=\"5 研究方法\"></a>5 研究方法</h1><h2 id=\"5-1-基准测试模型\"><a href=\"#5-1-基准测试模型\" class=\"headerlink\" title=\"5.1 基准测试模型\"></a>5.1 基准测试模型</h2><p>涵盖基线模型（CNN、LSTM）、基因组语言模型（DNABERT系列、GPN、Nucleotide Transformer系列等）、RNA语言模型（RNAFM、SpliceBERT、RNAErnie）、蛋白质语言模型（ESM-1b、ESM-2），详细信息如下表：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/T1.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/T1.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"表1 模型列表\"></p>\n<h2 id=\"5-2-基准测试数据集\"><a href=\"#5-2-基准测试数据集\" class=\"headerlink\" title=\"5.2 基准测试数据集\"></a>5.2 基准测试数据集</h2><p>涵盖DNA、RNA、蛋白质三类模态的36项任务，88个数据集，关键信息如下（部分核心数据集）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/T2.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/05/T2.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"表2 数据集列表\"></p>\n<h2 id=\"5-3-实验设置\"><a href=\"#5-3-实验设置\" class=\"headerlink\" title=\"5.3 实验设置\"></a>5.3 实验设置</h2><ul>\n<li><p><strong>微调细节</strong>：所有模型使用预训练权重初始化，添加任务特定头（回归任务用单层回归头，分类任务用softmax分类头），AdamW优化器+余弦学习率调度器，基于验证集损失选择最优 epoch。</p>\n</li>\n<li><p><strong>评估指标</strong>：</p>\n<ul>\n<li><p><strong>分类任务</strong>：准确率（Accuracy）、F1分数、宏F1分数（Macro-F1）</p>\n<ul>\n<li>$Accuracy &#x3D; \\frac{TP+TN}{TP+TN+FP+FN}$</li>\n<li>$F1 &#x3D; 2 × \\frac{Precision × Recall}{Precision + Recall}$（其中$Precision &#x3D; \\frac{TP}{TP+FP}$，$Recall &#x3D; \\frac{TP}{TP+FN}$）</li>\n<li>$Macro-F1 &#x3D; \\frac{1}{N} \\sum_{i&#x3D;1}^{N} F1_i$（N为类别数，$F1_i$为第i类的F1分数）</li>\n</ul>\n</li>\n<li><p><strong>回归任务</strong>：决定系数（$R^2$）、斯皮尔曼等级相关系数（ρ）</p>\n<ul>\n<li>$R^2 &#x3D; 1 - \\frac{\\sum_{i&#x3D;1}^{n}(y_i - \\hat{y}<em>i)^2}{\\sum</em>{i&#x3D;1}^{n}(y_i - \\overline{y})^2}$（$y_i$为真实值，$\\hat{y}_i$为预测值，$\\overline{y}$为真实值均值）</li>\n<li>$\\rho &#x3D; 1 - \\frac{6 \\cdot \\sum d_i^2}{n(n^2 - 1)}$（$d_i$为预测值与真实值的秩差，n为样本数）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>计算资源</strong>：5亿参数以下模型使用单张NVIDIA RTX 3090 GPU，5亿参数以上模型使用单张NVIDIA H800 GPU。</p>\n</li>\n</ul>\n<h2 id=\"5-4-数据可用性\"><a href=\"#5-4-数据可用性\" class=\"headerlink\" title=\"5.4 数据可用性\"></a>5.4 数据可用性</h2><table>\n<thead>\n<tr>\n<th>Database</th>\n<th>Link</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DNA</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>EPDnew</td>\n<td><a href=\"https://epd.expasy.org/epd/\">https://epd.expasy.org/epd/</a></td>\n</tr>\n<tr>\n<td>ENCODE</td>\n<td><a href=\"https://www.encodeproject.org/\">https://www.encodeproject.org/</a></td>\n</tr>\n<tr>\n<td>GENCODE</td>\n<td><a href=\"https://www.gencodegenes.org/\">https://www.gencodegenes.org/</a></td>\n</tr>\n<tr>\n<td>Ensembl</td>\n<td><a href=\"https://www.ensembl.org/\">https://www.ensembl.org</a></td>\n</tr>\n<tr>\n<td>RefSeq</td>\n<td><a href=\"https://www.ncbi.nlm.nih.gov/refseq/\">https://www.ncbi.nlm.nih.gov/refseq/</a></td>\n</tr>\n<tr>\n<td>GEO</td>\n<td><a href=\"https://www.ncbi.nlm.nih.gov/geo\">https://www.ncbi.nlm.nih.gov/geo</a></td>\n</tr>\n<tr>\n<td>ClinVar</td>\n<td><a href=\"https://www.ncbi.nlm.nih.gov/clinvar/\">https://www.ncbi.nlm.nih.gov/clinvar/</a></td>\n</tr>\n<tr>\n<td>SpliceVarDB</td>\n<td><a href=\"https://splicevardb.org/\">https://splicevardb.org</a></td>\n</tr>\n<tr>\n<td><strong>RNA</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Rfam</td>\n<td><a href=\"https://rfam.org/\">https://rfam.org</a></td>\n</tr>\n<tr>\n<td>PaxDb</td>\n<td><a href=\"https://pax-db.org/\">https://pax-db.org</a></td>\n</tr>\n<tr>\n<td>GEO</td>\n<td><a href=\"https://www.ncbi.nlm.nih.gov/geo\">https://www.ncbi.nlm.nih.gov/geo</a></td>\n</tr>\n<tr>\n<td>RMBase</td>\n<td><a href=\"https://rna.sysu.edu.cn/rmbase\">https://rna.sysu.edu.cn/rmbase</a></td>\n</tr>\n<tr>\n<td>RADAR</td>\n<td><a href=\"http://rnaedit.com/\">http://rnaedit.com</a></td>\n</tr>\n<tr>\n<td>EMBL-EBI</td>\n<td><a href=\"https://www.ebi.ac.uk/gxa/home\">https://www.ebi.ac.uk/gxa/home</a></td>\n</tr>\n<tr>\n<td>SRA</td>\n<td><a href=\"https://www.ncbi.nlm.nih.gov/sra\">https://www.ncbi.nlm.nih.gov/sra</a></td>\n</tr>\n<tr>\n<td>GenBank</td>\n<td><a href=\"https://www.ncbi.nlm.nih.gov/genbank\">https://www.ncbi.nlm.nih.gov/genbank</a></td>\n</tr>\n<tr>\n<td>Ensembl</td>\n<td><a href=\"https://www.ensembl.org/\">https://www.ensembl.org</a></td>\n</tr>\n<tr>\n<td><strong>Protein</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>UniProt</td>\n<td><a href=\"https://www.uniprot.org/\">https://www.uniprot.org/</a></td>\n</tr>\n<tr>\n<td>GENCODE</td>\n<td><a href=\"https://www.gencodegenes.org/\">https://www.gencodegenes.org/</a></td>\n</tr>\n<tr>\n<td>Protein Data Bank</td>\n<td><a href=\"https://www.rcsb.org/\">https://www.rcsb.org/</a></td>\n</tr>\n<tr>\n<td>ProteomicsDB</td>\n<td><a href=\"https://www.proteomicsdb.org/\">https://www.proteomicsdb.org/</a></td>\n</tr>\n</tbody></table>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>Yihui Wang, Zhiyuan Cai, Qian Zeng, Yihang Gao, Jiarui Ouyang, Yingxue Xu, Shu Yang, Sunan He, Yuxiang Nie, Yu Cai, Fengtao Zhou, Cheng Jin, Xi Wang, Zhi Xie, Danqing Zhu, Ting Xie, Kwang-Ting Cheng, Can Yang, Xi Fu, Jiguang Wang, Kang Zhang, Jianhua Yao, Raul Rabadan, Hao Chen. Genomic Touchstone: Benchmarking Genomic Language Models in the Context of the Central Dogma. bioRxiv 2025.06.25.661622; doi: <a href=\"https://doi.org/10.1101/2025.06.25.661622\">https://doi.org/10.1101/2025.06.25.661622</a></li>\n</ul>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"Segmentation models实战","slug":"Segmentation-models实战","date":"2025-11-16T02:42:14.000Z","updated":"2025-11-16T02:47:50.066Z","comments":true,"path":"api/articles/Segmentation-models实战.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig01.webp","content":"<h1 id=\"1-Segmentation-models-简介\"><a href=\"#1-Segmentation-models-简介\" class=\"headerlink\" title=\"1. Segmentation models 简介\"></a>1. Segmentation models 简介</h1><p>使用Transformer骨干网络的分割模型（如Nucleotide Transformer、Enformer、Borzoi）可用于单核苷酸分辨率下的基因组元件预测。例如，<code>SegmentNT</code>能在长达30kb的序列（可扩展至50kbp）中<strong>预测14种不同类别的人类基因组元件</strong>，并表现出优异的性能。</p>\n<p>所有模型均搭配一维U-Net分割头，以单核苷酸分辨率预测序列中多种基因组元件的位置。这些元件包括基因元件（蛋白质编码基因、长链非编码RNA、5’非翻译区、3’非翻译区、外显子、内含子、剪接受体位点和供体位点）和调控元件（polyA signal、组织非特异性和组织特异性启动子及增强子，以及CTCF结合位点）。</p>\n<ul>\n<li>📜 <strong><a href=\"https://www.nature.com/articles/s41592-025-02881-2\">Read the Paper (Nature Methods 2025)</a></strong></li>\n<li>🤗 <strong><a href=\"https://huggingface.co/collections/InstaDeepAI/segmentnt-65eb4941c57808b4a3fe1319\">SegmentNT Hugging Face Collection</a></strong></li>\n<li>🚀 <strong><a href=\"https://colab.research.google.com/#fileId=https%3A//huggingface.co/InstaDeepAI/segment_nt/blob/main/inference_segment_nt.ipynb\">SegmentNT Inference Notebook (HF)</a></strong></li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig01.webp\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig01.webp\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt= \"Performance on downstream tasks\" width=\"600\">\n\n<p><em>Fig. 1: SegmentNT localizes genomics elements at nucleotide resolution.</em></p>\n<h1 id=\"2-如何使用-🚀\"><a href=\"#2-如何使用-🚀\" class=\"headerlink\" title=\"2. 如何使用 🚀\"></a>2. 如何使用 🚀</h1><h2 id=\"2-1-安装并加载模块\"><a href=\"#2-1-安装并加载模块\" class=\"headerlink\" title=\"2.1 安装并加载模块\"></a>2.1 安装并加载模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!pip install boto3</span><br><span class=\"line\">!pip install matplotlib</span><br><span class=\"line\">!pip install biopython</span><br><span class=\"line\">!pip install dm-haiku</span><br></pre></td></tr></table></figure>\n\n<pre><code>Looking in indexes: https://pypi.org/simple, https://packagecloud.io/github/git-lfs/pypi/simple\nRequirement already satisfied: boto3 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (1.28.2)\nRequirement already satisfied: botocore&lt;1.32.0,&gt;=1.31.2 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from boto3) (1.31.2)\nRequirement already satisfied: jmespath&lt;2.0.0,&gt;=0.7.1 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from boto3) (1.0.1)\nRequirement already satisfied: s3transfer&lt;0.7.0,&gt;=0.6.0 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from boto3) (0.6.1)\nRequirement already satisfied: python-dateutil&lt;3.0.0,&gt;=2.1 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from botocore&lt;1.32.0,&gt;=1.31.2-&gt;boto3) (2.8.2)\nRequirement already satisfied: urllib3&lt;1.27,&gt;=1.25.4 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from botocore&lt;1.32.0,&gt;=1.31.2-&gt;boto3) (1.26.16)\nRequirement already satisfied: six&gt;=1.5 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from python-dateutil&lt;3.0.0,&gt;=2.1-&gt;botocore&lt;1.32.0,&gt;=1.31.2-&gt;boto3) (1.16.0)\n\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m24.1.1\u001b[0m\u001b[39;49m -&gt; \u001b[0m\u001b[32;49m24.1.2\u001b[0m\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\nLooking in indexes: https://pypi.org/simple, https://packagecloud.io/github/git-lfs/pypi/simple\nRequirement already satisfied: matplotlib in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (3.7.2)\nRequirement already satisfied: contourpy&gt;=1.0.1 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (1.1.0)\nRequirement already satisfied: cycler&gt;=0.10 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (0.11.0)\nRequirement already satisfied: fonttools&gt;=4.22.0 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (4.41.0)\nRequirement already satisfied: kiwisolver&gt;=1.0.1 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (1.4.4)\nRequirement already satisfied: numpy&gt;=1.20 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (1.25.1)\nRequirement already satisfied: packaging&gt;=20.0 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (23.1)\nRequirement already satisfied: pillow&gt;=6.2.0 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (10.0.0)\nRequirement already satisfied: pyparsing&lt;3.1,&gt;=2.3.1 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (3.0.9)\nRequirement already satisfied: python-dateutil&gt;=2.7 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from matplotlib) (2.8.2)\nRequirement already satisfied: six&gt;=1.5 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib) (1.16.0)\n\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m24.1.1\u001b[0m\u001b[39;49m -&gt; \u001b[0m\u001b[32;49m24.1.2\u001b[0m\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\nLooking in indexes: https://pypi.org/simple, https://packagecloud.io/github/git-lfs/pypi/simple\nRequirement already satisfied: biopython in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (1.81)\nRequirement already satisfied: numpy in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from biopython) (1.25.1)\n\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m24.1.1\u001b[0m\u001b[39;49m -&gt; \u001b[0m\u001b[32;49m24.1.2\u001b[0m\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\nLooking in indexes: https://pypi.org/simple, https://packagecloud.io/github/git-lfs/pypi/simple\nRequirement already satisfied: dm-haiku in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (0.0.9)\nRequirement already satisfied: absl-py&gt;=0.7.1 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from dm-haiku) (1.4.0)\nRequirement already satisfied: jmp&gt;=0.0.2 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from dm-haiku) (0.0.4)\nRequirement already satisfied: numpy&gt;=1.18.0 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from dm-haiku) (1.25.1)\nRequirement already satisfied: tabulate&gt;=0.8.9 in /home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages (from dm-haiku) (0.9.0)\n\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m24.1.1\u001b[0m\u001b[39;49m -&gt; \u001b[0m\u001b[32;49m24.1.2\u001b[0m\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n</code></pre>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> nucleotide_transformer</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">    !pip install git+https://github.com/instadeepai/nucleotide-transformer@main |tail -n <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> nucleotide_transformer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">&quot;COLAB_TPU_ADDR&quot;</span> <span class=\"keyword\">in</span> os.environ:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> jax.tools <span class=\"keyword\">import</span> colab_tpu</span><br><span class=\"line\"></span><br><span class=\"line\">    colab_tpu.setup_tpu()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-SegmentNT\"><a href=\"#2-2-SegmentNT\" class=\"headerlink\" title=\"2.2 SegmentNT\"></a>2.2 SegmentNT</h2><p>⚠️ SegmentNT 模型采用 <a href=\"https://www.nature.com/articles/s41592-024-02523-z\">核苷酸转换器（NT）</a> 作为骨干网络，训练数据为 30,000 个核苷酸序列（对应 5001 个标记，包含 CLS 标记）。但研究表明，SegmentNT 可泛化至 50,000 bp（碱基对）的序列。由于 30,000 bp 的训练长度超过了核苷酸转换器所能处理的最大长度（2048 个 6-mer 标记），因此采用了 Yarn 缩放技术。</p>\n<p>默认情况下，<code>缩放系数（rescaling factor）</code> 已设置为训练时使用的值。若需对 30kbp 至 50kbp 之间的序列进行推理，需在 <code>get_pretrained_segment_nt_model</code> 函数中传入 <code>rescaling_factor</code> 参数，其值计算公式为：</p>\n<p><strong>rescaling_factor &#x3D; 最大核苷酸数 &#x2F; 核苷酸转换器最大标记数</strong></p>\n<p>其中，<code>推理时 DNA 标记数（num_dna_tokens_inference）</code> 指推理过程中的标记总数（例如 40008 个碱基对的序列对应 6669 个标记），<code>核苷酸转换器最大标记数（max_num_tokens_nt）</code> 为骨干网络核苷酸转换器的训练最大标记数，即 <code>2048</code>。</p>\n<p>🚧 <font color=\"#FF0000\">SegmentNT 模型不支持输入序列中包含任何 “<strong>N</strong>” 碱基。原因是每个核苷酸需被标记化为 <code>6-mer</code> 形式，而包含一个或多个 “N” 碱基的序列无法满足这一标记化要求。</font></p>\n<h3 id=\"2-2-1-🔍-示例代码\"><a href=\"#2-2-1-🔍-示例代码\" class=\"headerlink\" title=\"2.2.1 🔍 示例代码\"></a>2.2.1 🔍 <strong>示例代码</strong></h3><p>下面这段代码的核心功能是使用预训练的<code>segment_nt</code>模型对 DNA 序列进行基因组特征预测（如预测序列是否为内含子 intron 等），并展示了从模型加载、数据预处理到并行推理的完整流程。具体包括：</p>\n<ul>\n<li><strong>环境配置</strong>：指定 JAX 使用 CPU 设备，避免内存泄漏，同时准备多设备并行计算环境。</li>\n<li><strong>模型加载</strong>：加载预训练的segment_nt模型，包括模型参数、前向计算函数、分词器和配置信息，并通过 Haiku 和 JAX 的并行接口（pmap）适配多设备计算。</li>\n<li><strong>数据处理</strong>：将输入的 DNA 序列通过分词器转换为模型可识别的 token ids，并转换为 JAX 数组格式。</li>\n<li><strong>并行推理</strong>：在多个 CPU 设备上并行运行模型，输出 DNA 序列对应各类基因组特征的预测概率，并重点提取了 “intron”（内含子）的预测概率。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入所需库：haiku用于构建神经网络，jax用于高性能数值计算，jax.numpy是jax的numpy接口</span></span><br><span class=\"line\"><span class=\"comment\"># nucleotide_transformer.pretrained中的get_pretrained_segment_nt_model用于获取预训练的核苷酸序列模型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> haiku <span class=\"keyword\">as</span> hk</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax.numpy <span class=\"keyword\">as</span> jnp</span><br><span class=\"line\"><span class=\"keyword\">from</span> nucleotide_transformer.pretrained <span class=\"keyword\">import</span> get_pretrained_segment_nt_model</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置JAX默认使用CPU作为计算设备，避免在其他设备（如GPU）上可能出现的内存泄漏问题，增强代码稳定性</span></span><br><span class=\"line\">jax.config.update(<span class=\"string\">&quot;jax_platform_name&quot;</span>, <span class=\"string\">&quot;cpu&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定计算后端为CPU，获取所有可用的CPU设备，并计算设备数量</span></span><br><span class=\"line\">backend = <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">devices = jax.devices(backend)</span><br><span class=\"line\">num_devices = <span class=\"built_in\">len</span>(devices)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Devices found: <span class=\"subst\">&#123;devices&#125;</span>&quot;</span>)  <span class=\"comment\"># 打印找到的设备信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># DNA序列token数量（不包含前缀的CLS token）需要能被下采样块数量的2的幂整除（此处下采样块对应的值为4）</span></span><br><span class=\"line\">max_num_nucleotides = <span class=\"number\">8</span>  <span class=\"comment\"># 定义最大核苷酸数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 断言检查：确保max_num_nucleotides能被4整除，否则抛出错误（保证模型输入尺寸兼容）</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> max_num_nucleotides % <span class=\"number\">4</span> == <span class=\"number\">0</span>, (</span><br><span class=\"line\">    <span class=\"string\">&quot;The number of DNA tokens (excluding the CLS token prepended) needs to be dividible by&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;2 to the power of the number of downsampling block, i.e 4.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取预训练的segment_nt模型：包括模型参数、前向计算函数、分词器和模型配置</span></span><br><span class=\"line\"><span class=\"comment\"># 其中：</span></span><br><span class=\"line\"><span class=\"comment\"># - model_name指定模型名为&quot;segment_nt&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># - embeddings_layers_to_save指定保存第29层的嵌入特征</span></span><br><span class=\"line\"><span class=\"comment\"># - attention_maps_to_save指定保存(1,4)和(7,10)位置的注意力图</span></span><br><span class=\"line\"><span class=\"comment\"># - max_positions指定最大位置数（包含CLS token，因此为max_num_nucleotides + 1）</span></span><br><span class=\"line\">parameters, forward_fn, tokenizer, config = get_pretrained_segment_nt_model(</span><br><span class=\"line\">    model_name=<span class=\"string\">&quot;segment_nt&quot;</span>,</span><br><span class=\"line\">    embeddings_layers_to_save=(<span class=\"number\">29</span>,),</span><br><span class=\"line\">    attention_maps_to_save=((<span class=\"number\">1</span>, <span class=\"number\">4</span>), (<span class=\"number\">7</span>, <span class=\"number\">10</span>)),</span><br><span class=\"line\">    max_positions=max_num_nucleotides + <span class=\"number\">1</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\"># 用haiku.transform转换前向函数，使其符合haiku的函数式编程范式</span></span><br><span class=\"line\">forward_fn = hk.transform(forward_fn)</span><br><span class=\"line\"><span class=\"comment\"># 使用jax.pmap对前向计算函数进行并行映射，指定计算设备，donate_argnums=(0,)表示允许释放参数的内存</span></span><br><span class=\"line\">apply_fn = jax.pmap(forward_fn.apply, devices=devices, donate_argnums=(<span class=\"number\">0</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 准备输入数据并进行分词</span></span><br><span class=\"line\">sequences = [<span class=\"string\">&quot;ATTCCGATTCCGATTCCAACGGATTATTCCGATTAACCGATTCCAATT&quot;</span>, <span class=\"string\">&quot;ATTTCTCTCTCTCTCTGAGATCGATGATTTCTCTCTCATCGAACTATG&quot;</span>]  <span class=\"comment\"># 两个DNA序列示例</span></span><br><span class=\"line\"><span class=\"comment\"># 对序列进行批量分词，提取token ids（忽略元组中的第一个元素，保留token ids）</span></span><br><span class=\"line\">tokens_ids = [b[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\"><span class=\"comment\"># 将token ids转换为jax数组（int32类型），作为模型输入</span></span><br><span class=\"line\">tokens = jnp.asarray(tokens_ids, dtype=jnp.int32)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化随机种子，并将随机键复制到所有设备（多设备并行时保持一致性）</span></span><br><span class=\"line\">random_key = jax.random.PRNGKey(seed=<span class=\"number\">0</span>)</span><br><span class=\"line\">keys = jax.device_put_replicated(random_key, devices=devices)</span><br><span class=\"line\"><span class=\"comment\"># 将模型参数复制到所有设备</span></span><br><span class=\"line\">parameters = jax.device_put_replicated(parameters, devices=devices)</span><br><span class=\"line\"><span class=\"comment\"># 将输入token复制到所有设备</span></span><br><span class=\"line\">tokens = jax.device_put_replicated(tokens, devices=devices)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对输入序列进行模型推理</span></span><br><span class=\"line\">outs = apply_fn(parameters, keys, tokens)</span><br><span class=\"line\"><span class=\"comment\"># 从推理结果中获取基因组特征的logits（未归一化的概率）</span></span><br><span class=\"line\">logits = outs[<span class=\"string\">&quot;logits&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 将logits通过softmax转换为概率，并取最后一个维度的结果</span></span><br><span class=\"line\">probabilities = jnp.asarray(jax.nn.softmax(logits, axis=-<span class=\"number\">1</span>))[...,-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Probabilities shape: <span class=\"subst\">&#123;probabilities.shape&#125;</span>&quot;</span>)  <span class=\"comment\"># 打印概率的形状</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印模型可预测的基因组特征（如intron、exon等）</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Features inferred: <span class=\"subst\">&#123;config.features&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取&quot;intron&quot;（内含子）特征在特征列表中的索引</span></span><br><span class=\"line\">idx_intron = config.features.index(<span class=\"string\">&quot;intron&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 提取&quot;intron&quot;对应的概率</span></span><br><span class=\"line\">probabilities_intron = probabilities[..., idx_intron]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Intron probabilities shape: <span class=\"subst\">&#123;probabilities_intron.shape&#125;</span>&quot;</span>)  <span class=\"comment\"># 打印内含子概率的形状</span></span><br></pre></td></tr></table></figure>\n\n<p>支持的模型名:</p>\n<ul>\n<li><strong>segment_nt</strong></li>\n<li><strong>segment_nt_multi_species</strong></li>\n</ul>\n<h3 id=\"2-2-2-完整代码\"><a href=\"#2-2-2-完整代码\" class=\"headerlink\" title=\"2.2.2 完整代码\"></a>2.2.2 完整代码</h3><p>下面的代码展示了如何对 10kb 和 50kb 序列进行推理，以及如何绘制概率分布图以复现论文中的图 1（Fig.1d）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Bio <span class=\"keyword\">import</span> SeqIO</span><br><span class=\"line\"><span class=\"keyword\">import</span> gzip</span><br><span class=\"line\"><span class=\"keyword\">import</span> haiku <span class=\"keyword\">as</span> hk</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax.numpy <span class=\"keyword\">as</span> jnp</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> seaborn <span class=\"keyword\">as</span> sns</span><br><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> <span class=\"type\">List</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> nucleotide_transformer.pretrained <span class=\"keyword\">import</span> get_pretrained_segment_nt_model</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Specify &quot;cpu&quot; as default (but you can decide to use GPU or TPU in the next cell)</span></span><br><span class=\"line\">jax.config.update(<span class=\"string\">&quot;jax_platform_name&quot;</span>, <span class=\"string\">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<pre><code>Devices found: [CpuDevice(id=0)]\n</code></pre>\n<p><strong>（1）指定后端设备</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Use either &quot;cpu&quot;, &quot;gpu&quot; or &quot;tpu&quot;</span></span><br><span class=\"line\">backend = <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">devices = jax.devices(backend)</span><br><span class=\"line\">num_devices = <span class=\"built_in\">len</span>(devices)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Devices found: <span class=\"subst\">&#123;devices&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）定义用于绘制概率的函数</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># seaborn settings</span></span><br><span class=\"line\">sns.set_style(<span class=\"string\">&quot;whitegrid&quot;</span>)</span><br><span class=\"line\">sns.set_context(</span><br><span class=\"line\">    <span class=\"string\">&quot;notebook&quot;</span>,</span><br><span class=\"line\">    font_scale=<span class=\"number\">1</span>,</span><br><span class=\"line\">    rc=&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;font.size&quot;</span>: <span class=\"number\">14</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;axes.titlesize&quot;</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;axes.labelsize&quot;</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;xtick.labelsize&quot;</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ytick.labelsize&quot;</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;legend.fontsize&quot;</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.rcParams[<span class=\"string\">&#x27;xtick.bottom&#x27;</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">plt.rcParams[<span class=\"string\">&#x27;ytick.left&#x27;</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set colors</span></span><br><span class=\"line\">colors = sns.color_palette(<span class=\"string\">&quot;Set2&quot;</span>).as_hex()</span><br><span class=\"line\">colors2 = sns.color_palette(<span class=\"string\">&quot;husl&quot;</span>).as_hex()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Rearrange order of the features to match Fig.3 from the paper.</span></span><br><span class=\"line\">features_rearranged = [</span><br><span class=\"line\"> <span class=\"string\">&#x27;protein_coding_gene&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;lncRNA&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;5UTR&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;3UTR&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;exon&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;intron&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;splice_donor&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;splice_acceptor&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;promoter_Tissue_specific&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;promoter_Tissue_invariant&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;enhancer_Tissue_specific&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;enhancer_Tissue_invariant&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;CTCF-bound&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;polyA_signal&#x27;</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_features</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    predicted_probabilities_all,</span></span><br><span class=\"line\"><span class=\"params\">    seq_length: <span class=\"built_in\">int</span>,</span></span><br><span class=\"line\"><span class=\"params\">    features: <span class=\"type\">List</span>[<span class=\"built_in\">str</span>],</span></span><br><span class=\"line\"><span class=\"params\">    order_to_plot: <span class=\"type\">List</span>[<span class=\"built_in\">str</span>],</span></span><br><span class=\"line\"><span class=\"params\">    fig_width=<span class=\"number\">8</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    Function to plot labels and predicted probabilities.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Args:</span></span><br><span class=\"line\"><span class=\"string\">        predicted_probabilities_all: Probabilities per genomic feature for each</span></span><br><span class=\"line\"><span class=\"string\">            nucleotides in the DNA sequence.</span></span><br><span class=\"line\"><span class=\"string\">        seq_length: DNA sequence length.</span></span><br><span class=\"line\"><span class=\"string\">        feature: Genomic features to plot.</span></span><br><span class=\"line\"><span class=\"string\">        order_to_plot: Order in which to plot the genomic features. This needs to be</span></span><br><span class=\"line\"><span class=\"string\">            specified in order to match the order presented in the Fig.3 of the paper</span></span><br><span class=\"line\"><span class=\"string\">        fig_width: Width of the figure</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sc = <span class=\"number\">1.8</span></span><br><span class=\"line\">    n_panels = <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># fig, axes = plt.subplots(n_panels, 1, figsize=(fig_width * sc, (n_panels + 2) * sc), height_ratios=[6] + [2] * (n_panels-1))</span></span><br><span class=\"line\">    _, axes = plt.subplots(n_panels, <span class=\"number\">1</span>, figsize=(fig_width * sc, (n_panels + <span class=\"number\">4</span>) * sc))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n, feat <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(order_to_plot):</span><br><span class=\"line\">        feat_id = features.index(feat)</span><br><span class=\"line\">        prob_dist = predicted_probabilities_all[:, feat_id]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Use the appropriate subplot</span></span><br><span class=\"line\">        ax = axes[n // <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            id_color = colors[feat_id]</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            id_color = colors2[feat_id - <span class=\"number\">8</span>]</span><br><span class=\"line\">        ax.plot(</span><br><span class=\"line\">            prob_dist,</span><br><span class=\"line\">            color=id_color,</span><br><span class=\"line\">            label=feat,</span><br><span class=\"line\">            linestyle=<span class=\"string\">&quot;-&quot;</span>,</span><br><span class=\"line\">            linewidth=<span class=\"number\">1.5</span>,</span><br><span class=\"line\">        )</span><br><span class=\"line\">        ax.set_xlim(<span class=\"number\">0</span>, seq_length)</span><br><span class=\"line\">        ax.grid(<span class=\"literal\">False</span>)</span><br><span class=\"line\">        ax.spines[<span class=\"string\">&#x27;bottom&#x27;</span>].set_color(<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\">        ax.spines[<span class=\"string\">&#x27;top&#x27;</span>].set_color(<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\">        ax.spines[<span class=\"string\">&#x27;right&#x27;</span>].set_color(<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\">        ax.spines[<span class=\"string\">&#x27;left&#x27;</span>].set_color(<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> <span class=\"built_in\">range</span> (<span class=\"number\">0</span>,n_panels):</span><br><span class=\"line\">        axes[a].set_ylim(<span class=\"number\">0</span>, <span class=\"number\">1.05</span>)</span><br><span class=\"line\">        axes[a].set_ylabel(<span class=\"string\">&quot;Prob.&quot;</span>)</span><br><span class=\"line\">        axes[a].legend(loc=<span class=\"string\">&quot;upper left&quot;</span>, bbox_to_anchor=(<span class=\"number\">1</span>, <span class=\"number\">1</span>), borderaxespad=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a != (n_panels-<span class=\"number\">1</span>):</span><br><span class=\"line\">            axes[a].tick_params(axis=<span class=\"string\">&#x27;x&#x27;</span>, which=<span class=\"string\">&#x27;both&#x27;</span>, bottom=<span class=\"literal\">True</span>, top=<span class=\"literal\">False</span>, labelbottom=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Set common x-axis label</span></span><br><span class=\"line\">    axes[-<span class=\"number\">1</span>].set_xlabel(<span class=\"string\">&quot;Nucleotides&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># axes[0].axis(&#x27;off&#x27;)  # Turn off the axis</span></span><br><span class=\"line\">    axes[n_panels-<span class=\"number\">1</span>].grid(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    axes[n_panels-<span class=\"number\">1</span>].tick_params(axis=<span class=\"string\">&#x27;y&#x27;</span>, which=<span class=\"string\">&#x27;both&#x27;</span>, left=<span class=\"literal\">True</span>, right=<span class=\"literal\">False</span>, labelleft=<span class=\"literal\">True</span>, labelright=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;Probabilities predicted over all genomics features&quot;</span>, fontweight=<span class=\"string\">&quot;bold&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）获取人的 20号染色体序列</strong></p>\n<p>为了重现Segment-NT论文中的图表，我们在此检索下载人类20号染色体的文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! wget https://ftp.ensembl.org/pub/release-<span class=\"number\">111</span>/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.chromosome<span class=\"number\">.20</span>.fa.gz</span><br></pre></td></tr></table></figure>\n\n<pre><code>--2024-07-23 09:38:24--  https://ftp.ensembl.org/pub/release-111/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.chromosome.20.fa.gz\nResolving ftp.ensembl.org (ftp.ensembl.org)... 193.62.193.169\nConnecting to ftp.ensembl.org (ftp.ensembl.org)|193.62.193.169|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 18833053 (18M) [application/x-gzip]\nSaving to: ‘Homo_sapiens.GRCh38.dna.chromosome.20.fa.gz’\n\nHomo_sapiens.GRCh38 100%[===================&gt;]  17,96M  1,77MB/s    in 10s     \n\n2024-07-23 09:38:35 (1,75 MB/s) - ‘Homo_sapiens.GRCh38.dna.chromosome.20.fa.gz’ saved [18833053/18833053]\n</code></pre>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fasta_path = <span class=\"string\">&quot;Homo_sapiens.GRCh38.dna.chromosome.20.fa.gz&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> gzip.<span class=\"built_in\">open</span>(fasta_path, <span class=\"string\">&quot;rt&quot;</span>) <span class=\"keyword\">as</span> handle:</span><br><span class=\"line\">    record = <span class=\"built_in\">next</span>(SeqIO.parse(handle, <span class=\"string\">&quot;fasta&quot;</span>))</span><br><span class=\"line\">    chr20 = <span class=\"built_in\">str</span>(record.seq)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）对10kb基因组序列进行推断</strong>（不需要改变前向函数中的重新缩放因子）</p>\n<p><strong>① 实例化SegmentNT推理函数</strong></p>\n<p>以下代码允许您下载其中一个Segment-NT模型的权重。它会返回权重字典、haiku前向函数、分词器和配置字典。</p>\n<p>与<code>get_pretrained_nucleotide_transformer</code>函数类似，您还可以指定：</p>\n<ol>\n<li>您希望收集嵌入的层（例如，(5, 10, 20) 表示获取第5、10和20层的嵌入）</li>\n<li>您希望收集的注意力图（例如，((1,4), (7,18)) 表示获取对应于第1层第4头和第7层第18头的注意力图）。请参考配置以查看模型中的层数和头数。</li>\n<li>您将进行推理计算的序列中的最大标记数。您可以输入不超过模型配置中指定的值（包含将自动添加到序列开头的类标记），但为了优化内存和推理时间，我们建议将此数字尽可能设小。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The number of DNA tokens (excluding the CLS token prepended) needs to be dividible by</span></span><br><span class=\"line\"><span class=\"comment\"># the square of the number of downsampling block, i.e 4.</span></span><br><span class=\"line\">max_num_nucleotides = <span class=\"number\">1668</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> max_num_nucleotides % <span class=\"number\">4</span> == <span class=\"number\">0</span>, (</span><br><span class=\"line\">    <span class=\"string\">&quot;The number of DNA tokens (excluding the CLS token prepended) needs to be dividible by&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;2 to the power of the number of downsampling block, i.e 4.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># If max_num_nucleotides is larger than what was used to train Segment-NT, the rescaling</span></span><br><span class=\"line\"><span class=\"comment\"># factor needs to be adapted.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> max_num_nucleotides + <span class=\"number\">1</span> &gt; <span class=\"number\">5001</span>:</span><br><span class=\"line\">    inference_rescaling_factor = (max_num_nucleotides + <span class=\"number\">1</span>) / <span class=\"number\">2048</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    inference_rescaling_factor=<span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># If this download fails at one point, restarting it will not work.</span></span><br><span class=\"line\"><span class=\"comment\"># Before rerunning the cell, make sure to delete the cache by executing:</span></span><br><span class=\"line\"><span class=\"comment\"># ! rm -rf ~/.cache/nucleotide_transformer/</span></span><br><span class=\"line\">parameters, forward_fn, tokenizer, config = get_pretrained_segment_nt_model(</span><br><span class=\"line\">    model_name=<span class=\"string\">&quot;segment_nt&quot;</span>,</span><br><span class=\"line\">    rescaling_factor=inference_rescaling_factor,</span><br><span class=\"line\">    embeddings_layers_to_save=(<span class=\"number\">29</span>,),</span><br><span class=\"line\">    attention_maps_to_save=((<span class=\"number\">1</span>, <span class=\"number\">4</span>), (<span class=\"number\">7</span>, <span class=\"number\">10</span>)),</span><br><span class=\"line\">    max_positions=max_num_nucleotides + <span class=\"number\">1</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\">forward_fn = hk.transform(forward_fn)</span><br><span class=\"line\">apply_fn = jax.pmap(forward_fn.apply, devices=devices, donate_argnums=(<span class=\"number\">0</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Put required quantities for the inference on the devices. This step is not</span></span><br><span class=\"line\"><span class=\"comment\"># reproduced in the second inference since the quantities will already be loaded</span></span><br><span class=\"line\"><span class=\"comment\"># on the devices !</span></span><br><span class=\"line\">random_key = jax.random.PRNGKey(seed=<span class=\"number\">0</span>)</span><br><span class=\"line\">keys = jax.device_put_replicated(random_key, devices=devices)</span><br><span class=\"line\">parameters = jax.device_put_replicated(parameters, devices=devices)</span><br></pre></td></tr></table></figure>\n\n<pre><code>Downloading model&#39;s hyperparameters json file...\nDownloaded model&#39;s hyperparameters.\nDownloading model&#39;s weights...\nDownloaded model&#39;s weights...\n</code></pre>\n<p><strong>② 对DNA序列进行分词</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idx_start = <span class=\"number\">2650520</span></span><br><span class=\"line\"></span><br><span class=\"line\">idx_stop = idx_start + max_num_nucleotides*<span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">sequences = [chr20[idx_start:idx_stop]]</span><br><span class=\"line\">tokens_ids = [b[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\">tokens_str = [b[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># This stacks the batch so that it is repeated across the devices. This is done</span></span><br><span class=\"line\"><span class=\"comment\"># in order to allow for replication even if one has more than one device.</span></span><br><span class=\"line\"><span class=\"comment\"># To take advantage of the multiple devices and infer different sequences on</span></span><br><span class=\"line\"><span class=\"comment\"># each of the devices, make sure to change this line into a reshape.</span></span><br><span class=\"line\"><span class=\"comment\"># a reshape</span></span><br><span class=\"line\">tokens = jnp.stack([jnp.asarray(tokens_ids, dtype=jnp.int32)]*num_devices, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">tokens.shape</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre><code>(1, 1, 1669)\n</code></pre>\n<p><strong>③ 对生成的批次进行推理</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Infer</span></span><br><span class=\"line\">outs = apply_fn(parameters, keys, tokens)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Obtain the logits over the genomic features</span></span><br><span class=\"line\">logits = outs[<span class=\"string\">&quot;logits&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># Transform them on probabilities</span></span><br><span class=\"line\">probabilities = np.asarray(jax.nn.softmax(logits, axis=-<span class=\"number\">1</span>))[...,-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<pre><code>/home/hugo/anaconda3/envs/trix/lib/python3.10/site-packages/jax/interpreters/mlir.py:622: UserWarning: Some donated buffers were not usable: ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,8192]), ShapedArray(float32[4096,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[4107,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[4107]), ShapedArray(float32[1024,4107]), ShapedArray(float32[1024]), ShapedArray(float32[1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[1024]), ShapedArray(float32[168]), ShapedArray(float32[1024,168]), ShapedArray(float32[1024]), ShapedArray(float32[3,1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[3,1024,1024]), ShapedArray(float32[2048]), ShapedArray(float32[3,1024,2048]), ShapedArray(float32[2048]), ShapedArray(float32[3,2048,2048]), ShapedArray(float32[1024]), ShapedArray(float32[3,1024,1024]), ShapedArray(float32[1024]), ShapedArray(float32[3,1024,1024]), ShapedArray(float32[2048]), ShapedArray(float32[3,2048,2048]), ShapedArray(float32[2048]), ShapedArray(float32[3,2048,2048]), ShapedArray(float32[1024]), ShapedArray(float32[3,1024,2048]), ShapedArray(float32[1024]), ShapedArray(float32[3,1024,1024]).\nSee an explanation at https://jax.readthedocs.io/en/latest/faq.html#buffer-donation.\n  warnings.warn(f&quot;Some donated buffers were not usable: &#123;&#39;, &#39;.join(unused_donations)&#125;.\\n&#123;msg&#125;&quot;)\n</code></pre>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">probabilities.shape</span><br></pre></td></tr></table></figure>\n\n\n\n\n<pre><code>(1, 1, 10008, 14)\n</code></pre>\n<p><strong>④ 绘制这条DNA序列上14个基因组特征的概率图</strong></p>\n<p>请注意，SegmentNT论文中的图1是用SegmentNT-10kb实现的，而这里使用的是SegmentNT-30kb，这就解释了为什么概率并非完全相同。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plot_features(</span><br><span class=\"line\">    probabilities[<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">    probabilities.shape[-<span class=\"number\">2</span>],</span><br><span class=\"line\">    fig_width=<span class=\"number\">20</span>,</span><br><span class=\"line\">    features=config.features,</span><br><span class=\"line\">    order_to_plot=features_rearranged</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_26_0.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_26_0.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"png\"></p>\n<p><strong>（5）对50kb的基因组序列进行推断并绘图</strong>（需要更改前向函数中的重新缩放因子）</p>\n<p><strong>① 实例化SegmentNT推理函数</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The number of DNA tokens (excluding the CLS token prepended) needs to be dividible by</span></span><br><span class=\"line\"><span class=\"comment\"># the square of the number of downsampling block, i.e 4.</span></span><br><span class=\"line\">max_num_nucleotides = <span class=\"number\">8332</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> max_num_nucleotides % <span class=\"number\">4</span> == <span class=\"number\">0</span>, (</span><br><span class=\"line\">    <span class=\"string\">&quot;The number of DNA tokens (excluding the CLS token prepended) needs to be dividible by&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;2 to the power of the number of downsampling block, i.e 4.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># If max_num_nucleotides is larger than what was used to train Segment-NT, the rescaling</span></span><br><span class=\"line\"><span class=\"comment\"># factor needs to be adapted.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> max_num_nucleotides + <span class=\"number\">1</span> &gt; <span class=\"number\">5001</span>:</span><br><span class=\"line\">    inference_rescaling_factor = (max_num_nucleotides + <span class=\"number\">1</span>) / <span class=\"number\">2048</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    inference_rescaling_factor=<span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># The parameters have already been downloaded above</span></span><br><span class=\"line\"><span class=\"comment\"># so we do not instantiate them. However we instantiate a new forward function</span></span><br><span class=\"line\"><span class=\"comment\"># where the context length extension needed is in effect.</span></span><br><span class=\"line\">_, forward_fn, tokenizer, config = get_pretrained_segment_nt_model(</span><br><span class=\"line\">    model_name=<span class=\"string\">&quot;segment_nt&quot;</span>,</span><br><span class=\"line\">    rescaling_factor=inference_rescaling_factor,</span><br><span class=\"line\">    embeddings_layers_to_save=(<span class=\"number\">29</span>,),</span><br><span class=\"line\">    attention_maps_to_save=((<span class=\"number\">1</span>, <span class=\"number\">4</span>), (<span class=\"number\">7</span>, <span class=\"number\">10</span>)),</span><br><span class=\"line\">    max_positions=max_num_nucleotides + <span class=\"number\">1</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\">forward_fn = hk.transform(forward_fn)</span><br><span class=\"line\">apply_fn = jax.pmap(forward_fn.apply, devices=devices, donate_argnums=(<span class=\"number\">0</span>,))</span><br></pre></td></tr></table></figure>\n\n<p><strong>② 对DNA序列进行分词</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idx_start = <span class=\"number\">5099984</span></span><br><span class=\"line\">idx_stop = idx_start + max_num_nucleotides*<span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">sequences = [chr20[idx_start:idx_stop]]</span><br><span class=\"line\">tokens_ids = [b[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\">tokens_str = [b[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># This stacks the batch so that it is repeated across the devices. This is done</span></span><br><span class=\"line\"><span class=\"comment\"># in order to allow for replication even if one has more than one device.</span></span><br><span class=\"line\"><span class=\"comment\"># To take advantage of the multiple devices and infer different sequences on</span></span><br><span class=\"line\"><span class=\"comment\"># each of the devices, make sure to change this line into a reshape.</span></span><br><span class=\"line\"><span class=\"comment\"># a reshape</span></span><br><span class=\"line\">tokens = jnp.asarray(tokens_ids, dtype=jnp.int32)[<span class=\"literal\">None</span>, :]</span><br><span class=\"line\">tokens.shape, idx_stop</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<pre><code>((1, 1, 8333), 5149976)\n</code></pre>\n<p><strong>③ 对生成的批次进行推理</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Infer</span></span><br><span class=\"line\">outs = apply_fn(parameters, keys, tokens)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Obtain the logits over the genomic features</span></span><br><span class=\"line\">logits = outs[<span class=\"string\">&quot;logits&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># Transform them on probabilities</span></span><br><span class=\"line\">probabilities = np.asarray(jax.nn.softmax(logits, axis=-<span class=\"number\">1</span>))[...,-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>④ 绘制这条DNA序列上14个基因组特征的概率图</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plot_features(</span><br><span class=\"line\">    probabilities[<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">    probabilities.shape[-<span class=\"number\">2</span>],</span><br><span class=\"line\">    fig_width=<span class=\"number\">20</span>,</span><br><span class=\"line\">    features=config.features,</span><br><span class=\"line\">    order_to_plot=features_rearranged</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_35_0.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_35_0.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"png\"></p>\n<h2 id=\"2-3-SegmentEnformer\"><a href=\"#2-3-SegmentEnformer\" class=\"headerlink\" title=\"2.3 SegmentEnformer\"></a>2.3 SegmentEnformer</h2><p>SegmentEnformer借助了<a href=\"https://www.nature.com/articles/s41592-021-01252-x\">Enformer</a>，它移除了预测头，并用一个一维U-Net分割头取而代之，以单核苷酸分辨率<strong>预测序列中多种基因组元件的位置</strong>。</p>\n<h3 id=\"2-3-1-🔍-示例\"><a href=\"#2-3-1-🔍-示例\" class=\"headerlink\" title=\"2.3.1 🔍 示例\"></a>2.3.1 🔍 示例</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> haiku <span class=\"keyword\">as</span> hk</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax.numpy <span class=\"keyword\">as</span> jnp</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> nucleotide_transformer.enformer.pretrained <span class=\"keyword\">import</span> get_pretrained_segment_enformer_model</span><br><span class=\"line\"><span class=\"keyword\">from</span> nucleotide_transformer.enformer.features <span class=\"keyword\">import</span> FEATURES</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Initialize CPU as default JAX device. This makes the code robust to memory leakage on</span></span><br><span class=\"line\"><span class=\"comment\"># the devices.</span></span><br><span class=\"line\">jax.config.update(<span class=\"string\">&quot;jax_platform_name&quot;</span>, <span class=\"string\">&quot;cpu&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">backend = <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">devices = jax.devices(backend)</span><br><span class=\"line\">num_devices = <span class=\"built_in\">len</span>(devices)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Load model</span></span><br><span class=\"line\">parameters, state, forward_fn, tokenizer, config = get_pretrained_segment_enformer_model()</span><br><span class=\"line\">forward_fn = hk.transform_with_state(forward_fn)</span><br><span class=\"line\"></span><br><span class=\"line\">apply_fn = jax.pmap(forward_fn.apply, devices=devices, donate_argnums=(<span class=\"number\">0</span>,))</span><br><span class=\"line\">random_key = jax.random.PRNGKey(seed=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Replicate over devices</span></span><br><span class=\"line\">keys = jax.device_put_replicated(random_key, devices=devices)</span><br><span class=\"line\">parameters = jax.device_put_replicated(parameters, devices=devices)</span><br><span class=\"line\">state = jax.device_put_replicated(state, devices=devices)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get data and tokenize it</span></span><br><span class=\"line\">sequences = [<span class=\"string\">&quot;A&quot;</span> * <span class=\"number\">196_608</span>]</span><br><span class=\"line\">tokens_ids = [b[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\">tokens = jnp.stack([jnp.asarray(tokens_ids, dtype=jnp.int32)] * num_devices, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Infer</span></span><br><span class=\"line\">outs, state = apply_fn(parameters, state, keys, tokens)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Obtain the logits over the genomic features</span></span><br><span class=\"line\">logits = outs[<span class=\"string\">&quot;logits&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># Transform them on probabilities</span></span><br><span class=\"line\">probabilities = np.asarray(jax.nn.softmax(logits, axis=-<span class=\"number\">1</span>))[..., -<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get probabilities associated with intron</span></span><br><span class=\"line\">idx_intron = FEATURES.index(<span class=\"string\">&quot;intron&quot;</span>)</span><br><span class=\"line\">probabilities_intron = probabilities[..., idx_intron]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Intron probabilities shape: <span class=\"subst\">&#123;probabilities_intron.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-2-完整代码\"><a href=\"#2-3-2-完整代码\" class=\"headerlink\" title=\"2.3.2 完整代码\"></a>2.3.2 完整代码</h3><p>下列代码展示了如何对一个196,608bp 的序列进行推断并绘制概率图。模块导入、基因组下载、绘图函数如前所述，不再重复。</p>\n<p><strong>（1）实例化SegmentEnformer推理函数</strong></p>\n<p>以下代码允许您下载SegmentEnformer的权重。它会返回权重字典、haiku前向函数、分词器和配置字典。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parameters, state, forward_fn, tokenizer, config = get_pretrained_segment_enformer_model()</span><br></pre></td></tr></table></figure>\n\n<pre><code>Downloading model&#39;s weights...\n</code></pre>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward_fn = hk.transform_with_state(forward_fn)</span><br><span class=\"line\">apply_fn = jax.pmap(forward_fn.apply, devices=devices, donate_argnums=(<span class=\"number\">0</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Put required quantities for the inference on the devices. This step is not</span></span><br><span class=\"line\"><span class=\"comment\"># reproduced in the second inference since the quantities will already be loaded</span></span><br><span class=\"line\"><span class=\"comment\"># on the devices !</span></span><br><span class=\"line\">random_key = jax.random.PRNGKey(seed=<span class=\"number\">0</span>)</span><br><span class=\"line\">keys = jax.device_put_replicated(random_key, devices=devices)</span><br><span class=\"line\">parameters = jax.device_put_replicated(parameters, devices=devices)</span><br><span class=\"line\">state = jax.device_put_replicated(state, devices=devices)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）DNA序列分词</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_nucleotides = <span class=\"number\">196_608</span></span><br><span class=\"line\">idx_start = <span class=\"number\">2650520</span></span><br><span class=\"line\"></span><br><span class=\"line\">idx_stop = idx_start + num_nucleotides</span><br><span class=\"line\"></span><br><span class=\"line\">sequences = [chr20[idx_start:idx_stop]]</span><br><span class=\"line\">tokens_ids = [b[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\">tokens_str = [b[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># This stacks the batch so that it is repeated across the devices. This is done</span></span><br><span class=\"line\"><span class=\"comment\"># in order to allow for replication even if one has more than one device.</span></span><br><span class=\"line\"><span class=\"comment\"># To take advantage of the multiple devices and infer different sequences on</span></span><br><span class=\"line\"><span class=\"comment\"># each of the devices, make sure to change this line into a reshape.</span></span><br><span class=\"line\"><span class=\"comment\"># a reshape</span></span><br><span class=\"line\">tokens = jnp.stack([jnp.asarray(tokens_ids, dtype=jnp.int32)]*num_devices, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">tokens.shape</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<pre><code>(1, 1, 196608)\n</code></pre>\n<p><strong>（3）对生成的批次进行推断</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Infer</span></span><br><span class=\"line\">outs, state = apply_fn(parameters, state, keys, tokens) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Obtain the logits over the genomic features</span></span><br><span class=\"line\">logits = outs[<span class=\"string\">&quot;logits&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># Transform them on probabilities</span></span><br><span class=\"line\">probabilities = np.asarray(jax.nn.softmax(logits, axis=-<span class=\"number\">1</span>))[...,-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">probabilities.shape</span><br></pre></td></tr></table></figure>\n\n\n<pre><code>(1, 1, 196608, 14)\n</code></pre>\n<p><strong>（4）绘制该DNA序列中14个基因组特征的概率图</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plot_features(</span><br><span class=\"line\">    probabilities[<span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    probabilities.shape[-<span class=\"number\">2</span>],</span><br><span class=\"line\">    fig_width=<span class=\"number\">20</span>,</span><br><span class=\"line\">    features=FEATURES,</span><br><span class=\"line\">    order_to_plot=features_rearranged</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_48_0.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_48_0.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"png\"></p>\n<h2 id=\"2-4-SegmentBorzoi\"><a href=\"#2-4-SegmentBorzoi\" class=\"headerlink\" title=\"2.4 SegmentBorzoi\"></a>2.4 SegmentBorzoi</h2><p>SegmentBorzoi利用了<a href=\"https://www.nature.com/articles/s41588-024-02053-6\">Borzoi</a>，它移除了预测头，并将其替换为一个一维U-Net分割头，以<strong>预测序列中多种基因组元素的位置</strong>。</p>\n<h3 id=\"2-4-1-🔍-示例\"><a href=\"#2-4-1-🔍-示例\" class=\"headerlink\" title=\"2.4.1 🔍 示例\"></a>2.4.1 🔍 示例</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> haiku <span class=\"keyword\">as</span> hk</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax</span><br><span class=\"line\"><span class=\"keyword\">import</span> jax.numpy <span class=\"keyword\">as</span> jnp</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> nucleotide_transformer.borzoi.pretrained <span class=\"keyword\">import</span> get_pretrained_segment_borzoi_model</span><br><span class=\"line\"><span class=\"keyword\">from</span> nucleotide_transformer.enformer.features <span class=\"keyword\">import</span> FEATURES</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Initialize CPU as default JAX device. This makes the code robust to memory leakage on</span></span><br><span class=\"line\"><span class=\"comment\"># the devices.</span></span><br><span class=\"line\">jax.config.update(<span class=\"string\">&quot;jax_platform_name&quot;</span>, <span class=\"string\">&quot;cpu&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">backend = <span class=\"string\">&quot;cpu&quot;</span></span><br><span class=\"line\">devices = jax.devices(backend)</span><br><span class=\"line\">num_devices = <span class=\"built_in\">len</span>(devices)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Load model</span></span><br><span class=\"line\">parameters, state, forward_fn, tokenizer, config = get_pretrained_segment_borzoi_model()</span><br><span class=\"line\">forward_fn = hk.transform_with_state(forward_fn)</span><br><span class=\"line\">apply_fn = jax.pmap(forward_fn.apply, devices=devices, donate_argnums=(<span class=\"number\">0</span>,))</span><br><span class=\"line\">random_key = jax.random.PRNGKey(seed=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Replicate over devices</span></span><br><span class=\"line\">keys = jax.device_put_replicated(random_key, devices=devices)</span><br><span class=\"line\">parameters = jax.device_put_replicated(parameters, devices=devices)</span><br><span class=\"line\">state = jax.device_put_replicated(state, devices=devices)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get data and tokenize it</span></span><br><span class=\"line\">sequences = [<span class=\"string\">&quot;A&quot;</span> * <span class=\"number\">524_288</span>]</span><br><span class=\"line\">tokens_ids = [b[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\">tokens = jnp.stack([jnp.asarray(tokens_ids, dtype=jnp.int32)] * num_devices, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Infer</span></span><br><span class=\"line\">outs, state = apply_fn(parameters, state, keys, tokens)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Obtain the logits over the genomic features</span></span><br><span class=\"line\">logits = outs[<span class=\"string\">&quot;logits&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># Transform them on probabilities</span></span><br><span class=\"line\">probabilities = np.asarray(jax.nn.softmax(logits, axis=-<span class=\"number\">1</span>))[..., -<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get probabilities associated with intron</span></span><br><span class=\"line\">idx_intron = FEATURES.index(<span class=\"string\">&quot;intron&quot;</span>)</span><br><span class=\"line\">probabilities_intron = probabilities[..., idx_intron]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Intron probabilities shape: <span class=\"subst\">&#123;probabilities_intron.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-完整代码\"><a href=\"#2-4-2-完整代码\" class=\"headerlink\" title=\"2.4.2 完整代码\"></a>2.4.2 完整代码</h3><p>下述代码展示了如何对一个196608 bp （524288bp？）的序列进行推断并绘制概率图。模块导入、基因组下载、绘图函数如前所述，不再重复。</p>\n<p><strong>（1）实例化SegmentBorzoi推理函数</strong></p>\n<p>以下代码允许您下载SegmentBorzoi的权重。它会返回权重字典、haiku前向函数、分词器和配置字典。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parameters, state, forward_fn, tokenizer, config = get_pretrained_segment_borzoi_model()</span><br></pre></td></tr></table></figure>\n\n<pre><code>Downloading model&#39;s weights...\n</code></pre>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward_fn = hk.transform_with_state(forward_fn)</span><br><span class=\"line\">apply_fn = jax.pmap(forward_fn.apply, devices=devices, donate_argnums=(<span class=\"number\">0</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Put required quantities for the inference on the devices. This step is not</span></span><br><span class=\"line\"><span class=\"comment\"># reproduced in the second inference since the quantities will already be loaded</span></span><br><span class=\"line\"><span class=\"comment\"># on the devices !</span></span><br><span class=\"line\">random_key = jax.random.PRNGKey(seed=<span class=\"number\">0</span>)</span><br><span class=\"line\">keys = jax.device_put_replicated(random_key, devices=devices)</span><br><span class=\"line\">parameters = jax.device_put_replicated(parameters, devices=devices)</span><br><span class=\"line\">state = jax.device_put_replicated(state, devices=devices)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）DNA 序列分词</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_nucleotides = <span class=\"number\">524_288</span></span><br><span class=\"line\"></span><br><span class=\"line\">idx_start = <span class=\"number\">2650520</span></span><br><span class=\"line\">idx_stop = idx_start + num_nucleotides</span><br><span class=\"line\"></span><br><span class=\"line\">sequences = [chr20[idx_start:idx_stop]]</span><br><span class=\"line\">tokens_ids = [b[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\">tokens_str = [b[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> tokenizer.batch_tokenize(sequences)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># This stacks the batch so that it is repeated across the devices. This is done</span></span><br><span class=\"line\"><span class=\"comment\"># in order to allow for replication even if one has more than one device.</span></span><br><span class=\"line\"><span class=\"comment\"># To take advantage of the multiple devices and infer different sequences on</span></span><br><span class=\"line\"><span class=\"comment\"># each of the devices, make sure to change this line into a reshape.</span></span><br><span class=\"line\"><span class=\"comment\"># a reshape</span></span><br><span class=\"line\">tokens = jnp.stack([jnp.asarray(tokens_ids, dtype=jnp.int32)]*num_devices, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">tokens.shape</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<pre><code>(1, 1, 524288)\n</code></pre>\n<p><strong>（3）对生成的批次进行推断</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Infer</span></span><br><span class=\"line\">outs, state = apply_fn(parameters, state, keys, tokens) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Obtain the logits over the genomic features</span></span><br><span class=\"line\">logits = outs[<span class=\"string\">&quot;logits&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># Transform them on probabilities</span></span><br><span class=\"line\">probabilities = np.asarray(jax.nn.softmax(logits, axis=-<span class=\"number\">1</span>))[...,-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">probabilities.shape</span><br></pre></td></tr></table></figure>\n\n\n<pre><code>(1, 1, 196608, 14)\n</code></pre>\n<p><strong>（4）绘制该DNA序列中14个基因组特征的概率图</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plot_features(</span><br><span class=\"line\">    probabilities[<span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    probabilities.shape[-<span class=\"number\">2</span>],</span><br><span class=\"line\">    fig_width=<span class=\"number\">20</span>,</span><br><span class=\"line\">    features=FEATURES,</span><br><span class=\"line\">    order_to_plot=features_rearranged</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_61_0.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Segmentation_models%E5%AE%9E%E6%88%98_61_0.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"png\"></p>\n<h1 id=\"参考文献-📚\"><a href=\"#参考文献-📚\" class=\"headerlink\" title=\"参考文献 📚\"></a>参考文献 📚</h1><ul>\n<li>[1] de Almeida, B.P., Dalla-Torre, H., Richard, G. et al. Annotating the genome at single-nucleotide resolution with DNA foundation models. Nat Methods (2025). <a href=\"https://doi.org/10.1038/s41592-025-02881-2\">https://doi.org/10.1038/s41592-025-02881-2</a></li>\n</ul>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"使用DNA基础模型在单核苷酸分辨率上注释基因组","slug":"使用DNA基础模型在单核苷酸分辨率上注释基因组","date":"2025-11-13T11:26:15.000Z","updated":"2025-11-13T12:25:57.636Z","comments":true,"path":"api/articles/使用DNA基础模型在单核苷酸分辨率上注释基因组.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig01.webp","content":"<p>2025年9月，InstaDeep（英国伦敦）、BioNTech（德国美因茨）、哥本哈根大学计算机系等机构的Bernardo P. de Almeida、Hugo Dalla-Torre（共同第一作者）、Thomas Pierrot（通讯作者）等研究者在《Nature Methods》期刊发表了题为“Annotating the genome at single-nucleotide resolution with DNA foundation models”的学术文章。该文章报道了其开发的基因组注释模型家族（SegmentNT、SegmentEnformer、SegmentBorzoi），在基因组功能元件注释领域具有突破传统工具局限性、实现14种基因及调控元件单核苷酸分辨率精准注释的重要意义。</p>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1 前言\"></a>1 前言</h1><h2 id=\"1-1-研究背景\"><a href=\"#1-1-研究背景\" class=\"headerlink\" title=\"1.1 研究背景\"></a>1.1 研究背景</h2><p>基因组注释模型是现代生物学研究的核心工具，可直接从DNA序列中识别<code>基因</code>、<code>外显子-内含子</code>结构及其他<code>功能元件</code>。随着测序技术发展，已测序基因组数量呈指数增长，精准高效的DNA序列注释不仅有助于解析遗传结构，还对遗传变异预测、计算机模拟序列设计等应用至关重要。</p>\n<p>现有注释工具存在明显局限：基于隐马尔可夫模型的工具（如AUGUSTUS）虽具备单核苷酸分辨率，但难以建模生物复杂性，预测基因异构体和全染色体注释时需依赖实验数据；调控元件识别工具多针对特定元件单独开发，训练数据集规模有限且分布与实际应用场景差异大，泛化能力不足。</p>\n<p>DNA基础模型（参数达数亿至数十亿，训练数据达数千亿至数万亿token）的出现为解决上述问题提供了新思路，其可通过无监督或监督训练学习通用序列表征，适配多种下游任务。</p>\n<h2 id=\"1-2-研究目标\"><a href=\"#1-2-研究目标\" class=\"headerlink\" title=\"1.2 研究目标\"></a>1.2 研究目标</h2><p><code>将基因组注释问题构建为多标签语义分割任务</code>，利用预训练DNA基础模型微调，开发能在单核苷酸分辨率下注释14种基因及调控元件的通用模型，突破传统工具的元件特异性和序列长度限制，提升跨物种泛化能力。</p>\n<h1 id=\"2-研究方法\"><a href=\"#2-研究方法\" class=\"headerlink\" title=\"2 研究方法\"></a>2 研究方法</h1><h2 id=\"2-1-基因组分割模型架构\"><a href=\"#2-1-基因组分割模型架构\" class=\"headerlink\" title=\"2.1 基因组分割模型架构\"></a>2.1 基因组分割模型架构</h2><h3 id=\"2-1-1-SegmentNT架构\"><a href=\"#2-1-1-SegmentNT架构\" class=\"headerlink\" title=\"2.1.1 SegmentNT架构\"></a>2.1.1 SegmentNT架构</h3><p><code>SegmentNT</code>以预训练DNA基础模型<code>Nucleotide Transformer</code>（NT-Multispecies-v2，500M参数）为DNA编码器，采用<code>6-mer</code>分词器提取序列嵌入特征（序列长度N与token数L满足$L≈N&#x2F;6$）。<u>模型替换NT的原始语言模型头，引入<code>1D U-Net</code>分割头，包含<code>2个下采样</code>卷积块和<code>2个上采样</code>卷积块，各块分别含2048和4096个卷积核，序列长度分别为 $L&#x2F;2$ 和 $L&#x2F;4$，总参数6300万</u>。</p>\n<p>U-Net输出张量形状为$(N, K, 2)$（K&#x3D;14种元件），经softmax层后<u>得到每个核苷酸属于每种元件的概率$P$及非概率$1-P$</u>。模型允许单个核苷酸属于多种元件，二元分类阈值设为<strong>0.5</strong>。</p>\n<h3 id=\"2-1-2-SegmentEnformer与SegmentBorzoi架构\"><a href=\"#2-1-2-SegmentEnformer与SegmentBorzoi架构\" class=\"headerlink\" title=\"2.1.2 SegmentEnformer与SegmentBorzoi架构\"></a>2.1.2 SegmentEnformer与SegmentBorzoi架构</h3><p><code>将Enformer和Borzoi作为DNA编码器</code>，其原始架构含卷积-下采样块及自注意力块（Enformer分辨率128 bp，Borzoi分辨率32 bp）。在两模型最后一层表征（预测头前）添加U-Net分割头，分别命名为SegmentEnformer和SegmentBorzoi，保持与SegmentNT一致的训练和验证超参数。</p>\n<h2 id=\"2-2-模型训练与评估\"><a href=\"#2-2-模型训练与评估\" class=\"headerlink\" title=\"2.2 模型训练与评估\"></a>2.2 模型训练与评估</h2><h3 id=\"2-2-1-训练参数\"><a href=\"#2-2-1-训练参数\" class=\"headerlink\" title=\"2.2.1 训练参数\"></a>2.2.1 训练参数</h3><ul>\n<li><strong>优化器</strong>：Adam，学习率$5×10^{-5}$</li>\n<li><strong>批次大小</strong>：256</li>\n<li><strong>训练数据量</strong>：SegmentNT-3kb模型训练102.4亿token（2048万条序列），10kb、20kb、30kb模型基于前一尺寸最佳检查点初始化并微调（如30kb模型额外训练25.6亿token，51万条序列）</li>\n<li><strong>损失函数</strong>：焦点损失（$γ&#x3D;2$），聚焦稀疏元件对应的“困难样本”</li>\n<li><strong>硬件</strong>：8块H100 GPU，训练时长20小时（3kb模型）</li>\n</ul>\n<h3 id=\"2-2-2-数据集分割\"><a href=\"#2-2-2-数据集分割\" class=\"headerlink\" title=\"2.2.2 数据集分割\"></a>2.2.2 数据集分割</h3><p><strong>按染色体划分训练集、验证集和测试集</strong>：20、21号染色体为测试集，22号为验证集，其余为训练集。<u>排除测试集中与训练&#x2F;验证集基因同源的片段（未剔除可能影响这些区域性能的同源远端调控元件）</u>，验证集和测试集采用固定滑动窗口采样，测试集进行10次随机采样以计算置信区间。</p>\n<h3 id=\"2-2-3-评估指标\"><a href=\"#2-2-3-评估指标\" class=\"headerlink\" title=\"2.2.3 评估指标\"></a>2.2.3 评估指标</h3><ul>\n<li><strong>核苷酸水平指标</strong>：马修斯相关系数（MCC）、精确率-召回率曲线下面积（auPRC）、雅卡尔相似度（Jaccard）、F1分数</li>\n<li><strong>区域水平指标</strong>：片段重叠分数（SOV），使用默认λ&#x3D;1.0 （代码： <a href=\"http://dna.cs.miami.edu/SOV/%EF%BC%89\">http://dna.cs.miami.edu/SOV/）</a></li>\n</ul>\n<h2 id=\"2-3-模型消融与基线设置\"><a href=\"#2-3-模型消融与基线设置\" class=\"headerlink\" title=\"2.3 模型消融与基线设置\"></a>2.3 模型消融与基线设置</h2><h3 id=\"2-3-1-消融实验模型\"><a href=\"#2-3-1-消融实验模型\" class=\"headerlink\" title=\"2.3.1 消融实验模型\"></a>2.3.1 消融实验模型</h3><ol>\n<li>以NT v1 2.5B 1000G模型为骨干（总参数26亿）</li>\n<li>仅微调U-Net分割头的SegmentNT-3kb模型（5.63亿参数）</li>\n<li>编码器随机初始化的SegmentNT模型（全参数训练或仅训练分割头）</li>\n<li>直接输入one-hot编码的U-Net模型（6300万或2.52亿参数）</li>\n<li>one-hot编码经线性层扩展至1024维嵌入的U-Net模型（6600万参数）</li>\n</ol>\n<h3 id=\"2-3-2-基线模型\"><a href=\"#2-3-2-基线模型\" class=\"headerlink\" title=\"2.3.2 基线模型\"></a>2.3.2 基线模型</h3><ul>\n<li><strong>BPNet</strong>：2个版本（嵌入维度64对应12万参数，1024对应2900万参数）</li>\n<li><strong>SpliceAI</strong>：3个版本（嵌入维度32对应70万参数，256对应4400万参数，920对应5.73亿参数）</li>\n</ul>\n<h2 id=\"2-4-上下文长度扩展方法\"><a href=\"#2-4-上下文长度扩展方法\" class=\"headerlink\" title=\"2.4 上下文长度扩展方法\"></a>2.4 上下文长度扩展方法</h2><p>由于SegmentNT的DNA编码器采用的旋转位置编码（RoPE）在训练时的最大序列长度为2048个token，因此在对更长序列进行推理时，其性能会迅速下降。此前已有多项研究提出了对RoPE的改进方案，以更好地处理长序列的评估或微调任务，例如采用位置插值法或“NTK感知的缩放旋转位置编码”（NTK-aware scaled RoPE）。</p>\n<p>Peng等人提出了一种适用于未见过序列长度的RoPE适配方案，名为YaRN。经过测试，与直接使用“NTK感知的缩放旋转位置编码”相比，YaRN在扩展SegmentNT的序列长度方面并未带来性能提升。由于后者的实现更为简便，作者最终选择采用该方法来扩展SegmentNT的上下文长度。</p>\n<p>设隐藏层神经元集合为(D)，序列向量为$(x_{1}, …, x_{L} \\in \\mathbb{R}^{|D|})$，则“NTK感知的旋转位置编码”可通过以下公式描述：</p>\n<p>$f^′_{w}(x_{m}, m, θ_{d}) &#x3D; f_{w}(x_{m}, g(m), h(θ_{d}))$</p>\n<p>其中，(d)表示嵌入维度上的位置，(m)表示嵌入在序列中的位置，(J)为RoPE函数，(w)表示可学习参数（权重），$(g(m)&#x3D;m)$，$(h(\\theta_{d})&#x3D;b^{\\prime-\\frac{2d}{|D|}})$，$(b’&#x3D;b \\cdot s^{\\frac{|D|}{|D|-2}})$，最终满足$(\\frac{2\\pi}{\\theta_{d}}&#x3D;2\\pi b^{\\frac{2d}{10}})$。</p>\n<p>为完整说明，(b)是旋转位置编码中使用的指数基，(b’)是对(b)进行缩放后的版本，用于适配NTK感知的缩放逻辑和上下文长度。缩放因子(s)的计算方式为$(s&#x3D;\\frac{L’}{L})$，其中(L’)为扩展后的上下文长度，(L)为训练时的上下文长度（对于NT-Multispecies-v2（500M）模型，(L&#x3D;2048)个token）。</p>\n<p>对于采用“NTK感知的旋转位置编码”训练的SegmentNT模型，所有长度小于其训练长度的序列，在评估时均使用训练过程中采用的同一缩放因子。具体而言，SegmentNT-30kb模型的训练缩放因子(s&#x3D;2.44)，因此对长度小于30,000 bp的序列进行推理时，仍使用(s&#x3D;2.44)；而对50 kb序列进行评估时，缩放因子则调整为(s&#x3D;4.07)。</p>\n<h2 id=\"2-5-多物种训练\"><a href=\"#2-5-多物种训练\" class=\"headerlink\" title=\"2.5 多物种训练\"></a>2.5 多物种训练</h2><p>基于人类SegmentNT-30kb模型，加入小鼠（mm10）、鸡（galGal6）、果蝇（dm6）、斑马鱼（danRer11）、秀丽隐杆线虫（ce11）的注释数据进行微调，得到多物种模型。各物种数据权重：人类5、小鼠4、鸡&#x2F;果蝇&#x2F;斑马鱼2、线虫1。各物种单独划分验证集和测试集（如小鼠：验证集chr19，测试集chr18）。</p>\n<h2 id=\"2-6-基因组注释数据来源\"><a href=\"#2-6-基因组注释数据来源\" class=\"headerlink\" title=\"2.6 基因组注释数据来源\"></a>2.6 基因组注释数据来源</h2><h3 id=\"2-6-1-人类基因组元件数据\"><a href=\"#2-6-1-人类基因组元件数据\" class=\"headerlink\" title=\"2.6.1 人类基因组元件数据\"></a>2.6.1 人类基因组元件数据</h3><p>14种元件分为基因元件（蛋白质编码基因、长链非编码RNA、5’UTR、3’UTR、外显子、内含子、剪接受体位点、剪接供体位点）和调控元件（多聚腺苷酸信号、组织不变型&#x2F;组织特异性启动子、组织不变型&#x2F;组织特异性增强子、CTCF结合位点）。基因元件和多聚腺苷酸信号来自GENCODE V44注释（排除三级转录本），调控元件来自ENCODE的SCREEN数据库。</p>\n<h3 id=\"2-6-2-多物种数据集\"><a href=\"#2-6-2-多物种数据集\" class=\"headerlink\" title=\"2.6.2 多物种数据集\"></a>2.6.2 多物种数据集</h3><p>聚焦7种核心基因元件（蛋白质编码基因、5’UTR、3’UTR、外显子、内含子、剪接受体位点、剪接供体位点），注释数据来自Ensembl数据库。测试集含10种动物（如野牛、鲸鱼、猫等）和5种植物（拟南芥、大豆、水稻、小麦、玉米）。</p>\n<h2 id=\"2-7-基准测试方法\"><a href=\"#2-7-基准测试方法\" class=\"headerlink\" title=\"2.7 基准测试方法\"></a>2.7 基准测试方法</h2><h3 id=\"2-7-1-基因注释基准\"><a href=\"#2-7-1-基因注释基准\" class=\"headerlink\" title=\"2.7.1 基因注释基准\"></a>2.7.1 基因注释基准</h3><p>与AUGUSTUS在三种场景对比：30kb基因片段（仅主异构体）、30kb基因片段（所有异构体）、全染色体（所有异构体），评估指标为F1分数、MCC、精确率、召回率、SOV。</p>\n<h3 id=\"2-7-2-剪接位点预测基准\"><a href=\"#2-7-2-剪接位点预测基准\" class=\"headerlink\" title=\"2.7.2 剪接位点预测基准\"></a>2.7.2 剪接位点预测基准</h3><p>与SpliceAI、Pangolin在两种测试集对比：SpliceAI的mRNA测试集（适配30kb窗口，移除含N序列）、SegmentNT的全染色体测试集（仅保留正义链基因），评估指标为auPRC、MCC、top-k准确率。</p>\n<h3 id=\"2-7-3-调控元件定位基准\"><a href=\"#2-7-3-调控元件定位基准\" class=\"headerlink\" title=\"2.7.3 调控元件定位基准\"></a>2.7.3 调控元件定位基准</h3><p>与滑动窗口方法（NT微调模型、DeePromoter）对比，将组织不变型和组织特异性启动子&#x2F;增强子合并为单一类别，评估指标为auPRC，计算单A100 GPU上的推理时间。</p>\n<h1 id=\"3-实验结果\"><a href=\"#3-实验结果\" class=\"headerlink\" title=\"3 实验结果\"></a>3 实验结果</h1><h2 id=\"3-1-SegmentNT：DNA序列核苷酸分辨率分割模型\"><a href=\"#3-1-SegmentNT：DNA序列核苷酸分辨率分割模型\" class=\"headerlink\" title=\"3.1 SegmentNT：DNA序列核苷酸分辨率分割模型\"></a>3.1 SegmentNT：DNA序列核苷酸分辨率分割模型</h2><h3 id=\"3-1-1-模型性能基础表现\"><a href=\"#3-1-1-模型性能基础表现\" class=\"headerlink\" title=\"3.1.1 模型性能基础表现\"></a>3.1.1 模型性能基础表现</h3><p>SegmentNT-3kb在14种元件上表现出高核苷酸分辨率定位能力，外显子、剪接位点、3’UTR和组织不变型启动子的测试MCC均高于0.5，长链非编码RNA和CTCF结合位点最难预测（MCC低于0.1）。</p>\n<p>SegmentNT-10kb（平均MCC 0.42）性能优于3kb版本（0.37），蛋白质编码基因、3’UTR、外显子和内含子的提升尤为显著，表明这些元件依赖更长序列上下文（如图1c所示）。</p>\n<h3 id=\"3-1-2-基因位点注释示例\"><a href=\"#3-1-2-基因位点注释示例\" class=\"headerlink\" title=\"3.1.2 基因位点注释示例\"></a>3.1.2 基因位点注释示例</h3><p>在包含NOP56基因（正义链）和IDH3B基因（反义链）的10kb窗口中，SegmentNT-10kb准确预测了两种基因的蛋白质编码属性、5’UTR和3’UTR位置、剪接位点、外显子-内含子结构及多聚腺苷酸信号，同时捕获了NOP56基因的组织特异性和组织不变型启动子，以及区域内的多个增强子（如图1d所示）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig01.webp\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig01.webp\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1 SegmentNT在核苷酸分辨率下定位基因组元件\"></p>\n<p><font size=2 color='grey'>图注：a. SegmentNT神经网络架构，含预训练DNA编码器（NT22）和U-Net分割头，输出各基因组元件的核苷酸分辨率概率；b. 1D U-Net分割头结构，含2个下采样和2个上采样卷积块及跳跃连接，标注各层维度（N为核苷酸数，L为DNA token数，$L≈N&#x2F;6$）；c. SegmentNT-3kb和10kb模型在14种基因组元件上的MCC性能（数据为10次测试集采样的均值±95%置信区间）；d. NOP56&#x2F;IDH3B基因位点的14种元件注释及预测概率示例，含基因异构体、外显子-内含子结构及调控元件；e. SegmentNT与不同消融模型和架构的性能对比（指标为MCC、Jaccard、F1、auPRC、SOV，数据为14种元件的均值±标准差，列归一化颜色标度）。</font></p>\n<h2 id=\"3-2-预训练DNA编码器的核心作用\"><a href=\"#3-2-预训练DNA编码器的核心作用\" class=\"headerlink\" title=\"3.2 预训练DNA编码器的核心作用\"></a>3.2 预训练DNA编码器的核心作用</h2><h3 id=\"3-2-1-消融实验结果\"><a href=\"#3-2-1-消融实验结果\" class=\"headerlink\" title=\"3.2.1 消融实验结果\"></a>3.2.1 消融实验结果</h3><p>直接输入one-hot编码的U-Net模型性能显著降低，平均MCC仅0.07-0.11，远低于SegmentNT-3kb的0.37，证明DNA编码器的重要性。</p>\n<p>随机初始化NT编码器的模型，平均MCC仅0.16，且收敛速度比预训练编码器模型慢7倍，表明基因组自监督预训练能大幅提升模型性能。</p>\n<p>同时微调NT编码器和U-Net头的模型性能最优，且基于多物种预训练NT的SegmentNT优于人类基因组预训练NT模型（如图1e所示）。</p>\n<h3 id=\"3-2-2-与基线模型对比\"><a href=\"#3-2-2-与基线模型对比\" class=\"headerlink\" title=\"3.2.2 与基线模型对比\"></a>3.2.2 与基线模型对比</h3><p>原始SpliceAI架构（平均MCC 0.18）性能优于BPNet（0.10）、U-Net和随机初始化NT模型，缩放后SpliceAI平均MCC达0.27，但仍远低于SegmentNT-3kb的0.37（如图1e所示）。</p>\n<h2 id=\"3-3-SegmentNT对长序列的泛化能力\"><a href=\"#3-3-SegmentNT对长序列的泛化能力\" class=\"headerlink\" title=\"3.3 SegmentNT对长序列的泛化能力\"></a>3.3 SegmentNT对长序列的泛化能力</h2><h3 id=\"3-3-1-不同长度模型性能对比\"><a href=\"#3-3-1-不同长度模型性能对比\" class=\"headerlink\" title=\"3.3.1 不同长度模型性能对比\"></a>3.3.1 不同长度模型性能对比</h3><p>随着训练序列长度增加（3kb→10kb→20kb→30kb），模型平均MCC持续提升，SegmentNT-30kb达到最高（0.45），蛋白质编码基因、3’UTR、外显子和内含子的性能改善尤为明显（如图2a、2b所示）。</p>\n<h3 id=\"3-3-2-上下文长度扩展效果\"><a href=\"#3-3-2-上下文长度扩展效果\" class=\"headerlink\" title=\"3.3.2 上下文长度扩展效果\"></a>3.3.2 上下文长度扩展效果</h3><p>SegmentNT-10kb经上下文扩展后，在长序列上性能显著提升：100kb序列的平均MCC从0.07提升至0.26（如图2c所示）。</p>\n<p>所有SegmentNT模型中，SegmentNT-30kb在各序列长度下均表现最佳，50kb序列输入时平均MCC达0.47，100kb时仍保持0.45的高值（如图2d所示）。</p>\n<h3 id=\"3-3-3-长序列注释示例\"><a href=\"#3-3-3-长序列注释示例\" class=\"headerlink\" title=\"3.3.3 长序列注释示例\"></a>3.3.3 长序列注释示例</h3><p>在含TMEM230&#x2F;PCNA&#x2F;CDS2三个重叠基因的50kb区域，SegmentNT-30kb准确预测了所有14种元件的位置和概率，单次输出70万个预测结果（14×50000）（如图2e所示）。</p>\n<h3 id=\"3-3-4-错误预测分析\"><a href=\"#3-3-4-错误预测分析\" class=\"headerlink\" title=\"3.3.4 错误预测分析\"></a>3.3.4 错误预测分析</h3><p>所有元件的错误预测不仅集中在区域边缘，还富集于标记区域内部，调控元件的内部错误预测占比高于边缘，表明性能瓶颈源于部分区域的整体预测效果不佳，而非边缘效应。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig02.webp\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig02.webp\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2 SegmentNT在不同序列长度下的适配与泛化\"></p>\n<p><font size=2 color='grey'>图注：a. 不同长度SegmentNT模型在14种元件上的MCC性能（数据为10次测试集采样的均值±95%置信区间）；b. 各模型在14种元件上的平均MCC（数据为14种元件的均值±95%置信区间，每种元件经10次采样）；c. 上下文扩展对SegmentNT-10kb在不同长度序列上的性能影响（平均MCC）；d. 各SegmentNT模型在不同输入序列长度下的平均MCC（虚线为50kb最优推理长度）；e. TMEM230&#x2F;PCNA&#x2F;CDS2基因位点50kb区域的14种元件注释及预测概率示例。</font></p>\n<h2 id=\"3-4-不同基础模型作为DNA编码器的性能对比\"><a href=\"#3-4-不同基础模型作为DNA编码器的性能对比\" class=\"headerlink\" title=\"3.4 不同基础模型作为DNA编码器的性能对比\"></a>3.4 不同基础模型作为DNA编码器的性能对比</h2><h3 id=\"3-4-1-30kb输入序列下的性能\"><a href=\"#3-4-1-30kb输入序列下的性能\" class=\"headerlink\" title=\"3.4.1 30kb输入序列下的性能\"></a>3.4.1 30kb输入序列下的性能</h3><p>SegmentNT平均MCC（0.45）优于SegmentEnformer（0.34）和SegmentBorzoi（0.35）。SegmentNT在基因元件（蛋白质编码基因、UTR、外显子等）和短序列元件（剪接位点、多聚腺苷酸信号）上表现突出，而SegmentEnformer和SegmentBorzoi在长链非编码RNA、CTCF结合位点及调控元件上性能更优（如图3b、3c所示）。</p>\n<h3 id=\"3-4-2-扩展输入序列长度后的性能\"><a href=\"#3-4-2-扩展输入序列长度后的性能\" class=\"headerlink\" title=\"3.4.2 扩展输入序列长度后的性能\"></a>3.4.2 扩展输入序列长度后的性能</h3><p>SegmentEnformer（196kb输入）和SegmentBorzoi（524kb输入）相较于30kb版本性能整体提升，蛋白质编码基因、长链非编码RNA和内含子的改善最为显著。SegmentBorzoi在UTR区域的额外提升源于其RNA测序数据预训练（如图3b、3c所示）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig03.webp\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig03.webp\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3 不同基础模型作为DNA编码器的性能对比\"></p>\n<p><font size=2 color='grey'>图注：a. SegmentNT、SegmentEnformer、SegmentBorzoi的架构示意图（括号内为输入输出维度，Enformer输出对应128bp bins，Borzoi对应32bp bins）；b. 不同模型在14种元件上的MCC性能（数据为10次测试集采样的均值±95%置信区间）；c. 各模型在14种元件上的平均MCC（数据为14种元件的均值±95%置信区间）。</font></p>\n<h2 id=\"3-5-与现有基因注释工具的对比\"><a href=\"#3-5-与现有基因注释工具的对比\" class=\"headerlink\" title=\"3.5 与现有基因注释工具的对比\"></a>3.5 与现有基因注释工具的对比</h2><h3 id=\"3-5-1-主异构体注释场景\"><a href=\"#3-5-1-主异构体注释场景\" class=\"headerlink\" title=\"3.5.1 主异构体注释场景\"></a>3.5.1 主异构体注释场景</h3><p>SegmentNT-30kb在剪接供体位点上性能优于AUGUSTUS，内含子和剪接受体位点性能相当，编码序列（CDS）区域因精确率较低表现稍差（如图4a、4b所示）。</p>\n<h3 id=\"3-5-2-所有异构体注释场景\"><a href=\"#3-5-2-所有异构体注释场景\" class=\"headerlink\" title=\"3.5.2 所有异构体注释场景\"></a>3.5.2 所有异构体注释场景</h3><p>在30kb基因片段和全染色体测试集中，SegmentNT-30kb在所有基因元件上的F1分数和MCC均优于AUGUSTUS，且兼具更高的精确率和召回率（如图4c、4d、4e所示）。</p>\n<h3 id=\"3-5-3-区域水平评估\"><a href=\"#3-5-3-区域水平评估\" class=\"headerlink\" title=\"3.5.3 区域水平评估\"></a>3.5.3 区域水平评估</h3><p>基于SOV分数的区域水平评估显示，SegmentNT-30kb在所有场景下仍优于AUGUSTUS，但全染色体测试集的性能提升幅度小于核苷酸水平指标（如图4f、4g、4h所示）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig04.webp\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig04.webp\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图4 与AUGUSTUS基因预测性能对比\"></p>\n<p><font size=2 color='grey'>图注：a、c、d. 不同数据集（主异构体30kb片段、所有异构体30kb片段、所有异构体全染色体）中两种模型在各基因元件上的F1分数；b. 主异构体30kb片段数据集的精确率-召回率曲线；e. 所有异构体全染色体数据集的精确率-召回率曲线；f、g、h. 不同数据集下的SOV分数（误差线为95%置信区间，全染色体数据为10次采样均值±95%置信区间）。</font></p>\n<h2 id=\"3-6-剪接位点预测性能\"><a href=\"#3-6-剪接位点预测性能\" class=\"headerlink\" title=\"3.6 剪接位点预测性能\"></a>3.6 剪接位点预测性能</h2><h3 id=\"3-6-1-基因位点示例\"><a href=\"#3-6-1-基因位点示例\" class=\"headerlink\" title=\"3.6.1 基因位点示例\"></a>3.6.1 基因位点示例</h3><p>在EBF4基因位点，SegmentNT-30kb准确预测了所有外显子、内含子及剪接位点（包括起始处的可变外显子），而SpliceAI和Pangolin存在转录本边界外的假阳性预测（如图5a所示）。</p>\n<h3 id=\"3-6-2-mRNA测试集性能\"><a href=\"#3-6-2-mRNA测试集性能\" class=\"headerlink\" title=\"3.6.2 mRNA测试集性能\"></a>3.6.2 mRNA测试集性能</h3><p>SegmentNT-30kb与SpliceAI、Pangolin性能相当：剪接供体位点auPRC均为0.93-0.94，剪接受体位点auPRC为0.93-0.96（如图5b、5c、5d所示）。</p>\n<h3 id=\"3-6-3-全染色体测试集性能\"><a href=\"#3-6-3-全染色体测试集性能\" class=\"headerlink\" title=\"3.6.3 全染色体测试集性能\"></a>3.6.3 全染色体测试集性能</h3><p>SegmentNT-30kb的MCC高于SpliceAI和Pangolin，auPRC表现相当（剪接供体0.68-0.74，剪接受体0.70-0.72），剪接供体位点的top-k准确率更优（如图5e、5f、5g所示）。</p>\n<h3 id=\"3-6-4-非编码RNA剪接位点预测\"><a href=\"#3-6-4-非编码RNA剪接位点预测\" class=\"headerlink\" title=\"3.6.4 非编码RNA剪接位点预测\"></a>3.6.4 非编码RNA剪接位点预测</h3><p>SegmentNT和Pangolin在非编码RNA剪接位点上的性能低于SpliceAI，提示编码序列的相关信号可能驱动剪接检测性能（补充图6c）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig05.webp\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig05.webp\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图5 SegmentNT在剪接位点预测上的性能\"></p>\n<p><font size=2 color='grey'>图注：a. EBF4基因位点的剪接元件预测示例（红色星号标记SpliceAI&#x2F;Pangolin的错误预测区域）；b. mRNA测试集上的MCC性能（误差线为100次自助抽样的95%置信区间）；c、d. mRNA测试集的精确率-召回率曲线及auPRC值；e. 人类全染色体测试集的MCC性能；f、g. 人类全染色体测试集的精确率-召回率曲线及auPRC值；h. 多物种全染色体测试集的平均MCC；i、j. 多物种剪接供体&#x2F;受体位点的auPRC雷达图。</font></p>\n<h2 id=\"3-7-调控元件定位性能\"><a href=\"#3-7-调控元件定位性能\" class=\"headerlink\" title=\"3.7 调控元件定位性能\"></a>3.7 调控元件定位性能</h2><p>SegmentNT-30kb在启动子和增强子注释上优于滑动窗口基线模型，SegmentEnformer表现最佳（补充图7b、7c）。DeePromoter在 curated测试集上性能优异，但在基因组序列语境中泛化能力差于滑动窗口NT模型。</p>\n<p>SegmentNT家族模型的推理速度更快，单次完成所有核苷酸预测，适用于遗传变异候选区域和个性化基因组的快速评估（补充图7d）。</p>\n<h2 id=\"3-8-SegmentNT的跨物种泛化能力\"><a href=\"#3-8-SegmentNT的跨物种泛化能力\" class=\"headerlink\" title=\"3.8 SegmentNT的跨物种泛化能力\"></a>3.8 SegmentNT的跨物种泛化能力</h2><h3 id=\"3-8-1-人类模型的跨物种表现\"><a href=\"#3-8-1-人类模型的跨物种表现\" class=\"headerlink\" title=\"3.8.1 人类模型的跨物种表现\"></a>3.8.1 人类模型的跨物种表现</h3><p>人类SegmentNT-30kb模型在不同物种中均表现出高性能，外显子和剪接位点的MCC最高（与进化保守性相关）。亲缘关系较近的物种（如大猩猩、猕猴）性能较好，进化距离较远的动物和植物性能下降（如图6b、6c所示）。</p>\n<h3 id=\"3-8-2-物种进化距离与性能关联\"><a href=\"#3-8-2-物种进化距离与性能关联\" class=\"headerlink\" title=\"3.8.2 物种进化距离与性能关联\"></a>3.8.2 物种进化距离与性能关联</h3><p>随着与人类的分化时间增加，各基因元件的MCC呈下降趋势，外显子和剪接位点的下降幅度最小（如图6c所示）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig06.webp\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/03/Fig06.webp\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图6 SegmentNT的跨物种泛化能力\"></p>\n<p><font size=2 color='grey'>图注：a. 多物种模型微调与跨物种评估示意图；b. 人类模型在各物种基因元件上的MCC性能（按与人类的分化时间排序）；c. 基因元件MCC与进化分化时间的关联（相同进化距离物种的MCC均值）；d-g. 人类模型与多物种模型在训练物种、近缘动物、远缘动物、植物上的性能雷达图；h. 四种代表性物种的各元件MCC对比；i. 与AUGUSTUS在不同物种基因注释上的平均MCC对比（误差线为95%置信区间）。</font></p>\n<h2 id=\"3-9-多物种SegmentNT模型的泛化提升\"><a href=\"#3-9-多物种SegmentNT模型的泛化提升\" class=\"headerlink\" title=\"3.9 多物种SegmentNT模型的泛化提升\"></a>3.9 多物种SegmentNT模型的泛化提升</h2><h3 id=\"3-9-1-训练物种性能\"><a href=\"#3-9-1-训练物种性能\" class=\"headerlink\" title=\"3.9.1 训练物种性能\"></a>3.9.1 训练物种性能</h3><p>多物种模型在训练物种的测试染色体上性能优于人类模型（如图6d所示）。</p>\n<h3 id=\"3-9-2-未见过物种的泛化\"><a href=\"#3-9-2-未见过物种的泛化\" class=\"headerlink\" title=\"3.9.2 未见过物种的泛化\"></a>3.9.2 未见过物种的泛化</h3><ul>\n<li>人类近缘动物（分化时间&lt;1000万年）：两模型性能相当（平均MCC 0.62 vs 0.64）</li>\n<li>人类远缘动物（分化时间&gt;1000万年）：多物种模型平均MCC从0.49提升至0.57</li>\n<li>植物物种：多物种模型平均MCC从0.34提升至0.45，即使未经过植物基因组训练仍表现出显著改善（如图6e、6f、6g所示）。</li>\n</ul>\n<h3 id=\"3-9-3-与AUGUSTUS的对比\"><a href=\"#3-9-3-与AUGUSTUS的对比\" class=\"headerlink\" title=\"3.9.3 与AUGUSTUS的对比\"></a>3.9.3 与AUGUSTUS的对比</h3><p>多物种模型在除拟南芥外的所有物种上，基因注释性能均优于AUGUSTUS（如图6i所示）。</p>\n<h1 id=\"4-讨论\"><a href=\"#4-讨论\" class=\"headerlink\" title=\"4 讨论\"></a>4 讨论</h1><h2 id=\"4-1-核心结论\"><a href=\"#4-1-核心结论\" class=\"headerlink\" title=\"4.1 核心结论\"></a>4.1 核心结论</h2><ol>\n<li>提出的DNA基础模型微调方法，实现了14种基因组元件的单核苷酸分辨率注释，SegmentNT模型可处理长达50kb的DNA序列，单次输出70万个预测结果，效率显著。</li>\n<li>预训练DNA编码器是模型高性能的关键，相较于直接使用one-hot编码或随机初始化编码器，性能提升显著，且上下文长度扩展方法有效突破了序列长度限制。</li>\n<li>不同DNA编码器各具优势：SegmentNT在基因元件和短序列元件上表现最佳，SegmentEnformer和SegmentBorzoi在调控元件上更具优势，可根据任务需求选择。</li>\n<li>人类SegmentNT模型具有天然的跨物种泛化能力，多物种模型进一步提升了对远缘动物和植物的注释性能，为未充分研究物种的基因组注释提供了高效工具。</li>\n</ol>\n<h2 id=\"4-2-研究展望\"><a href=\"#4-2-研究展望\" class=\"headerlink\" title=\"4.2 研究展望\"></a>4.2 研究展望</h2><ol>\n<li>扩展SegmentNT的上下文长度，结合自然语言处理领域的长序列建模技术和状态空间模型，开发下一代模型。</li>\n<li>细化调控元件分类，按细胞类型拆分启动子和增强子，提升细胞类型特异性调控密码的预测精度。</li>\n<li>探索SegmentNT在遗传变异影响评估、癌症基因组分析等领域的应用，整合实验数据进一步优化注释流程。</li>\n<li>扩充多物种模型的训练物种范围，纳入更多植物物种及基因组重排显著的物种，提升序列多样性覆盖。</li>\n</ol>\n<h1 id=\"数据获取说明\"><a href=\"#数据获取说明\" class=\"headerlink\" title=\"数据获取说明\"></a>数据获取说明</h1><p>SegmentNT训练数据来源于公开资源。基因注释数据来自gencode（<a href=\"https://www.gencodegenes.org/%EF%BC%89%E5%92%8CEnsembl%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88https://\">https://www.gencodegenes.org/）和Ensembl数据库（https://</a> <a href=\"http://www.ensembl.org).人类调控元件数据来自encode的筛选数据库(https//screen.wenglab.org/%EF%BC%89%E3%80%82\">www.ensembl.org）。人类调控元件数据来自encode的筛选数据库（https://screen.wenglab.org/）。</a> 进化距离数据取自生命时间树（<a href=\"https://timetree.org/\">Timetree of Life</a>）。SpliceAI测试集数据源自Illumina Basespace平台（<a href=\"https://basespace.illumina.com/projects/66029966/%EF%BC%89%E3%80%82\">https://basespace.illumina.com/projects/66029966/）。</a> 交互式浏览器会话，展示人类SegmentNT-30kb模型在测试染色体20和21上位于 <a href=\"https://tinyurl.com/23837bnl\">https://tinyurl.com/23837bnl</a> 区域的标签与预测结果。</p>\n<h1 id=\"代码资源说明\"><a href=\"#代码资源说明\" class=\"headerlink\" title=\"代码资源说明\"></a>代码资源说明</h1><p>人类及多物种SegmentNT-30kb模型、SegmentEnformer和SegmentBorzoi模型的模型权重，以及Jax语言的推理代码，可通过GitHub（<a href=\"https://github.com/instadeepai/nucleotide-transformer?tab=readme-ov-file#-segmentnt--family-segmentenformer-segmentborzoi\">https://github.com/instadeepai/nucleotide-transformer?tab=readme-ov-file#-segmentnt--family-segmentenformer-segmentborzoi</a>）获取研究使用。HuggingFace平台上的PyTorch版本模型可访问（<a href=\"https://huggingface.co/collections/InstaDeepAI/segmentnt-65eb4941c57808b4a3fe1319\">https:&#x2F;&#x2F; huggingface.co&#x2F;collections&#x2F;InstaDeepAI&#x2F;segmentnt-65eb4941c57 808b4a3fe1319</a>）。示例笔记本可在<a href=\"https://colab.research.google.com/#fileId=https\">Google Colab</a>获取。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li>[1] de Almeida, B.P., Dalla-Torre, H., Richard, G. et al. Annotating the genome at single-nucleotide resolution with DNA foundation models. Nat Methods (2025). <a href=\"https://doi.org/10.1038/s41592-025-02881-2\">https://doi.org/10.1038/s41592-025-02881-2</a></li>\n</ul>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"基因组语言模型的机遇与挑战","slug":"基因组语言模型的机遇与挑战","date":"2025-11-11T15:08:16.000Z","updated":"2025-11-11T15:11:30.465Z","comments":true,"path":"api/articles/基因组语言模型的机遇与挑战.json","excerpt":null,"keywords":null,"cover":"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig01.png","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>大型语言模型（LLMs）正在对广泛的科学领域产生变革性影响，尤其是在生物医学领域。正如自然语言处理（NLP）的目标是理解单词序列一样，生物学的一个主要目标是理解生物序列。基因组语言模型（gLMs）是在DNA序列上训练的大型语言模型，有望显著增进我们对基因组的理解，以及不同尺度的DNA元件如何相互作用以产生复杂功能。为展示这一潜力，我们重点介绍了基因组语言模型的关键应用，包括<code>功能约束预测</code>、<code>序列设计</code>和<code>迁移学习</code>。然而，尽管近期取得了显著进展，开发有效且高效的基因组语言模型仍面临诸多挑战，特别是对于具有大型复杂基因组的物种。在此，我们探讨了开发和评估基因组语言模型的主要考量因素。</p>\n<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h2><p>人工智能&#x2F;机器学习（AI&#x2F;ML）的最新进展对广泛的科学学科产生了深远影响，彻底改变了建模、数据分析、解释和发现的方法。这一发展的关键支柱之一是自监督学习，通过在大量未标记数据上进行训练，模型能够学习复杂特征及其相互作用。这种范式尤其改变了自然语言处理领域，使人工智能模型在多个具有挑战性的任务上达到人类水平，包括翻译、语音识别，甚至回答标准化专业和学术考试中的问题。</p>\n<p>正如自然语言处理的目标是理解自然语言序列一样，计算生物学的一个主要目标是理解生物序列。因此，近年来人们对将自然语言处理中的现代技术应用于生物序列（DNA、RNA、蛋白质）产生了浓厚兴趣。特别是，蛋白质序列数据库（如UniProt）在过去十年中呈指数级增长，在这些海量数据上训练的蛋白质语言模型（pLMs）在复杂问题上取得了令人印象深刻的性能，例如结构预测和变异效应预测等记的蛋白质序列数据集有望包含重要的生物信息。</p>\n<p>类似地，在DNA序列上训练的大型语言模型（LLMs）有望改变基因组学，但为基因组开发有效的模型面临额外的挑战。例如，与作为功能重要单元且尺寸相对较小的蛋白质不同，大多数基因组要大得多，并且通常包含大量复杂的非功能区域，这些区域在数量上超过了功能元件。此外，与数亿个蛋白质序列相比，整个生命树中可用的全基因组序列数量极少，这限制了训练数据中功能重要的DNA元件的多样性。尽管存在这些问题，我们认为在基因组上训练的语言模型——即基因组语言模型（gLMs）——对生物学具有巨大潜力。在本文中，我们回顾了该领域的一些关键机遇和挑战，<u>并概述了开发和评估对基因组学界有用的基因组语言模型应解决的主要考量因素</u>。</p>\n<h2 id=\"2-应用\"><a href=\"#2-应用\" class=\"headerlink\" title=\"2 应用\"></a>2 应用</h2><p>语言模型的通用框架总结在<code>BOX 1</code>中。下面，我们详细阐述基因组语言模型的三个主要应用领域：功能约束预测、序列设计和迁移学习。</p>\n<h3 id=\"2-1-功能约束预测\"><a href=\"#2-1-功能约束预测\" class=\"headerlink\" title=\"2.1 功能约束预测\"></a>2.1 功能约束预测</h3><p>基因组语言模型一个有趣的应用是在无需任何任务监督的情况下预测基因组位点的功能约束。这种方法的一个显著优势是它不依赖于标记（例如某个变异是否致病），而标记通常数量有限且存在偏差。其核心思想是，参考基因组（通常来自健康个体）中有害变异的含量相对较低。因此，在这些数据上训练的模型倾向于给有害变异分配较低的概率。这一观察结果为使用<strong>两个等位基因之间的对数似然比</strong>（LLR）——即$(\\log[\\mathbb{P}(X_{i}&#x3D;a|X_{-i})&#x2F;\\mathbb{P}(X_{i}&#x3D;b|X_{-i})])$——来估计它们的相对适应性提供了依据。</p>\n<p><font size=2 color='grey'><strong>BOX 1</strong>：通用语言模型框架</p>\n<p>从高层次来看，语言模型的训练目标是学习如下形式的条件概率分布：</p>\n<p>在掩码语言建模（MLM）中为 $(\\mathbb{P}[X_{i}|X_{- \\text{Masked}}])$（其中$(i \\in \\text{Masked})$），在因果语言建模（CLM）中为 $(\\mathbb{P}[X_{k}|X_{1:k-1}])$。这里，$(X&#x3D;(X_{1},X_{2},\\dots))$ 表示“标记”（如核苷酸或氨基酸）序列，“Masked”表示被掩码的位置集合。自然语言处理近期取得进展的关键在于，不再手动设计简单的上下文依赖参数模型，而是让数据自己说话，并通过利用强大的深度学习架构，随着观测数据的增加来拟合更复杂的模型。图1展示了用于DNA的语言建模框架。虽然模型训练的目的是利用未掩码位点的信息预测每个掩码位点的核苷酸，但它会学习位置特异性的上下文表示（称为嵌入，即一个高维向量），随后该向量会转换为在 ${A,C,G,T}$ 上的概率分布。这些嵌入和概率分布均具有位置特异性，可应用于基因组学中的许多问题。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig01.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig01.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1：基因组语言模型的训练和应用\"></p>\n<p><font size=2 color='grey'>左侧示意图展示了基因组语言模型的训练过程。两个等位基因之间的对数似然比（LLR，具体为$(\\log[\\mathbb{P}(X_{i}&#x3D;a|X_{-i})&#x2F;\\mathbb{P}(X_{i}&#x3D;b|X_{-i})])$）是功能约束的良好无监督预测因子（功能约束预测）。通过从学习到的概率分布中采样，可以生成新的序列（序列设计）。输入序列中每个标记的向量表示（称为嵌入）可以被提取出来，并适配于不同的下游任务（迁移学习）。</font></p>\n<p>在蛋白质序列模型中，最初引入了使用对数似然比进行功能约束预测的方法，在预测错义变异效应方面取得了出色成果。将这种方法扩展到基因组范围，GPN首次使用基因组语言模型进行全基因组功能约束预测，在模式植物拟南芥（<em>Arabidopsis thaliana</em>）中取得了最先进的结果。为说明基因组语言模型如何预测功能约束，我们注意到基因组语言模型能够学习<code>转录因子结合位点（TFBS）基序</code>，理解哪些位置受到约束，哪些位置不受约束（<strong>图2a</strong>）。此外，尽管<code>GPN</code>模型仅在拟南芥的一个基因组上训练，但它的对数似然比得分与拟南芥自然种群中的等位基因频率相关（<strong>图2b</strong>）。随后，<code>AgroNT</code>和<code>PlantCaduceus</code>在其他植物物种中也取得了优异结果。然而，对于人类基因组，核苷酸转换器（NT）的对数似然比性能低于现有的基准模型。与此同时，<code>GPNMSA</code>利用跨多种脊椎动物物种的全基因组多序列比对（MSA），实现了最先进的性能。需要注意的是，<u>观察到的核苷酸分布不仅受功能约束驱动，还受突变偏差影响；将此信息明确纳入功能约束预测是未来研究的一个有前景的方向</u>。</p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig02.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig02.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2：应用示例\"></p>\n<p><font size=2 color='grey'>（a）基因组语言模型在启动子区域预测的序列标志图（顶部），突出显示了与假定功能性转录因子结合位点匹配的基序（底部序列标志图）。（b）变异次要等位基因频率（MAF）与基因组语言模型得分（对数似然比）之间的相关性。（c）基因组语言模型可以用不同的控制标签提示，设计在特定细胞类型中驱动高表达或低表达的启动子序列。（d）不同基因组窗口类别的基因组语言模型嵌入可视化，表明学习到的表示包含有用信息，如基因区域。注：面板a、b、d使用GPN模型生成。</font></p>\n<p>对于单核苷酸多态性（SNP），在掩码语言模型中只需对变异位置进行一次掩码查询即可计算对数似然比，而在因果语言模型中则需要对参考序列和替代序列进行两次查询。因果语言模型可以轻松处理多个替换、插入和缺失，而掩码语言模型必须采用更耗时的伪对数似然比方法。除对数似然比外，还提出了其他用于功能约束预测的得分，例如嵌入空间中的距离或突变周围位置核苷酸概率的变化。尽管对数似然比在蛋白质语言模型和基因组语言模型领域都被广泛使用，但深入理解这些替代得分在哪些场景下有用仍然很重要。</p>\n<p>基因组学中有两类主要的变异效应预测器：<strong>一类是功能约束预测器</strong>，包括基因组语言模型和传统的保守性得分；<strong>另一类是活性预测器</strong>，如基因表达预测器<code>Enformer</code>或剪接预测器<code>SpliceAI</code>。这两类模型存在关联：如果某个位点的变异受到选择，它会在某些情况下诱导活性变化（例如，在肢体发育过程中某个基因的转录变化），最终影响高级性状（例如，多指畸形）。功能约束模型涵盖了影响整体生物体适应性的所有可能机制和场景，而活性模型仅反映了它们明确训练过的机制和场景（某些数据，如人类大脑发育过程中的蛋白质表达，获取难度较大）。另一方面，活性模型可以指出变异发挥作用的特定机制和场景，而功能约束模型则不提供机制解释。</p>\n<p>关于功能性变异的优先排序，还有一些额外的考量。对于两个在不同基因中引起相似表达倍数变化的变异，即使它们的表达水平在生理耐受性上存在巨大差异，活性模型通常也会给出相似的得分。另一方面，不受可检测选择影响的性状仍可能具有科学或医学意义。在这种情况下，功能约束模型在优先排序影响该性状的变异方面能力有限，尤其是当这些变异效应量较小时（如在复杂性状全基因组关联研究（GWAS）中常见的情况）。然而，尽管基因组语言模型的对数似然比在这种情况下可能效果不佳，但基因组语言模型学习到的嵌入（<strong>BOX 1</strong>）在有标记数据的额外监督下仍可能具有价值。</p>\n<h3 id=\"2-2-序列设计\"><a href=\"#2-2-序列设计\" class=\"headerlink\" title=\"2.2 序列设计\"></a>2.2 序列设计</h3><p>设计新的生物序列对学术界和工业界研究团体都极具吸引力，因为它在药物发现与递送、农业改良、生物修复以及生物研究工具开发等方面具有巨大潜力。在此，我们描述使用<code>因果语言模型</code>（<strong>BOX 1</strong>）进行序列生成的方法，这是最常用的方法。具体而言，序列生成任务被分解为一系列下一个标记预测问题。从给定的序列片段（称为提示或控制标签）开始，语言模型可以递归地预测下一个标记，从而生成完整的新序列。蛋白质语言模型已被证明是蛋白质设计的强大工具。除编码序列外，非编码序列的设计也至关重要，因为它在基因和细胞治疗以及合成生物学等领域有应用。此类设计任务以前通过有监督的活性模型解决，但最近有多项研究探索使用基因组语言模型来应对这一挑战，如下所述。</p>\n<p><code>regLM</code>模型基于因果基因组语言模型<code>HyenaDNA</code>构建，用于<strong>从头生成启动子和增强子序列</strong>。HyenaDNA模型在带有前置控制标签的调控序列上进行训练或微调。然后，使用训练好的模型生成带有给定标签的新调控序列（<strong>图2c</strong>）。作者在酵母和人类细胞系中对生成序列的多样性和活性进行了计算评估，证明这些序列具有预期的功能以及真实且多样的序列特征。</p>\n<p>基因组语言模型在多模态设计任务中具有独特潜力，例如通过将蛋白质-RNA复合物统一为DNA序列设计来生成此类复合物。<u>例如，在原核生物基因组上训练的基因组语言模型EVO被用于设计新的CRISPR-Cas系统</u>。该模型使用带有前置Cas亚型特异性提示的CRISPR-Cas序列数据集进行微调。微调后的模型能够生成与亚型提示匹配的新CRISPR-Cas序列，且其预测结构与天然存在的系统相似。</p>\n<p>此外，<u>基因组语言模型还有可能用于在染色体或基因组尺度上设计有组织的功能性DNA序列</u>。最近，两个基因组语言模型<code>MegaDNA</code>和<code>EVO</code>探索了原核生物基因组的此类设计任务。EVO用于生成20个约650 Mbp大小的序列。研究发现，生成的序列具有真实的编码序列密度、具有预测二级结构和球状折叠的蛋白质序列，以及合理的tRNA序列。MegaDNA用于生成长达96 kbp的完整噬菌体基因组。除验证编码序列外，作者还在生成的序列中识别出包括启动子和核糖体结合位点在内的功能性调控元件。然而，此类大规模DNA序列设计任务仍然具有挑战性。研究发现，<u>EVO生成的序列缺乏功能原核生物基因组中通常存在的高度保守标记基因，且预测的蛋白质结构与天然蛋白质数据库的匹配度有限。最近的一项独立评估表明，MegaDNA生成的基因组序列组成与天然基因组仍有很大差异</u>。因此，需要进一步研究改进方法，以实现使用基因组语言模型从头设计完全功能性的基因组。</p>\n<h3 id=\"2-3-迁移学习\"><a href=\"#2-3-迁移学习\" class=\"headerlink\" title=\"2.3 迁移学习\"></a>2.3 迁移学习</h3><p>通过功能基因组学实验训练的用于预测注释的神经网络已被广泛用于解释基因组元件的功能。<u>一个重要的应用是预测变异对分子表型的影响，例如基因表达和剪接</u>。神经网络能够解释基因组位点之间复杂相互作用的能力，使其成为解决这些重要问题的必备工具，但合适的训练数据通常难以收集，因此数量有限。为了在预测任务上实现泛化，模型需要能够识别广泛的功能重要序列元件，这可能需要大量的数据和计算资源。为克服单个任务数据不足的限制，开发者采用了迁移学习方法——即利用在一个任务上训练模型获得的知识来改进相关任务性能的技术。具体而言，大多数用于预测功能注释的神经网络都经过训练以同时预测多种注释，迫使这些模型学习单一的统一表示。这进而提高了它们的泛化性能。</p>\n<p>语言模型也可用于迁移学习（有关迁移学习在自然语言处理中的应用，请参见<strong>BOX 2</strong>）。一种技术是特征提取：在学习预测核苷酸的上下文依赖分布时，基因组语言模型将输入的基因组序列转换为中间向量表示<strong>BOX 1</strong>）。这些表示可能提炼了相关信息，因此可用作另一个模型的特征。例如，<u>基因组语言模型嵌入的可视化显示，在没有任何监督的情况下，模型已经学会区分不同类别的基因组元件，如编码序列和非翻译区（<strong>图2d</strong>）</u>。不同层的嵌入可以为不同任务提供有用信息。利用语言模型进行迁移学习的另一种方法是将其用作预训练模型，即在下游任务上继续训练它们。这种技术称为微调。在某个任务上微调预训练的神经网络，会隐式地对其参数进行正则化，使得网络的预测综合了来自两个任务的知识。因此，对神经网络进行预训练通常会提高其在下游任务上的泛化性能。在最近的研究中，<code>SegmentNT</code>模型（通过微调核苷酸转换器（NT）基因组语言模型以实现<strong>基因和顺式调控元件注释</strong>任务而开发）在该任务上取得了最先进的性能。研究表明，使用预训练模型是其取得成功的关键。类似地，NT家族的另一个模型<code>AgroNT</code>在多种植物物种上进行预训练，然后在选定的作物物种上微调以预测染色质可及性和基因表达。<code>DNABERT-S</code>将对比学习与预训练的<code>DNABERT-2</code>嵌入相结合，用于<strong>宏基因组分箱</strong>。<code>IsoFormer</code>是DNA和蛋白质语言模型之间多模态迁移学习的一个例子，用于<strong>预测转录本亚型表达</strong>。这些最近的成功表明，微调后的基因组语言模型可能在各种基因组解释任务上取得显著进展。</p>\n<p>最近有两项研究评估了多个基因组语言模型在人类基因组预测任务中的性能，发现它们通常不会优于非基因组语言模型基准。这些结果基于冻结的嵌入；评估完整的微调过程将提供更多见解。尽管基因组语言模型已经非常适合展示迁移学习在研究较少的生物体中的价值，但要使其在人类遗传学（已有高质量标记数据和精心设计的模型）中提供显著价值，可能还需要进一步的创新。一个重要的问题是，缩放假设对基因组语言模型的适用程度如何，即增加未标记数据和计算资源在多大程度上能持续提高模型性能。最近的一项蛋白质语言模型研究发现，缩放仅改进了蛋白质结构预测，而没有改进大多数其他任务（如功能或性质预测），因此基因组语言模型任务也应受到同样的审视。</p>\n<p><font size=2 color='grey'> <strong>BOX 2</strong>：自然语言处理中的迁移学习<br>为了在大多数任务（包括情感分析、问答和词性标注等典型任务）上实现泛化，自然语言处理模型需要理解语法和语义。然而，这些任务的特定数据通常有限。利用在原始文本数据（来源于文章、书籍和网站）上训练的大型语言模型进行迁移学习，已在这些问题上取得了突破性进展。如今，几乎所有最先进的自然语言处理模型都是从大型语言模型改编而来。</font></p>\n<p>迁移学习技术是近年来自然语言模型蓬勃发展的基础。特别是，可广泛适配于下游任务的预训练模型（称为“基础模型”）的出现，使得机器学习模型的开发方式发生了重大转变。</p>\n<h2 id=\"3-开发\"><a href=\"#3-开发\" class=\"headerlink\" title=\"3 开发\"></a>3 开发</h2><p>现在，我们描述开发有用的基因组语言模型的关键组成部分；<strong>图3</strong>展示了总结开发流程的示意图。我们首先阐述选择和准备训练数据的重要性，然后讨论架构和训练决策，接着考虑基因组语言模型的解释和基准测试。我们的目标是<u>深入了解开发有效且高效的基因组语言模型所涉及的方法和挑战</u>。为全面展示该领域的当前状况，我们在<strong>表1</strong>中列出了一些我们已知的现有基因组语言模型，并总结了它们的设计决策。</p>\n<h3 id=\"3-1-训练数据\"><a href=\"#3-1-训练数据\" class=\"headerlink\" title=\"3.1 训练数据\"></a>3.1 训练数据</h3><p>机器学习模型的性能在很大程度上受其架构和训练数据的影响。卷积神经网络（CNNs）、Transformer 和状态空间模型（SSMs）等各种模型架构已成功应用于广泛的领域，包括自然语言、图像、音频、蛋白质和基因组学。然而，为预训练选择合适的数据需要对特定领域有深入的理解，尤其是<u>在基因组学领域，目前尚无类似于自然语言处理（如Pile）或蛋白质生物学（如UniProt）中那样被普遍接受的精选数据集</u>。</p>\n<p><strong>一个关键的考量因素是数据质量</strong>。例如，在自然语言处理中，数据质量可能指经过编辑或同行评审的数据源，如科学文章或书籍。<u>在蛋白质领域，质量控制包括去除预测的假基因或不再具有功能的截断蛋白质</u>。然而，最近的一项研究发现，作为最常用的基因组语言模型训练数据集（<strong>表1</strong>）的人类参考基因组中，仅有3.3%的碱基受到显著约束且可能具有功能。重要的是，<u>用于训练基因组语言模型的典型基因组序列既包含<code>功能位点</code>，也包含<code>非功能位点</code>，且通常无法将训练样本明确分为<code>高质量</code>和<code>低质量</code>两类</u>。一个提出的解决方案是根据功能证据对训练损失进行碱基级加权。</p>\n<p>在自然语言处理和蛋白质领域，<strong>过滤重复序列</strong>是标准做法，这有助于提高训练效率并减少记忆。尽管人类基因组中高达50%的序列是重复序列（在真核生物中这一比例普遍较高），但很少有基因组语言模型研究提出解决方案（如降低权重或下采样），甚至很少有研究承认这一问题。如果语言模型困惑度的研究也能分别报告非重复区域的困惑度，以区分泛化改进和记忆改进，那将很有启发意义。</p>\n<p><strong>另一个关键问题是如何确保数据量充足</strong>。单个基因组可能不足以训练大型模型，尤其是当非功能区域被下采样或降低权重时。一种方法是添加同一物种的序列变异。然而，在包括人类在内的许多物种中，个体之间的变异相对较少。更常用的方法是<code>跨多个物种进行训练</code>（<strong>表1</strong>），这与蛋白质语言模型的做法类似。随着物种亲缘关系的疏远，调控逻辑的分化速度快于蛋白质。一种提出的方法是<strong>将物种标识符作为额外输入明确添加到模型中</strong>。尽管如此，一个足够大的模型，在有足够基因组上下文的情况下，仍有可能自然地对远缘基因组进行建模，类似于大型语言模型处理多语言数据集的方式。</p>\n<p>如前所述，在原核生物中，已有模型（MegaDNA和EVO）将整个基因组作为上下文。目前，这在真核生物中还不可行，因此产生了<strong>如何将基因组划分为可单独建模的上下文窗口的问题</strong>。许多相互作用局限于邻近位置（如转录因子结合位点基序），这推动了具有相对较小上下文（&lt;6 kb）的模型的开发（**表1**）。然而，也存在明显的长程相互作用，例如同一基因的外显子之间或增强子与启动子之间（可达1 Mb）。如此长的上下文长度带来了计算和统计挑战，研究人员已在努力克服这些挑战。无论选择何种上下文长度，将基因组划分为独立单元（类似于按蛋白质划分蛋白质组的方式）仍然并非易事。例如，<u>一个基因的增强子可能位于另一个基因的内含子中，且多个基因可能由同一个增强子调控。尤其是在跨物种训练时，避免因直系同源和旁系同源导致的数据泄露非常具有挑战性</u>。</p>\n<p>训练数据的选择可能会显著影响基因组语言模型的输出和学习到的表示。自然界中观察到的DNA序列是各种进化过程的结果，其中最主要的是突变和选择。对于某些应用，可能需要精心选择训练数据，以突出这些过程中的某一个。例如，为了进行适应性预测，可能需要排除&#x2F;降低高突变位点（如CpG位点）和非功能区域（如某些类型的重复元件）的权重。</p>\n<h3 id=\"3-2-模型架构\"><a href=\"#3-2-模型架构\" class=\"headerlink\" title=\"3.2 模型架构\"></a>3.2 模型架构</h3><p>在Transformer架构出现之前，<code>卷积神经网络</code>模型已被广泛用于基因组学中的有监督任务。卷积神经网络通过对输入数据应用<code>过滤器</code>，特别<u>擅长捕捉基因组序列中的局部依赖关系和基序</u>。这些模型在预测<strong>DNA-蛋白质结合位点</strong>、<strong>调控元件</strong>和<strong>转录因子结合位点</strong>方面取得了成功。前面提到的用于拟南芥全基因组变异效应预测的基因组语言模型GPN，借鉴了自然语言处理和蛋白质建模中带有改进卷积神经网络层的语言模型的成功经验，用<code>扩张卷积神经网络层</code>替换了Transformer<code>编码器中的自注意力层</code>。</p>\n<p><code>Transformer</code>模型彻底改变了各种机器学习领域，尤其是自然语言处理，并且最近被广泛应用于基因组学建模。自注意力机制允许每个标记同时关注输入序列中的所有位置，使模型能够动态关注序列的相关部分。这种能力在有监督的基因表达任务中检测调控机制方面取得了显著进展。</p>\n<p>尽管Transformer模型具有优势，但它们在基因组学建模中面临一些独特的<strong>挑战</strong>。一个重要问题是，<u>Transformer对相互作用的局部性几乎没有或没有归纳偏置，这使得它们在建模转录因子结合位点等局部基序时数据效率较低</u>。这促使人们开发<strong>卷积神经网络-Transformer混合模型</strong>，如<code>LOGO</code>，其借鉴了<code>Enformer</code>等有监督模型的思路。</p>\n<p><strong>另一个挑战是上下文长度</strong>：自注意力机制导致<strong>计算时间和内存随输入序列长度呈二次方增长</strong>，这使得将Transformer应用于极长的基因组序列变得不切实际。因此，传统基于注意力的基因组语言模型目前能够处理的最长输入长度是<code>NT-v2的12 kb</code>。为解决这一限制，一些基于Transformer的基因组语言模型采用了<code>近似注意力</code>或<code>分层注意力</code>方法，牺牲了所有标记之间的完全成对注意力。这些方法包括在<code>GENA-LM</code>中使用稀疏注意力（将上下文长度扩展到<code>36 kb</code>），以及在<code>MegaDNA</code>中采用MEGABYTE亚二次方分层自注意力（实现<code>了96 kb</code>的上下文长度）。</p>\n<p>为克服自注意力的二次方缩放问题，人们提出了各种状态空间模型（SSMs）作为Transformer的高效替代方案，用于基因组语言模型，其<strong>计算复杂度随序列长度接近线性增长</strong>。基于·层次结构的<code>HyenaDNA</code>能够支持长达<code>100万</code>个核苷酸的输入上下文。<code>EVO</code>是一种结合了Hyena和Transformer架构的混合模型，在8 kb序列上进行预训练，然后在上下文扩展阶段使用<code>131 kb</code>序列进行微调。基于Mamba的状态空间模型构建的<code>Caduceus</code>在<code>131 kb</code>序列上进行训练，同时融入了反向互补等变。</p>\n<h3 id=\"3-3-学习目标\"><a href=\"#3-3-学习目标\" class=\"headerlink\" title=\"3.3 学习目标\"></a>3.3 学习目标</h3><p>如<strong>BOX 1</strong>所述，掩码语言模型（MLM）任务（有时也称为“掩码标记预测”）要求模型根据剩余标记预测以预定概率（通常为15%）随机掩码的标记身份。这一框架已用于训练开创性的大型语言模型BERT和蛋白质语言模型<code>ESM-1b</code>，此后被广泛用于训练基因组语言模型。因果语言模型（CLM）任务（也称为“自回归语言建模”或“下一个标记预测”）要求模型根据前面的标记预测序列中的标记；该任务已用于训练GPT系列大型语言模型。在该任务中，模型以单向从左到右的顺序，根据前面的标记预测下一个标记。这两个任务的共同点是，它们都要求模型根据其他组件作为上下文来预测数据的组件。为了在这些任务上实现泛化，模型必须学习数据的低维表示。这种能力使基因组语言模型能够通过捕捉基因组内的潜在模式和依赖关系来理解和生成基因组序列。<u>在蛋白质建模中，掩码语言模型在表示学习和迁移学习能力方面通常优于因果语言模型</u>。另一方面，因果语言模型是生成任务的传统选择，但最近通过渐进式掩码，掩码语言模型在生成任务上也取得了优异结果。</p>\n<p>为减少输入序列长度并建模更长的上下文，k-mer和字节对编码（BPE）创建了比天然核苷酸词汇表（{A,C,G,T}）更大的人工定义核苷酸词汇表。另一方面，单核苷酸标记化简化了模型解释和归因，并增强了模型处理基因组变异的能力。</p>\n<p>研究人员探索了对训练目标的多种修改，以提供额外的信号并提高性能。例如，<code>GPN-MSA</code>通过脊椎动物物种的全基因组多序列比对（MSA）增强了在人类参考基因组上的掩码语言模型训练，利用相关物种间的保守性获取额外上下文。其局限性在于，全基因组多序列比对仅针对某些物种生成，要在植物中有效应用可能需要进一步开发。此外，即使顺式调控元件的活性保守，其序列也可能快速分化，这限制了通过比对提取的直系同源信息。<code>Species LM</code>通过为每个酵母物种分配一个专用标记，并在训练和推理期间将物种标记附加到输入序列，直接整合了物种信息。核苷酸序列的预训练已扩展到支持与其他模态的交互，如表观遗传学、RNA、蛋白质和自然语言。</p>\n<h3 id=\"3-4-解释\"><a href=\"#3-4-解释\" class=\"headerlink\" title=\"3.4 解释\"></a>3.4 解释</h3><p>尽管深度学习模型在各种预测任务中取得了显著性能，但它们通常缺乏可解释性，常被视为“黑箱”。然而，理解这些模型如何生成预测对于实现更广泛的应用和推进模型开发至关重要。因此，研究人员开发了一系列解释深度学习模型的方法，包括专门针对基因组学的方法。尽管基因组语言模型的解释仍是一个新兴的研究方向，但已有研究表明，一些模型已经学习到了有意义的生物模式。</p>\n<p>从语言模型中提取的序列嵌入通常被用作捕捉丰富上下文信息和序列特征的表示。<u>对基因组语言模型编码的序列嵌入进行无监督聚类，发现输入序列形成了对应于不同基因组类别（如编码序列、内含子、非翻译区等）的明显聚类</u>（<strong>图2d</strong>）。此外，<u>对<code>SpliceBERT</code>嵌入的典型剪接位点和非剪接GT&#x2F;AG位点进行无监督聚类，发现了对应于这两组位点的明显聚类</u>。这些结果表明，模型已经学会捕捉表征基因组中功能元件的关键上下文模式。</p>\n<p>Transformer模型中的注意力机制旨在捕捉输入标记之间的交互模式。因此，解释给定输入序列的注意力权重或注意力图，可以揭示模型学习到的基因组特征。<u>在SpliceBERT中，剪接供体位点和受体位点之间的注意力权重显著高于随机位点对之间的注意力权重；此外，真实供体-受体对之间的交互强度往往高于其他供体和受体位点组合</u>。这些发现表明，模型已经学会了功能交互位点之间的关系。</p>\n<p>一些基因组语言模型还采用核苷酸重建方法来发现模型学习到的序列基序。具体而言，将输入序列的各个位置逐一掩码，然后由训练好的模型根据基因组上下文预测核苷酸的概率分布。每个位点获得的分布可以揭示模型学习到的基序。GPN中采用了这种方法，在重建核苷酸的分布中发现了显著模式。特别是，<strong>模型在功能重要位点的预测通常更有信心</strong>。例如，编码序列和剪接供体&#x2F;受体位点的预测信心通常高于深层内含子位点。此外，在编码序列中，密码子的第三个核苷酸位置（对翻译的氨基酸决定作用最小）的预测信心通常低于前两个核苷酸位置。通过适配<code>TF-MoDISco</code>（一种利用模型预测识别新转录因子结合位点的专用工具），作者还发现了与转录因子结合位点数据库和相关文献中已知基序匹配的序列基序（<strong>图2a</strong>）。类似地，Species LM重建的序列基序也与训练中未见过的物种中已知的DNA和RNA结合蛋白的结合位点匹配，基序重建的准确性取决于正确反映体内结合位点的上下文和基因组区域。此外，重建基序的组成、存在和位置表现出物种特异性模式，这表明<u>基因组语言模型可能成为研究序列基序和调控密码进化的强大工具</u>。</p>\n<p>最近，研究人员通过在某个位置引入点突变并量化其他位置核苷酸概率的变化，研究了基因组语言模型学习到的基因组位置之间的依赖关系。核苷酸依赖分析揭示了模型学习到的功能元件（如转录因子结合位点、剪接位点和RNA）内部和之间的相互作用，包括已知的二级和三级结构接触。值得注意的是，与之前基于预测边际概率分布的方法相比，核苷酸依赖分析能够更稳健地检测结合的转录因子结合位点。</p>\n<h3 id=\"3-5-评估\"><a href=\"#3-5-评估\" class=\"headerlink\" title=\"3.5 评估\"></a>3.5 评估</h3><p>在本节中，我们将讨论如何针对前面描述的三个应用领域对模型性能进行基准测试：预测等位基因的功能约束、生成新的可行序列以及迁移学习。</p>\n<p>有多种类型的数据可以反映等位基因的功能约束，可用于基准测试变异效应预测器。<strong>一类</strong>数据来自将<code>遗传变异的功能差异与读数</code>(readouts)（如报告基因的表达或细胞生长）相关联的实验。这些读数可用于对变异的功能性进行排序，由于影响功能的变异通常也受到选择，因此我们期望这些排序与模型预测的排序相关。这类数据的一个来源是<code>ProteinGym</code>，这是一个广泛使用的实验数据集集合，可用于基准测试错义变异效应预测器。<strong>另一类</strong>数据是<code>临床标记</code>，指示变异是否有致病证据（即是否会增加疾病风险）。致病性变异可能影响生育能力，因此可能具有有害性。因此，我们可以通过评估变异效应预测器作为致病性分类器的性能来对其进行基准测试。在人类遗传学中，变异临床标记的主要来源包括<code>ClinVar</code>、<code>HGMD</code>和<code>OMIM</code>数据库。<strong>第三类</strong>数据是<code>变异频率</code>。由于常见变异不太可能具有高度有害性，它们的预测约束水平应相对高于罕见变异。因此，我们可以根据预测器识别常见变异的能力对其进行基准测试。人类不同祖先群体中等位基因频率数据的主要来源是<code>gnomAD</code>数据库。总之，这些数据可以作为模型泛化性能的独立证据。</p>\n<p>变异效应预测器评估的一个问题是，验证数据与功能约束之间的关系可能不明确。因此，模型可能通过利用数据未能捕捉功能约束的方面在基准测试中表现出色。例如，使用临床标记的一个关键问题是，变异的分类基于是否有充分证据证明它们是良性的或致病性的。由于预测器也可能利用这些证据，它们在标记变异上的基准测试性能可能无法反映其在未标记变异上的真实性能（有关泛化性能的简要讨论，请参见<strong>BOX 3</strong>）。使用等位基因频率数据也存在关键问题：例如，除自然选择的直接作用外，等位基因频率还受突变率、遗传漂变、背景选择和遗传搭车等因素影响。因此，预测器可能通过预测这些过程的影响而非功能约束在基准测试中表现良好。这些问题凸显了需要仔细解释预测器性能原因的重要性，并促使人们呼吁提高预测器训练所使用的数据和方法的透明度。</p>\n<p>生成式序列模型的评估面临一系列独特挑战。评估语言模型生成能力的一种基本方法是比较它们在有效序列集上的困惑度。然而，要评估模型设计新序列的能力，需要衡量它们是否能够识别既可行又新颖的序列。因此，模型在测试集上的困惑度可能无法可靠地表明其在设计任务中的实用性。相反，可能需要采用全面的方法，检查生成序列的广泛特性。例如，最近用于调控序列设计的基准测试工具<code>Polygraph</code>提出了一系列分析方法，用于研究序列组成、基序模式和预测的功能活性。对于全基因组或染色体设计任务，可能还需要评估必需基因和功能性调控元件的存在和位置，以及它们之间的相互作用。最终，设计的序列需要通过实验评估，以确定它们是否能实现预期功能。</p>\n<p>最后，评估基因组语言模型在迁移学习中的性能面临一个独特挑战：任何基准测试集（可能需要结合多个基准测试集）都必须能够可靠地表明模型在相关任务上的性能。功能基因组学数据（如来自ENCODE或Roadmap表观基因组学项目的数据）可用于注释基因组区域和变异，这类数据可构建一系列任务，广泛反映模型适应基因组解释的能力。我们期望，模型在适应后从基因组序列预测这些注释的性能，能够表明其识别功能相似基因组元件的能力。为便于模型之间的比较，这些注释已被整合到各种标准化的训练和测试数据集集合中。</p>\n<p>由于迁移学习基准测试有助于凸显当前模型的局限性，并为发表建立标准，因此它们可能成为基因组语言模型开发者和用户的重要资产。然而，尽管当前基准测试在任务选择和方法上存在差异，但它们对基因组语言模型能力的见解似乎存在冗余。未来，计算基因组学界需要开发广泛认可的标准化且可扩展的基准测试。</p>\n<p><font size=2 color='grey'> <strong>BOX 3</strong>：评估泛化性能<br>评估预测模型的目的是建立对其泛化能力的信任，即对未标记数据做出令人满意的预测。估计模型泛化性能的一种直接且标准的方法是在代表目标未标记数据的标记“测试集”上评估其准确性。这种方法是大多数机器学习基准测试的基础。</p>\n<p>重要的是，为使这种评估成为泛化性能的可靠指标，不得向模型提供任何可用于区分测试集数据和最终部署数据的信息。否则，模型可能会以牺牲泛化性能为代价降低测试集误差。因此，通常会组织向参与者隐瞒测试数据的机器学习竞赛。<br></font></p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Table01.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Table01.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"表1：现有基因组语言模型总结\"></p>\n<p><font size=2 color='grey'>提供了各种基因组语言模型的概述，重点介绍了它们的预训练数据集、任务、架构、标记化方法和独特特征。模型按公开发布日期排序。缩写包括：SSM（状态空间模型）、CNN（卷积神经网络）、BPE（字节对编码）、CLM（因果语言建模）、MLM（掩码语言建模）。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig03.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig03.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3：开发流程\"></p>\n<p><font size=2 color='grey'>该图展示了本综述中描述的基因组语言模型通用开发流程，从模型构思到部署。我们首先选择和准备训练数据集，强调数据质量和数量的重要性（训练数据）。随后，在模型架构和学习目标部分，我们探讨了设计和训练基因组语言模型的各种选择，讨论了不同方法的优缺点。我们还研究了混合模型如何结合多种架构的元素以缓解特定局限性。在解释部分，我们讨论了分析和解释基因组语言模型输出的方法。最后，在评估部分，我们通过当前基准测试介绍了评估方法，强调了使模型性能与实际生物功能保持一致的复杂性。</font></p>\n<h2 id=\"4-结论与未来展望\"><a href=\"#4-结论与未来展望\" class=\"headerlink\" title=\"4 结论与未来展望\"></a>4 结论与未来展望</h2><p>在基因组序列数量庞大且不断增长的时代，基因组语言模型正成为提取复杂模式的强大工具，可应用于功能约束估计、序列设计和迁移学习等多个领域。然而，正如“人工智能”一词可能暗示的那样，它们尚未实现神奇的突然突破。相反，我们将其视为另一种有用的建模工具，类似于隐马尔可夫模型刚出现时的情况。基因组语言模型通常被称为“基础模型”，这一术语最近被创造出来，指在广泛数据上训练、可适应各种下游任务的模型。这一新术语的引入受到了批评，因为“基础”一词意味着在下游任务性能上有显著改进，而这是一个实证问题，而非预训练模型的固有属性。在基因组学等新领域，这种批评更为强烈，因为建立足够的基准测试可能需要一些时间。</p>\n<p>早期的基因组语言模型或多或少是自然语言处理模型的直接改编，我们期望通过深入结合基因组学专业知识，能获得最大的收益。我们注意到，评估基因组语言模型的能力具有挑战性，因为指标可能具有误导性，尤其是在过度优化的情况下。自然语言处理的一个优势是人类是自然语言的专家，因此可以根据自身专业知识校准基准测试。然而，在基因组学中，我们必须依靠数据和专家知识来验证模型。问题的这一方面使其特别具有挑战性，并可能意味着需要与领域专家合作，并有意识地进行实验以开发基准测试。在本综述的最后，我们提出了一些我们认为值得进一步研究的方向（列于未解决的问题中）。</p>\n<h3 id=\"未解决的问题\"><a href=\"#未解决的问题\" class=\"headerlink\" title=\"未解决的问题\"></a>未解决的问题</h3><ol>\n<li>如何最好地对从基序到基因再到全基因组的各种尺度模式进行建模？</li>\n<li>哪些应用需要对长程相互作用进行建模？如何确定合适的感受野大小？</li>\n<li>如何将结构变异纳入基因组语言模型？</li>\n<li>训练基因组语言模型时，利用群体遗传数据的最佳方式是什么？</li>\n<li>如何最好地将基因组语言模型与其他复杂模态（如转录组学和表观遗传学数据）整合？</li>\n<li>在开发基因组语言模型时，如何更好地理解为什么某些基因组比其他基因组更难建模？</li>\n<li>缩放假设对基因组语言模型是否成立？能成立多久？考虑到大多数数据可能是非功能性的，是否真的有足够的数据可用？</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li>Gonzalo Benegas, Chengzhong Ye, Carlos Albors, Jianan Canal Li, Yun S. Song. arXiv:2407.11435v2. doi: <a href=\"https://doi.org/10.48550/arXiv.2407.11435\">https://doi.org/10.48550/arXiv.2407.11435</a></li>\n</ul>\n<h2 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h2><p>关注公众号“生信之巅”，聊天窗口回复“85d7”获取下载链接。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"AI 在生物信息学的方法革新与应用全景","slug":"AI 在生物信息学的方法革新与应用全景","date":"2025-11-11T11:33:35.000Z","updated":"2025-11-11T11:56:38.573Z","comments":true,"path":"api/articles/AI 在生物信息学的方法革新与应用全景.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig00.png","content":"<p><strong>摘要</strong>：随着人工智能（AI）技术的快速迭代，从传统深度学习到预训练模型、大型语言模型（LLMs）的演进，生物信息学领域正经历从“数据驱动”到“知识赋能”的范式转变。本文整合2024-2025年最新综述成果，系统梳理AI在生物信息学中的核心方法体系（语言模型、图模型、多模态模型）、技术演进脉络（从单一任务模型到基础模型）、典型应用领域（基因组分析、蛋白质研究、微生物组挖掘等），并总结当前面临的数据质量、可解释性、计算成本等挑战，展望多模态融合、小样本学习、临床转化等未来方向。本文旨在为读者建立AI赋能生物信息学的全局认知框架，为后续细分模型与场景篇章奠定基础。</p>\n<p><strong>关键词</strong>：人工智能；生物信息学；大型语言模型；基础模型；预训练模型</p>\n<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h2><p>生物信息学的核心目标是解析生物分子序列（DNA、RNA、蛋白质）中的信息编码规律，揭示基因表达、蛋白质功能、细胞代谢等生命过程的分子机制。传统研究依赖实验测序与手工分析，难以应对高通量测序技术带来的“数据爆炸”——截至2025年，全球基因组数据库已积累超过100万个人类基因组序列、10亿条蛋白质序列<sup>[1]</sup>。AI技术的兴起为这一困境提供了破局方案：从2015年卷积神经网络（CNN）用于DNA motif预测，到2021年首个DNA预训练模型<code>DNABERT</code>问世，再到2024-2025年基因组语言模型（gLMs）、蛋白质语言模型（PLMs）实现跨模态功能预测，AI已成为生物信息学从<strong>描述性研究</strong>向<strong>预测性研究</strong>跨越的核心工具<sup>[2]</sup>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig00.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig00.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图0 可视化大模型工具，专为提升生物信息学各应用领域的研究效能而开发&lt;sup&gt;[2]&lt;/sup&gt;。\"></p>\n<p>本文通过整合多篇权威综述，从<strong>技术演进-方法体系-应用领域-挑战展望</strong>四个维度，构建AI在生物信息学的全景图谱，为后续章节深入探讨细分模型（DNA模型、蛋白质模型等）提供理论与方法基础。</p>\n<h2 id=\"2-AI赋能生物信息学的技术演进\"><a href=\"#2-AI赋能生物信息学的技术演进\" class=\"headerlink\" title=\"2 AI赋能生物信息学的技术演进\"></a>2 AI赋能生物信息学的技术演进</h2><p>AI在生物信息学的应用可分为三个阶段，各阶段的技术特征、代表模型与核心突破存在显著差异，其演进逻辑与生物数据复杂度、计算能力提升高度契合<sup>[3]</sup>。</p>\n<h3 id=\"2-1-阶段1：传统深度学习（2015-2020）——任务特异性建模\"><a href=\"#2-1-阶段1：传统深度学习（2015-2020）——任务特异性建模\" class=\"headerlink\" title=\"2.1 阶段1：传统深度学习（2015-2020）——任务特异性建模\"></a>2.1 阶段1：传统深度学习（2015-2020）——任务特异性建模</h3><p>此阶段以“<strong>单一任务、手工特征</strong>”为核心，模型设计针对具体生物问题（如DNA结合位点预测、蛋白质二级结构预测），依赖领域专家提取特征（如k-mer频率、序列保守性）。</p>\n<ul>\n<li><p><strong>代表技术</strong>：CNN（捕捉局部序列 motif）、循环神经网络（LSTM&#x2F;GRU，捕捉序列长程依赖）、图神经网络（GNN，处理蛋白质相互作用网络）；</p>\n</li>\n<li><p><strong>典型应用</strong>：</p>\n<ul>\n<li>CNN用于转录因子结合位点（TFBS）预测（如Basset模型，2016）；</li>\n<li>LSTM用于RNA剪接位点识别（如SpliceAI，2019）；</li>\n</ul>\n</li>\n<li><p><strong>局限</strong>：泛化能力弱（换用数据集需重新训练）、依赖手工特征、难以处理多模态生物数据（如DNA+表观遗传数据）。</p>\n</li>\n</ul>\n<h3 id=\"2-2-阶段2：预训练模型（2021-2023）——跨任务知识迁移\"><a href=\"#2-2-阶段2：预训练模型（2021-2023）——跨任务知识迁移\" class=\"headerlink\" title=\"2.2 阶段2：预训练模型（2021-2023）——跨任务知识迁移\"></a>2.2 阶段2：预训练模型（2021-2023）——跨任务知识迁移</h3><p>受自然语言处理（NLP）中BERT模型启发，生物信息学领域开始构建“<strong>预训练-微调</strong>”范式：先在大规模无标注生物序列（如人类基因组、UniProt蛋白质库）上预训练，再针对下游任务（如变异效应预测）微调，实现知识跨任务迁移。</p>\n<ul>\n<li><p><strong>代表模型</strong>：</p>\n<ul>\n<li><code>DNA领域</code>：DNABERT（2021，首个DNA-BERT模型，基于k-mer tokenization）、Nucleotide Transformer（2023，多物种基因组预训练）；</li>\n<li><code>蛋白质领域</code>：ProteinBERT（2022，统一蛋白质序列与功能建模）、ESM系列（2021-2023，蛋白质结构预测）；</li>\n</ul>\n</li>\n<li><p><strong>核心突破</strong>：摆脱手工特征依赖，模型可自动学习生物序列的“<strong>语义信息</strong>”（如DNA的调控语法、蛋白质的结构-功能关联），泛化能力显著提升（2021-DNABERT）。</p>\n</li>\n</ul>\n<h3 id=\"2-3-阶段3：基础模型-大模型（2024-2025）——跨模态与通用智能\"><a href=\"#2-3-阶段3：基础模型-大模型（2024-2025）——跨模态与通用智能\" class=\"headerlink\" title=\"2.3 阶段3：基础模型&#x2F;大模型（2024-2025）——跨模态与通用智能\"></a>2.3 阶段3：基础模型&#x2F;大模型（2024-2025）——跨模态与通用智能</h3><p>此阶段模型具备“<strong>大规模数据输入、跨模态融合、多任务适配</strong>”特征，被称为“生物信息学基础模型（Foundation Models）”，可同时处理DNA、RNA、蛋白质、表观遗传等多类型数据，适配从序列分析到功能设计的全链条任务。</p>\n<ul>\n<li><p><strong>代表模型</strong>：</p>\n<ul>\n<li><code>基因组领域</code>：Genomic Touchstone（2025，gLMs基准测试框架，跨DNA&#x2F;RNA&#x2F;蛋白质功能预测）、Generator（2025，长序列基因组生成模型）；</li>\n<li><code>多模态领域</code>：LucaOne（2025，统一核酸与蛋白质语言的基础模型）、CD-GPT（2024，连接中心法则的跨分子模型）；</li>\n</ul>\n</li>\n<li><p><strong>核心突破</strong>：实现“<strong>从数据到知识</strong>”的跨越，可解释性与实用性同步提升（如gLMs可解析基因组功能元件的进化规律，2025-Genomic Touchstone）。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig01.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig01.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1 生物信息学领域大型语言模型（LLMs）整合的里程碑：在DNA、RNA、蛋白质及单细胞RNA（scRNA）应用方面取得的突破&lt;sup&gt;[3]&lt;/sup&gt;。\"></p>\n<h2 id=\"3-AI-在生物信息学的核心方法体系\"><a href=\"#3-AI-在生物信息学的核心方法体系\" class=\"headerlink\" title=\"3 AI 在生物信息学的核心方法体系\"></a>3 AI 在生物信息学的核心方法体系</h2><p>AI赋能生物信息学的方法可分为三大类：<strong>语言模型（主导序列建模）、图模型（主导网络建模）、多模态模型（主导跨类型数据融合）</strong>，各类方法的核心原理、适用场景与代表技术存在显著差异。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig02.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig02.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2 生物信息学领域大型语言模型（LLMs）整合的里程碑：在DNA、RNA、蛋白质及单细胞RNA（scRNA）应用方面取得的突破&lt;sup&gt;[6]&lt;/sup&gt;。\"></p>\n<h3 id=\"3-1-语言模型：生物序列的“语义解析”工具\"><a href=\"#3-1-语言模型：生物序列的“语义解析”工具\" class=\"headerlink\" title=\"3.1 语言模型：生物序列的“语义解析”工具\"></a>3.1 语言模型：生物序列的“语义解析”工具</h3><p>语言模型是当前生物信息学最主流的AI方法，核心思想是将生物序列（如DNA、蛋白质）视为“生物语言”，通过预训练学习序列的上下文依赖关系，适配序列分类、预测、生成等任务。  </p>\n<h4 id=\"3-1-1-核心训练目标\"><a href=\"#3-1-1-核心训练目标\" class=\"headerlink\" title=\"3.1.1 核心训练目标\"></a>3.1.1 核心训练目标</h4><p>语言模型的训练目标决定其对序列信息的捕捉能力，主流目标包括：</p>\n<ol>\n<li><p><strong>掩码语言模型（Masked Language Modeling, MLM）</strong></p>\n<p>随机掩码序列中的部分“token”（如DNA中的k-mer、蛋白质中的氨基酸），模型预测掩码位置的真实token，适用于序列理解任务（如变异效应预测）。</p>\n<p>数学表达：给定序列 $( X &#x3D; (X_1, X_2, …, X_n) )$，随机选择掩码集合 {Masked}，模型学习条件概率分布：</p>\n<p>$\\mathbb{P}[X_i | X_{-i}] \\quad (i \\in \\text{Masked})$</p>\n</li>\n<li><p><strong>因果语言模型（Causal Language Modeling, CLM）</strong></p>\n<p>模型按“从左到右”顺序预测下一个token，适用于序列生成任务（如DNA调控序列设计）。</p>\n<p>数学表达：模型学习条件概率分布：</p>\n<p>$\\mathbb{P}[X_k | X_{1:k-1}] \\quad (k &#x3D; 1, 2, …, n)$</p>\n</li>\n</ol>\n<h4 id=\"3-1-2-关键技术：Tokenization\"><a href=\"#3-1-2-关键技术：Tokenization\" class=\"headerlink\" title=\"3.1.2 关键技术：Tokenization\"></a>3.1.2 关键技术：Tokenization</h4><p>Tokenization是将生物序列转化为模型可处理<code>词汇</code>的过程，直接影响模型对序列特征的捕捉能力，主流方法对比见表1：  </p>\n<p><strong>表1 DNA序列分析的Tokenization方法对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>Tokenization方法</th>\n<th>原理</th>\n<th>优势</th>\n<th>劣势</th>\n<th>代表模型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单核苷酸（Nucleotide-level）</td>\n<td>每个碱基（A&#x2F;C&#x2F;G&#x2F;T）作为1个token</td>\n<td>可解释性强，适配变异分析</td>\n<td>上下文信息少，计算成本高</td>\n<td>GPN（2023）、HyenaDNA（2023）</td>\n</tr>\n<tr>\n<td>重叠k-mer</td>\n<td>滑动窗口截取k个连续碱基作为1个token（如6-mer）</td>\n<td>捕捉局部 motif 信息</td>\n<td>存在序列冗余，词汇表大</td>\n<td>DNABERT（2021）、SpliceBERT（2024）</td>\n</tr>\n<tr>\n<td>非重叠k-mer</td>\n<td>固定窗口截取k个连续碱基作为1个token</td>\n<td>无冗余，计算效率高</td>\n<td>可能割裂长程依赖</td>\n<td>Nucleotide Transformer（2023）</td>\n</tr>\n<tr>\n<td>字节对编码（BPE）</td>\n<td>基于序列频率合并高频子序列</td>\n<td>适配长序列，词汇表小</td>\n<td>可解释性弱</td>\n<td>DNABERT-2（2023）、GENA-LM（2023）</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-2-图模型：生物网络的“关系挖掘”工具\"><a href=\"#3-2-图模型：生物网络的“关系挖掘”工具\" class=\"headerlink\" title=\"3.2 图模型：生物网络的“关系挖掘”工具\"></a>3.2 图模型：生物网络的“关系挖掘”工具</h3><p>生物系统中大量存在网络结构（如蛋白质-蛋白质互作网络、微生物共丰度网络），图模型通过将节点（如蛋白质、微生物）与边（如互作关系、共丰度）建模，挖掘网络中的隐藏关联。  </p>\n<h4 id=\"3-2-1-核心模型类型\"><a href=\"#3-2-1-核心模型类型\" class=\"headerlink\" title=\"3.2.1 核心模型类型\"></a>3.2.1 核心模型类型</h4><ol>\n<li><p><strong>图注意力网络（GAT）</strong>：通过注意力机制分配节点权重，突出关键节点对（如核心蛋白质），适用于蛋白质互作预测（如PGAT-ABPp，2024）；</p>\n</li>\n<li><p><strong>图卷积网络（GCN）</strong>：通过邻接矩阵聚合节点特征，适用于微生物组-疾病关联分析（如2023-Leveraging pre-trained language models）；</p>\n</li>\n</ol>\n<h4 id=\"3-2-2-典型应用\"><a href=\"#3-2-2-典型应用\" class=\"headerlink\" title=\"3.2.2 典型应用\"></a>3.2.2 典型应用</h4><ul>\n<li><strong>蛋白质互作预测</strong>：输入蛋白质序列特征与已知互作网络，GAT模型预测未发现的互作关系（2025-PLM-interact）；  </li>\n<li><strong>微生物组分层</strong>：GCN模型基于微生物共丰度网络，识别疾病相关的微生物集群（2025-AI-empowered human microbiome research）。</li>\n</ul>\n<h3 id=\"3-3-多模态模型：跨类型数据的“融合建模”工具\"><a href=\"#3-3-多模态模型：跨类型数据的“融合建模”工具\" class=\"headerlink\" title=\"3.3 多模态模型：跨类型数据的“融合建模”工具\"></a>3.3 多模态模型：跨类型数据的“融合建模”工具</h3><p>生物数据具有多模态特征（如DNA序列+表观遗传标记+蛋白质结构），多模态模型通过统一表示空间融合不同类型数据，解决“单一数据信息有限”的问题。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig03.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig03.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3 多模态基础模型的计算组件。a、多模态基础模型的预期组件。该模型由多模态输入数据构成，通过混合统一标记和多级注意力操作进行处理。可采用多种自监督和监督学习目标进行预训练和迁移学习。b、多模态内/跨模态注意力机制的放大模型，展示模型中使用的多头注意力变体。放大面板直观呈现单个注意力头的跨模态与模态内操作，密集方块表示对应查询(Q)与键(K)对之间的注意力计算，虚线方块则表示未进行注意力计算。查询、键和值(V)均为Transformer模型计算的实数向量。Nx表示连续堆叠的注意力块数量&lt;sup&gt;[4]&lt;/sup&gt;。\"></p>\n<h4 id=\"3-3-1-核心融合策略\"><a href=\"#3-3-1-核心融合策略\" class=\"headerlink\" title=\"3.3.1 核心融合策略\"></a>3.3.1 核心融合策略</h4><ol>\n<li><p><strong>早期融合</strong>：将多模态数据（如DNA序列嵌入+ histone修饰信号）在输入层拼接，共同输入模型（如Enformer，2021，用于基因表达预测）；</p>\n</li>\n<li><p><strong>晚期融合</strong>：各模态数据单独建模，在输出层融合预测结果（如LucaOne，2025，融合核酸与蛋白质特征）；</p>\n</li>\n</ol>\n<h4 id=\"3-3-2-代表应用\"><a href=\"#3-3-2-代表应用\" class=\"headerlink\" title=\"3.3.2 代表应用\"></a>3.3.2 代表应用</h4><ul>\n<li><strong>跨模态功能预测</strong>：Genomic Touchstone（2025）通过多模态模型，从DNA序列预测RNA稳定性与蛋白质结构，准确率超单一模态模型15%-20%；  </li>\n<li><strong>细胞分子建模</strong>：整合DNA、RNA、蛋白质与细胞影像数据，解析细胞功能调控网络<sup>[4]</sup>。</li>\n</ul>\n<h2 id=\"4-AI-在生物信息学的典型应用领域\"><a href=\"#4-AI-在生物信息学的典型应用领域\" class=\"headerlink\" title=\"4 AI 在生物信息学的典型应用领域\"></a>4 AI 在生物信息学的典型应用领域</h2><p>AI技术已渗透生物信息学的全链条研究，从基础分子序列分析到临床应用，形成多维度应用体系。以下按“基因组→蛋白质组→微生物组→单细胞组学”分类，结合2024-2025年综述成果<sup>[5,6]</sup>，总结各领域的核心应用、代表模型与数据来源。  </p>\n<h3 id=\"4-1-基因组领域：从序列解读到功能设计\"><a href=\"#4-1-基因组领域：从序列解读到功能设计\" class=\"headerlink\" title=\"4.1 基因组领域：从序列解读到功能设计\"></a>4.1 基因组领域：从序列解读到功能设计</h3><p>基因组是生物信息学的基础，AI的核心作用是“<strong>解析DNA序列中的功能编码</strong>”，应用场景涵盖基因注释、变异分析、序列设计等。  </p>\n<h4 id=\"4-1-1-核心应用场景\"><a href=\"#4-1-1-核心应用场景\" class=\"headerlink\" title=\"4.1.1 核心应用场景\"></a>4.1.1 核心应用场景</h4><ol>\n<li><strong>基因组功能注释</strong>：预测DNA中的功能元件（如启动子、增强子、CTCF结合位点），代表模型包括：  <ul>\n<li>gLMs（如GPN，2023）：通过MLM预训练，识别拟南芥基因组中的转录因子结合位点（TFBS），准确率达0.86（F1 score）；  </li>\n<li>基准框架（如Genomic Touchstone，2025）：评估gLMs在人类基因组注释的性能，Top模型（如NTv2-500m-Multi）的增强子预测F1 score达0.55；</li>\n</ul>\n</li>\n<li><strong>遗传变异效应预测</strong>：判断变异（如SNP、Indel）是否影响基因功能，代表模型包括：  <ul>\n<li>Nucleotide Transformer（2023）：预测人类基因组中SNP的致病性，AUC达0.89；  </li>\n<li>GPN-MSA（2023）：结合多物种序列比对（MSA），提升罕见变异效应预测准确率；</li>\n</ul>\n</li>\n<li><strong>DNA序列设计</strong>：生成具有特定功能的DNA序列（如启动子、CRISPR向导RNA），代表模型包括：  <ul>\n<li>regLM（2024）：基于HyenaDNA，生成酵母与人类细胞的启动子序列，功能验证成功率达78%；  </li>\n<li>EVO（2024）：设计新型CRISPR-Cas系统，预测结构与天然系统相似度达0.92。</li>\n</ul>\n</li>\n</ol>\n<p><strong>表2 基因组领域AI应用总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>应用场景</th>\n<th>代表模型</th>\n<th>数据来源</th>\n<th>核心指标（准确率&#x2F;F1 score）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>启动子注释</td>\n<td>NTv2-500m-Multi</td>\n<td>人类基因组（hg38）</td>\n<td>0.86</td>\n</tr>\n<tr>\n<td>增强子分类</td>\n<td>DNABERT2</td>\n<td>ENCODE SCREEN数据库</td>\n<td>0.55</td>\n</tr>\n<tr>\n<td>SNP致病性预测</td>\n<td>Nucleotide Transformer</td>\n<td>ClinVar数据库</td>\n<td>0.89（AUC）</td>\n</tr>\n<tr>\n<td>启动子生成</td>\n<td>regLM</td>\n<td>酵母&#x2F;人类调控序列</td>\n<td>0.78（功能成功率）</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-2-蛋白质领域：从结构预测到功能优化\"><a href=\"#4-2-蛋白质领域：从结构预测到功能优化\" class=\"headerlink\" title=\"4.2 蛋白质领域：从结构预测到功能优化\"></a>4.2 蛋白质领域：从结构预测到功能优化</h3><p>蛋白质是生命活动的执行者，AI的核心作用是“破解蛋白质序列-结构-功能的关联”，应用场景涵盖结构预测、功能注释、酶工程等。  </p>\n<h4 id=\"4-2-1-核心应用场景\"><a href=\"#4-2-1-核心应用场景\" class=\"headerlink\" title=\"4.2.1 核心应用场景\"></a>4.2.1 核心应用场景</h4><ol>\n<li><strong>蛋白质结构预测</strong>：预测二级（α-螺旋&#x2F;β-折叠）与三级结构，代表模型包括：  <ul>\n<li>ESM-2（2023）：基于650M参数PLM，二级结构预测Q3 score达0.86；  </li>\n<li>AlphaFold3（2024）：多模态模型，整合序列与结构数据，三级结构预测TM-score达0.92；</li>\n</ul>\n</li>\n<li><strong>蛋白质功能注释</strong>：预测蛋白质的酶分类、翻译后修饰（PTM）位点，代表模型包括：  <ul>\n<li>ProteinBERT（2022）：酶分类准确率达0.74，PTM位点预测F1 score达0.72；  </li>\n<li>DPFunc（2025）：结合结构域信息，蛋白质功能预测准确率超传统模型12%；</li>\n</ul>\n</li>\n<li><strong>酶工程优化</strong>：改造酶的动力学参数（如催化效率、稳定性），代表模型包括：  <ul>\n<li>UniKP（2023）：统一框架预测酶的Km&#x2F;Kcat值，预测误差比传统方法降低30%；  </li>\n<li>强化学习模型（2025）：优化脂肪酶的温度稳定性，Tm值提升15℃。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-3-微生物组领域：从群落解析到疾病关联\"><a href=\"#4-3-微生物组领域：从群落解析到疾病关联\" class=\"headerlink\" title=\"4.3 微生物组领域：从群落解析到疾病关联\"></a>4.3 微生物组领域：从群落解析到疾病关联</h3><p>微生物组与人类健康密切相关（如肠道微生物影响代谢疾病），AI的核心作用是“挖掘微生物群落的组成规律与功能关联”，应用场景涵盖群落分类、疾病关联、功能预测等。  </p>\n<h4 id=\"4-3-1-核心应用场景\"><a href=\"#4-3-1-核心应用场景\" class=\"headerlink\" title=\"4.3.1 核心应用场景\"></a>4.3.1 核心应用场景</h4><ol>\n<li><strong>微生物群落分类</strong>：识别样本中的微生物种类与丰度，代表模型包括：  <ul>\n<li>ViBE（2022）：基于Transformer，病毒序列分类准确率达0.91；  </li>\n<li>预训练模型（2023）：基于16S rRNA序列，微生物物种分类F1 score达0.88；</li>\n</ul>\n</li>\n<li><strong>微生物组-疾病关联</strong>：挖掘影响疾病的关键微生物，代表模型包括：  <ul>\n<li>预训练语言模型（2023）：分析肠道微生物与糖尿病的关联，AUC达0.83；  </li>\n<li>图模型（2025）：基于微生物共丰度网络，识别肥胖相关微生物集群，准确率达0.79；</li>\n</ul>\n</li>\n<li><strong>微生物功能预测</strong>：预测微生物的代谢通路与酶功能，代表模型包括：  <ul>\n<li>MetaBERT（2024）：基于宏基因组序列，代谢通路预测准确率达0.81；  </li>\n<li>多模态模型（2025）：整合微生物序列与代谢组数据，酶功能预测F1 score达0.76。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-4-单细胞组学领域：从细胞分型到调控解析\"><a href=\"#4-4-单细胞组学领域：从细胞分型到调控解析\" class=\"headerlink\" title=\"4.4 单细胞组学领域：从细胞分型到调控解析\"></a>4.4 单细胞组学领域：从细胞分型到调控解析</h3><p>单细胞组学（如单细胞RNA-seq）可解析细胞异质性，AI的核心作用是“从高维单细胞数据中提取生物学信息”，应用场景涵盖细胞分型、轨迹推断、调控网络构建等。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig04.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig04.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图4 单细胞组学的Transformer模型。该模型的输入可为单细胞组学的单一或多种检测模式，其核心架构由M层Transformer构成，通过多层结构对输入数据进行特征转换。这类单细胞Transformer通常通过自监督学习任务（如预测细胞内特定基因的表达模式）进行预训练，可广泛应用于下游任务，既可用于细胞层面的注释分析，也可用于基因层面的功能预测&lt;sup&gt;[7]&lt;/sup&gt;。\"></p>\n<h4 id=\"4-4-1-核心应用场景\"><a href=\"#4-4-1-核心应用场景\" class=\"headerlink\" title=\"4.4.1 核心应用场景\"></a>4.4.1 核心应用场景</h4><ol>\n<li><strong>细胞分型</strong>：识别单细胞数据中的细胞类型，代表模型包括：  <ul>\n<li>Transformer-based模型（2024）：处理人类PBMC单细胞数据，细胞分型准确率达0.94；  </li>\n<li>基础模型（2024）：Large-scale foundation model，跨数据集细胞分型泛化率达0.89；</li>\n</ul>\n</li>\n<li><strong>细胞轨迹推断</strong>：预测细胞分化&#x2F;发育路径，代表模型包括：  <ul>\n<li>图神经网络（2024）：分析胚胎干细胞分化轨迹，与实验结果一致性达0.91；  </li>\n<li>多模态模型（2025）：整合单细胞RNA-seq与ATAC-seq数据，轨迹推断准确率提升15%；</li>\n</ul>\n</li>\n<li><strong>单细胞调控网络</strong>：构建细胞内基因调控关系，代表模型包括：  <ul>\n<li>注意力模型（2024）：预测TF-gene调控对，AUC达0.87；  </li>\n<li>因果推断模型（2025）：解析单细胞中的基因因果关系，假阳性率降低20%。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-AI-在生物信息学面临的挑战\"><a href=\"#5-AI-在生物信息学面临的挑战\" class=\"headerlink\" title=\"5 AI 在生物信息学面临的挑战\"></a>5 AI 在生物信息学面临的挑战</h2><p>尽管AI在生物信息学取得显著进展，但2024-2025年综述普遍指出，当前技术仍面临<strong>数据质量、可解释性、计算成本、临床转化</strong>四大核心挑战。  </p>\n<h3 id=\"5-1-数据质量：生物数据的“先天缺陷”\"><a href=\"#5-1-数据质量：生物数据的“先天缺陷”\" class=\"headerlink\" title=\"5.1 数据质量：生物数据的“先天缺陷”\"></a>5.1 数据质量：生物数据的“先天缺陷”</h3><ol>\n<li><strong>标注稀缺与偏差</strong>：  <ul>\n<li>功能标注数据不足（如人类基因组中仅3.3%碱基有明确功能标注）；  </li>\n<li>临床数据偏差（如ClinVar数据库中欧洲人群变异占比超80%，导致模型对其他人群的预测准确率下降15%-20%）；</li>\n</ul>\n</li>\n<li><strong>序列重复与冗余</strong>：  <ul>\n<li>基因组中50%以上为重复序列（如人类基因组），导致模型过度拟合重复区域，对功能区域预测精度下降；  </li>\n<li>蛋白质数据库中同源序列占比超40%，影响模型泛化能力；</li>\n</ul>\n</li>\n<li><strong>多模态数据异构</strong>：  <ul>\n<li>不同类型生物数据（如DNA序列、蛋白质结构、表观数据）的格式与尺度差异大，融合难度高，易导致模型“偏倚”（如过度依赖序列数据，忽视表观信息）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>表3 AI 在生物信息学的主要挑战分类</strong></p>\n<table>\n<thead>\n<tr>\n<th>挑战类型</th>\n<th>具体表现</th>\n<th>对模型的影响</th>\n<th>潜在解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据质量</td>\n<td>标注稀缺、重复序列多、多模态异构</td>\n<td>泛化能力弱、预测偏差大</td>\n<td>半监督学习、重复序列降权、统一模态表示</td>\n</tr>\n<tr>\n<td>可解释性</td>\n<td>模型“黑箱”，难以解析预测逻辑</td>\n<td>临床应用信任度低、难以指导实验设计</td>\n<td>注意力可视化、 motif 解析、因果推断</td>\n</tr>\n<tr>\n<td>计算成本</td>\n<td>大模型训练需千卡GPU时，推理速度慢</td>\n<td>小实验室难以使用、实时分析困难</td>\n<td>模型压缩、高效架构（如Mamba）、蒸馏</td>\n</tr>\n<tr>\n<td>临床转化</td>\n<td>模型性能与临床需求脱节（如假阳性率高）</td>\n<td>难以落地疾病诊断、药物研发</td>\n<td>临床数据微调、多中心验证</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-2-可解释性：AI-模型的“黑箱困境”\"><a href=\"#5-2-可解释性：AI-模型的“黑箱困境”\" class=\"headerlink\" title=\"5.2 可解释性：AI 模型的“黑箱困境”\"></a>5.2 可解释性：AI 模型的“黑箱困境”</h3><ol>\n<li><strong>预测逻辑不可追溯</strong>：  <ul>\n<li>大模型（如2.5B参数的Nucleotide Transformer）的预测依赖复杂的注意力权重，难以解析“为何某变异被预测为致病性”；  </li>\n<li>对比传统方法（如 conservation score），gLMs的功能元件预测缺乏明确的生物学解释（如未直接关联进化保守性）；</li>\n</ul>\n</li>\n<li><strong>缺乏机制性解释</strong>：  <ul>\n<li>模型可预测“某DNA序列为增强子”，但无法解释“该序列通过何种机制调控基因表达”（如结合哪些TF）；  </li>\n<li>蛋白质结构预测模型（如AlphaFold3）可输出结构，但难以解析“结构如何决定功能”<sup>[6]</sup>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-3-计算成本：大模型的“资源门槛”\"><a href=\"#5-3-计算成本：大模型的“资源门槛”\" class=\"headerlink\" title=\"5.3 计算成本：大模型的“资源门槛”\"></a>5.3 计算成本：大模型的“资源门槛”</h3><ol>\n<li><strong>训练成本高昂</strong>：  <ul>\n<li>基础模型（如LucaOne）训练需1000+ GPU时，硬件成本超100万美元，小实验室难以承担；  </li>\n<li>长序列模型（如HyenaDNA，处理1M碱基）推理时间是传统模型的5-10倍，难以满足实时分析需求；</li>\n</ul>\n</li>\n<li><strong>数据存储与预处理</strong>：  <ul>\n<li>多物种基因组数据（如850个物种）存储量超10TB，预处理需专门的分布式系统；  </li>\n<li>单细胞数据维度超10<sup>5</sup>，需降维处理，易丢失关键信息<sup>[7]</sup>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-4-临床转化：从“实验室”到“病床”的鸿沟\"><a href=\"#5-4-临床转化：从“实验室”到“病床”的鸿沟\" class=\"headerlink\" title=\"5.4 临床转化：从“实验室”到“病床”的鸿沟\"></a>5.4 临床转化：从“实验室”到“病床”的鸿沟</h3><ol>\n<li><strong>模型性能与临床需求脱节</strong>：  <ul>\n<li>变异致病性预测模型在数据库中的AUC达0.89，但在真实临床样本中假阳性率超30%，难以直接用于诊断；  </li>\n<li>微生物组-疾病关联模型多基于横断面数据，缺乏纵向验证，难以指导疾病预防；</li>\n</ul>\n</li>\n<li><strong>伦理与隐私问题</strong>：  <ul>\n<li>人类基因组数据涉及隐私，模型训练需合规（如GDPR），限制数据共享；  </li>\n<li>AI设计的生物序列（如抗菌肽）可能存在未知安全性风险，缺乏统一的伦理评估标准<sup>[6]</sup>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"6-未来展望\"><a href=\"#6-未来展望\" class=\"headerlink\" title=\"6 未来展望\"></a>6 未来展望</h2><p>基于2024-2025年综述的共识，AI在生物信息学的未来发展将聚焦<strong>多模态融合、小样本学习、可解释性提升、临床转化</strong>四大方向，旨在解决当前挑战，实现“从技术创新到生物学发现”的跨越<sup>[4,6]</sup>。</p>\n<h3 id=\"6-1-多模态融合：构建“生物系统全景模型”\"><a href=\"#6-1-多模态融合：构建“生物系统全景模型”\" class=\"headerlink\" title=\"6.1 多模态融合：构建“生物系统全景模型”\"></a>6.1 多模态融合：构建“生物系统全景模型”</h3><ul>\n<li><strong>目标</strong>：整合DNA、RNA、蛋白质、表观遗传、细胞影像等多类型数据，构建覆盖“分子-细胞-个体”的多层次模型；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>统一模态表示（如将蛋白质结构转化为序列嵌入，与DNA嵌入融合）；  </li>\n<li>跨模态注意力机制（突出关键模态对（如DNA+表观数据）的协同作用）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>多模态基础模型可同时预测基因表达、蛋白质结构、细胞功能，为合成生物学提供“全链条设计工具”；  </li>\n<li>跨尺度模型（如分子-细胞）解析疾病的分子机制（如癌症发生的基因-蛋白质-细胞异常 cascade）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-2-小样本学习：解决“数据稀缺”难题\"><a href=\"#6-2-小样本学习：解决“数据稀缺”难题\" class=\"headerlink\" title=\"6.2 小样本学习：解决“数据稀缺”难题\"></a>6.2 小样本学习：解决“数据稀缺”难题</h3><ul>\n<li><strong>目标</strong>：在少标注数据（如罕见疾病变异、新发现微生物）场景下，仍保持高预测精度；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>迁移学习（如从人类基因组模型迁移到稀有物种基因组）；  </li>\n<li>数据增强（如生成合成生物序列，扩充训练集）；  </li>\n<li>零样本学习（如利用进化关系，预测未标注物种的蛋白质功能）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>罕见病变异诊断：基于100-1000个标注样本，模型致病性预测准确率达0.90；  </li>\n<li>新发现微生物功能解析：零样本预测新微生物的代谢通路，与实验结果一致性达0.85。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-3-可解释性提升：从“黑箱”到“透明模型”\"><a href=\"#6-3-可解释性提升：从“黑箱”到“透明模型”\" class=\"headerlink\" title=\"6.3 可解释性提升：从“黑箱”到“透明模型”\"></a>6.3 可解释性提升：从“黑箱”到“透明模型”</h3><ul>\n<li><strong>目标</strong>：让AI模型的预测可追溯、可验证，提供明确的生物学机制解释；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>注意力可视化（如解析gLMs中哪些碱基对功能预测起关键作用）；  </li>\n<li>motif 提取（如从PLMs中提取酶的催化位点 motif，与实验验证的 motif 比对）；  </li>\n<li>因果推断（如区分模型预测中的“相关关系”与“因果关系”，避免假阳性）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>临床变异解读：模型不仅预测致病性，还输出“该变异影响XX基因的XX功能域，导致XX蛋白结构异常”；  </li>\n<li>实验设计指导：模型推荐验证实验（如突变某TFBS，验证其对基因表达的影响）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-4-临床转化：加速“AI-实验-临床”闭环\"><a href=\"#6-4-临床转化：加速“AI-实验-临床”闭环\" class=\"headerlink\" title=\"6.4 临床转化：加速“AI-实验-临床”闭环\"></a>6.4 临床转化：加速“AI-实验-临床”闭环</h3><ul>\n<li><strong>目标</strong>：将AI模型从实验室推向临床，实现疾病诊断、药物研发、精准医疗的落地应用；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>临床数据微调（如用多中心临床样本微调模型，降低人群偏差）；  </li>\n<li>模型标准化（如制定gLMs的性能基准与评估标准，确保不同模型的可比性）；  </li>\n<li>安全性评估（如AI设计的生物序列需通过体外实验验证安全性）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>精准诊断：AI辅助解读肿瘤基因组变异，诊断准确率提升20%，假阳性率降低30%；  </li>\n<li>药物研发：AI设计抗菌肽药物，研发周期从2年缩短至6个月，临床试验成功率提升15%。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-结论\"><a href=\"#7-结论\" class=\"headerlink\" title=\"7 结论\"></a>7 结论</h2><p>本文通过整合2024-2025年AI在生物信息学的最新综述成果，系统梳理了技术演进（从传统深度学习到基础模型）、方法体系（语言模型、图模型、多模态模型）、应用领域（基因组、蛋白质组、微生物组、单细胞组学）与核心挑战（数据质量、可解释性、计算成本、临床转化），并展望了未来发展方向。  </p>\n<p>AI已成为生物信息学的核心驱动力，但其价值不仅在于“提升分析效率”，更在于“发现新的生物学规律”——如gLMs解析基因组的功能语法、PLMs揭示蛋白质的进化规律。后续系列文章将聚焦细分模型（DNA模型、蛋白质模型、统一模型）与场景（肽设计、酶工程、蛋白质互作），深入拆解AI技术的具体实现与应用细节，为读者提供从“全局认知”到“实践落地”的完整指引。  </p>\n<p>未来，随着多模态融合、小样本学习、可解释性技术的突破，AI将进一步推动生物信息学从“数据驱动”向“知识驱动”转型，为生命科学研究与临床应用提供更强大的工具支撑。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><p>[1] Asim MN, Ibrahim MA, Zaib A and Dengel A (2025) DNA sequence analysis landscape: a comprehensive review of DNA sequence analysis task types, databases, datasets, word embedding methods, and language models. Front. Med. 12:1503229. doi: <a href=\"https://doi.org/10.3389/fmed.2025.1503229\">10.3389&#x2F;fmed.2025.1503229</a></p>\n</li>\n<li><p>[2] Sarumi, Oluwafemi A. et al., Large language models and their applications in bioinformatics. Computational and Structural Biotechnology Journal, Volume 23, 3498-3505. doi: <a href=\"https://doi.org/10.1016/j.csbj.2024.09.031\">https://doi.org/10.1016/j.csbj.2024.09.031</a></p>\n</li>\n<li><p>[3]Zhenyu Wang, Zikang Wang, Jiyue Jiang, Pengan Chen, Xiangyu Shi, Yu Li. Large Language Models in Bioinformatics: A Survey.  arXiv:2503.04490v2. doi: <a href=\"\">https://doi.org/10.48550/arXiv.2503.04490</a><a href=\"https://doi.org/10.48550/arXiv.2503.04490\">https://doi.org/10.48550/arXiv.2503.04490</a></p>\n</li>\n<li><p>[4] Cui, H., Tejada-Lapuerta, A., Brbić, M. et al. Towards multimodal foundation models in molecular cell biology. Nature 640, 623–633 (2025). <a href=\"https://doi.org/10.1038/s41586-025-08710-y\">https://doi.org/10.1038/s41586-025-08710-y</a></p>\n</li>\n<li><p>[5] Chen Z, Wei L, Gao G. Foundation models for bioinformatics. Quantitative Biology. 2024; 12(4): 339–44. <a href=\"https://doi.org/10.1002/qub2.69\">https://doi.org/10.1002/qub2.69</a></p>\n</li>\n<li><p>[6] Wei Ruan, Yanjun Lyu, Jing Zhang et al., Large Language Models for Bioinformatics. arXiv:2501.06271v1. doi:<br><a href=\"https://doi.org/10.48550/arXiv.2501.06271\">https://doi.org/10.48550/arXiv.2501.06271</a></p>\n</li>\n<li><p>[7] Szałata, A., Hrovatin, K., Becker, S. et al. Transformers in single-cell omics: a review and new perspectives. Nat Methods 21, 1430–1443 (2024). <a href=\"https://doi.org/10.1038/s41592-024-02353-z\">https://doi.org/10.1038/s41592-024-02353-z</a></p>\n</li>\n</ul>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"BioAI 专辑：解读 AI 重塑生物信息学研究逻辑","slug":"BioAI 专辑：解读 AI 重塑生物信息学研究逻辑","date":"2025-11-11T10:33:35.000Z","updated":"2025-11-11T11:56:35.606Z","comments":true,"path":"api/articles/BioAI 专辑：解读 AI 重塑生物信息学研究逻辑.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","content":"<h1 id=\"当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？\"><a href=\"#当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？\" class=\"headerlink\" title=\"当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？\"></a>当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？</h1><p>作为一名深耕生物信息学13年的研究者，我亲历过行业的“数据焦虑”与“效率瓶颈”。而如今，同样的工作场景早已天翻地覆——AlphaFold3能在几小时内精准预测蛋白质与核酸、小分子的复合物结构，AI工具仅凭免疫细胞序列就能区分10余种疾病亚型，甚至能让老药实现“跨界”抗癌。</p>\n<p>这种变革不是偶然，而是人工智能与生物信息学深度融合的必然结果。今天，我正式推出【BioAI前沿解读】专辑，带你穿透技术迷雾，看懂AI如何重塑我们熟悉的生物信息学研究逻辑。</p>\n<h2 id=\"1-AI不是“替代者”，而是传统方法的“破壁人”\"><a href=\"#1-AI不是“替代者”，而是传统方法的“破壁人”\" class=\"headerlink\" title=\"1. AI不是“替代者”，而是传统方法的“破壁人”\"></a>1. AI不是“替代者”，而是传统方法的“破壁人”</h2><p>传统生物信息学始终被两大痛点束缚：<strong>海量数据的“解读困境”</strong> 与<strong>实验验证的“高成本陷阱”</strong>。而AI的介入，正从根上破解这些僵局，每一个突破都有扎实的研究支撑：</p>\n<p>在<strong>蛋白质结构研究领域</strong>，2024年《Nature》发表的AlphaFold3，通过改进的Evoformer模块和扩散模型，不仅能预测蛋白质单体结构，还能精准建模蛋白质-DNA、蛋白质-小分子复合物，针对膜蛋白复合物的预测准确率比传统冷冻电镜方法高出52%。</p>\n<p>在<strong>基因编辑领域</strong>，CRISPR-Cas9的脱靶风险曾是临床转化的“死穴”。《Nature Biotechnology》发表的瑞士苏黎世联邦理工学院团队成果——AI工具Pythia，通过学习10万组基因编辑数据的修复模式，能预判细胞对编辑位点的修复倾向，设计的“精准修复模板”让HeLa细胞的编辑脱靶率从12.7%降至1.3%，这是传统试错法永远无法达到的精度。</p>\n<p>更贴近临床的突破来自<strong>疾病诊断</strong>：2025年《Science》刊登的斯坦福大学研究中，AI工具<a href=\"https://www.science.org/doi/10.1126/science.adp2407\">Mal-ID</a>通过分析血液中B细胞和T细胞的受体序列，对542名受试者的COVID-19、艾滋病、1型糖尿病等8种疾病进行诊断，AUC值（曲线下面积）均超过0.95，甚至能识别出传统检测遗漏的早期潜伏感染病例——这种“免疫序列解码”的思路，是我们10年前想都不敢想的。</p>\n<p>这些成果背后，是AI对传统方法的“降维打击”——当深度学习的模式识别能力遇上基因组、转录组、蛋白质组的海量数据，曾经隐藏在数据中的生命密码，正被逐一解码。</p>\n<h2 id=\"2-BioAI的黄金时代：不止于工具，更是研究范式的革命\"><a href=\"#2-BioAI的黄金时代：不止于工具，更是研究范式的革命\" class=\"headerlink\" title=\"2. BioAI的黄金时代：不止于工具，更是研究范式的革命\"></a>2. BioAI的黄金时代：不止于工具，更是研究范式的革命</h2><p>如果说5年前AI还只是生物研究的“辅助工具”，如今它早已成为<strong>研究范式的重构者</strong>。尤其值得关注的是DNA和蛋白质领域的大语言模型（LLM），正在开辟全新研究路径：</p>\n<p>在<strong>DNA LLM领域</strong>，2021年《Bioinformatics》发表的<a href=\"https://pubmed.ncbi.nlm.nih.gov/33538820/\">DNABERT</a>是里程碑式突破——它将DNA序列按3个碱基为单位（密码子）进行编码，通过BERT架构学习基因组的“语法规则”，识别启动子、增强子等调控元件的准确率比传统的HMM（隐马尔可夫模型）高出23%。</p>\n<p>在<strong>蛋白质LLM领域</strong>，2022年《Bioinformatics》发表的<a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC9386727/\">ProtBERT</a>首次将Transformer架构应用于蛋白质序列分析，通过学习UniProt数据库中1亿条蛋白质序列的特征，预测氨基酸突变对蛋白质功能的影响准确率达0.89。而2023年《Nature Biotechnology》发表的<a href=\"https://www.nature.com/articles/s41587-022-01618-2\">ProGen2</a>更实现了“创造性突破”——它能根据指定功能（如“结合钙离子”、“酶解纤维素”）从头设计蛋白质序列。</p>\n<h2 id=\"3-这个专辑，我想带你看懂什么？\"><a href=\"#3-这个专辑，我想带你看懂什么？\" class=\"headerlink\" title=\"3. 这个专辑，我想带你看懂什么？\"></a>3. 这个专辑，我想带你看懂什么？</h2><p>BioAI领域的论文和工具层出不穷，但很多前沿成果被包裹在复杂的算法公式里，非计算机背景的研究者很难快速转化应用。这正是我做这个专辑的初衷：<strong>把复杂技术讲透彻，把前沿成果落地上</strong>。</p>\n<p>在后续内容中，你会看到这些核心板块：</p>\n<ul>\n<li><p><strong>顶刊论文深度拆解</strong>：从AlphaFold3的扩散模型创新，到DNABERT的序列编码逻辑，我会抽丝剥茧解读核心算法，告诉你“AI为什么能做到”，并标注关键文献供大家溯源；</p>\n</li>\n<li><p><strong>实用工具实操指南</strong>：模型本地化部署教程、软件使用指南等干货，解决“想用时用不了”的难题；</p>\n</li>\n<li><p><strong>LLM解读</strong>：详解DNA LLM、蛋白质LLM的训练逻辑、应用场景，结合我自己的研究案例说明“如何用LLM解决实际问题”；</p>\n</li>\n</ul>\n<p>BioAI不是“技术炫技”，而是能真正落地解决研究痛点的“生产力工具”。它不会取代实验科学，而是让我们从重复的数据分析中解放出来，把更多精力投入到更富创造性的假设提出与实验设计中。</p>\n<p>如果你有想解读的论文、关注的方向，或是在研究中遇到的AI应用难题，欢迎在评论区留言——我会把大家关心的话题纳入后续内容。</p>\n<p>关注我，下一篇，不见不散！ 🌟</p>\n<p><font color=\"#FF0000\"><b>注：若读者对深度学习的基本概念和术语不了解，也可以阅读我的《PyTorch专辑》，从基础理论到案例实践都有，通过理论学习和代码练习快速入门深度学习。</b></font></p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"在Ubuntu中配置Python文字识别环境（基于Tesseract OCR）","slug":"在Ubuntu中配置Python文字识别环境（基于Tesseract-OCR）","date":"2025-10-19T13:41:46.000Z","updated":"2025-10-19T13:54:33.097Z","comments":true,"path":"api/articles/在Ubuntu中配置Python文字识别环境（基于Tesseract-OCR）.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","content":"<p>文字识别（OCR）是处理图像或PDF中文字内容的重要技术，Tesseract OCR是一款开源高效的OCR引擎，结合Python库可快速实现文字提取功能。本文将详细介绍在Ubuntu系统中配置支持中文的Python文字识别环境的步骤，适用于处理图片、PDF等文件中的文字内容。</p>\n<h2 id=\"一、安装Tesseract-OCR引擎\"><a href=\"#一、安装Tesseract-OCR引擎\" class=\"headerlink\" title=\"一、安装Tesseract OCR引擎\"></a>一、安装Tesseract OCR引擎</h2><p>Tesseract是核心OCR引擎，需先安装其基础程序。</p>\n<ol>\n<li><p>打开终端，更新系统包列表：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Tesseract OCR引擎：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install tesseract-ocr</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这一步将安装Tesseract的核心程序，支持基础的文字识别功能（默认包含英文语言包）。</p>\n<h2 id=\"二、安装并配置中文语言包\"><a href=\"#二、安装并配置中文语言包\" class=\"headerlink\" title=\"二、安装并配置中文语言包\"></a>二、安装并配置中文语言包</h2><p>默认安装的Tesseract不包含中文语言包，需单独安装并修正文件名（避免因命名格式导致识别失败）。</p>\n<ol>\n<li><p>安装中文简体语言包：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install tesseract-ocr-chi-sim</span><br></pre></td></tr></table></figure>\n\n<p> （可选）若需识别繁体中文，可额外安装：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install tesseract-ocr-chi-tra</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修正语言包文件名（关键步骤）：</p>\n</li>\n</ol>\n<p>Tesseract对语言包的文件名格式有严格规范，但实际使用中，其对文件名的识别存在一定兼容性差异：安装后中文语言包默认文件名为下划线格式（<code>chi_sim.traineddata</code> 对应简体，<code>chi_tra.traineddata</code> 对应繁体），但部分场景下程序可能要求使用连字符格式（<code>chi-sim.traineddata</code>、<code>chi-tra.traineddata</code>）。为避免因文件名格式导致识别失败，建议复制一份以连字符命名的文件，从而兼容不同场景下的调用需求。：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修正简体中文包文件名</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> /usr/share/tesseract-ocr/4.00/tessdata/chi_sim.traineddata /usr/share/tesseract-ocr/4.00/tessdata/chi-sim.traineddata</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># （可选）修正繁体中文包文件名</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> /usr/share/tesseract-ocr/4.00/tessdata/chi_tra.traineddata /usr/share/tesseract-ocr/4.00/tessdata/chi-tra.traineddata</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、验证Tesseract安装与语言包配置\"><a href=\"#三、验证Tesseract安装与语言包配置\" class=\"headerlink\" title=\"三、验证Tesseract安装与语言包配置\"></a>三、验证Tesseract安装与语言包配置</h2><p>安装完成后，需确认引擎和语言包是否正常生效。</p>\n<ol>\n<li><p>检查Tesseract版本（验证引擎安装）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract --version</span><br></pre></td></tr></table></figure>\n\n<p> 若输出类似<code>tesseract 4.0.0</code>的版本信息，说明引擎安装成功。</p>\n</li>\n<li><p>检查已安装的语言包（验证中文支持）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract --list-langs</span><br></pre></td></tr></table></figure>\n\n<p> 若输出包含<code>chi-sim</code>（简体中文）和<code>chi-tra</code>（繁体中文），说明中文语言包配置成功。</p>\n</li>\n</ol>\n<h2 id=\"四、配置TESSDATA-PREFIX环境变量\"><a href=\"#四、配置TESSDATA-PREFIX环境变量\" class=\"headerlink\" title=\"四、配置TESSDATA_PREFIX环境变量\"></a>四、配置TESSDATA_PREFIX环境变量</h2><p>Tesseract需要通过<code>TESSDATA_PREFIX</code>环境变量定位语言包目录，需手动配置以确保引擎能正确找到语言包。</p>\n<ol>\n<li><p>编辑环境变量配置文件（以bash为例）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export TESSDATA_PREFIX=/usr/share/tesseract-ocr/4.00/&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p> 说明：<code>TESSDATA_PREFIX</code>需指向<code>tessdata</code>目录。</p>\n</li>\n<li><p>使环境变量生效：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>（若使用zsh，需将命令中的<code>~/.bashrc</code>替换为<code>~/.zshrc</code>）</p>\n<h2 id=\"五、安装Python相关依赖库\"><a href=\"#五、安装Python相关依赖库\" class=\"headerlink\" title=\"五、安装Python相关依赖库\"></a>五、安装Python相关依赖库</h2><p>通过Python调用Tesseract需安装对应的接口库，同时为处理PDF文件需补充相关工具库。</p>\n<ol>\n<li><p>安装核心Python库：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pytesseract PyPDF2 pdf2image pdfplumber opencv-python pillow</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 各库作用说明：</p>\n<ul>\n<li><p><code>pytesseract</code>：Python调用Tesseract OCR的接口库；</p>\n</li>\n<li><p><code>PyPDF2</code>&#x2F;<code>pdfplumber</code>：用于读取PDF文件（支持文本型PDF直接提取）；</p>\n</li>\n<li><p><code>pdf2image</code>：将图片型PDF转换为图片格式（以便Tesseract识别）;</p>\n</li>\n<li><p><code>opencv-python</code>：主要用于计算机视觉任务，可实现图像处理、视频分析、目标检测、边缘识别等复杂功能，是机器视觉领域的常用库；</p>\n</li>\n<li><p><code>pillow</code>：是轻量易用的 Python 图像库，核心用于基础图像操作，包括图像的读写、裁剪、尺寸调整、色彩调整及简单滤镜效果实现。</p>\n</li>\n</ul>\n</li>\n<li><p>（可选）若<code>pdf2image</code>运行时提示缺少依赖，需安装图片处理工具：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install poppler-utils</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"六、注意事项\"><a href=\"#六、注意事项\" class=\"headerlink\" title=\"六、注意事项\"></a>六、注意事项</h2><ol>\n<li><p>环境变量生效范围：上述配置仅对当前用户生效，若需全局生效，可将环境变量写入<code>/etc/profile</code>（需管理员权限）。</p>\n</li>\n<li><p>虚拟环境问题：若在Python虚拟环境中使用，需在虚拟环境激活后重新执行<code>source ~/.bashrc</code>（或手动设置<code>TESSDATA_PREFIX</code>）。</p>\n</li>\n<li><p>权限问题：确保运行程序的用户对<code>/usr/share/tesseract-ocr/4.00/tessdata/</code>目录及语言包文件有读取权限（默认权限已满足，无需额外配置）。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上步骤，即可在Ubuntu系统中完成支持中文的Python文字识别环境配置。基于Tesseract OCR和Python库，可实现图片、PDF等文件的文字提取功能，为后续的文本分析、内容处理等场景奠定基础。</p>\n<h2 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h2><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"图像识别","path":"api/tags/图像识别.json"}]},{"title":"CentOS 7 升级 GCC 教程（以 GCC 9 为例）","slug":"CentOS-7-升级-GCC-教程（以-GCC-9-为例）","date":"2025-10-19T13:33:35.000Z","updated":"2025-10-19T13:40:18.210Z","comments":true,"path":"api/articles/CentOS-7-升级-GCC-教程（以-GCC-9-为例）.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","content":"<h2 id=\"一、教程背景\"><a href=\"#一、教程背景\" class=\"headerlink\" title=\"一、教程背景\"></a>一、教程背景</h2><p>CentOS 7 系统默认预装的 GCC 版本为 <strong>4.8.5</strong>（发布于 2015 年），而现代开发场景中，许多软件（如高版本 Python、TensorFlow、C++ 11+ 项目等）对 GCC 版本要求较高（需 5.4+ 及以上）。因此需升级 GCC，但直接覆盖系统默认 GCC 可能导致依赖冲突（如 <code>yum</code> 工具依赖旧版本）。</p>\n<p>本教程采用 <strong>SCL（Software Collections）仓库</strong> 方式升级，可在不覆盖系统默认 GCC 的前提下，安装并使用高版本 GCC（以 GCC 9 为例，稳定且兼容性强），安全且灵活。</p>\n<h2 id=\"二、升级前准备\"><a href=\"#二、升级前准备\" class=\"headerlink\" title=\"二、升级前准备\"></a>二、升级前准备</h2><p>确保系统已联网，且拥有 <code>root</code> 权限（或使用 <code>sudo</code> 权限执行命令）。</p>\n<h2 id=\"三、详细升级步骤\"><a href=\"#三、详细升级步骤\" class=\"headerlink\" title=\"三、详细升级步骤\"></a>三、详细升级步骤</h2><h3 id=\"1-备份原有-YUM-源（关键：防止配置出错）\"><a href=\"#1-备份原有-YUM-源（关键：防止配置出错）\" class=\"headerlink\" title=\"1. 备份原有 YUM 源（关键：防止配置出错）\"></a>1. 备份原有 YUM 源（关键：防止配置出错）</h3><p>CentOS 7 停止官方维护后，默认 YUM 源可能失效，且后续需添加新仓库配置。先备份原有源文件，避免误操作后无法恢复：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建备份目录</span></span><br><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /etc/yum.repos.d/backup</span><br><span class=\"line\"><span class=\"comment\"># 将所有 .repo 源文件移动到备份目录</span></span><br><span class=\"line\">sudo <span class=\"built_in\">mv</span> /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup/</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-添加-SCL-仓库配置文件（使用阿里云源）\"><a href=\"#2-添加-SCL-仓库配置文件（使用阿里云源）\" class=\"headerlink\" title=\"2. 添加 SCL 仓库配置文件（使用阿里云源）\"></a>2. 添加 SCL 仓库配置文件（使用阿里云源）</h3><p>SCL 仓库是升级 GCC 的核心，这里选择 <strong>阿里云 SCL 源</strong>（国内访问速度快，稳定性高），手动创建仓库配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用 vi 编辑器创建并编辑 centos-sclo-rh.repo 文件</span></span><br><span class=\"line\">sudo vi /etc/yum.repos.d/centos-sclo-rh.repo</span><br></pre></td></tr></table></figure>\n\n<p>打开编辑器后，按 <code>i</code> 进入编辑模式，<strong>完整复制以下内容</strong>（不要遗漏或修改格式）：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos-sclo-rh]</span><br><span class=\"line\">name=CentOS-7 - SCLo rh</span><br><span class=\"line\">baseurl=https://mirrors.aliyun.com/centos/7/sclo/x86_64/rh/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-SIG-SCLo</span><br><span class=\"line\">enabled=1</span><br></pre></td></tr></table></figure>\n\n<p>复制完成后，按 <code>Esc</code> 退出编辑模式，输入 <code>:wq</code> 并回车（保存并退出 vi 编辑器）。</p>\n<h3 id=\"3-清理-YUM-缓存并生成新缓存\"><a href=\"#3-清理-YUM-缓存并生成新缓存\" class=\"headerlink\" title=\"3. 清理 YUM 缓存并生成新缓存\"></a>3. 清理 YUM 缓存并生成新缓存</h3><p>新添加仓库后，需清理旧缓存、加载新仓库的包列表，确保后续安装能找到正确的软件包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理所有 YUM 缓存</span></span><br><span class=\"line\">sudo yum clean all &amp;&amp; </span><br><span class=\"line\"><span class=\"comment\"># 生成新的缓存（下载阿里云源的包列表）</span></span><br><span class=\"line\">sudo yum makecache</span><br></pre></td></tr></table></figure>\n\n<p>执行后耐心等待（时间取决于网络速度），若无报错则缓存生成成功。</p>\n<h3 id=\"4-（可选）安装-SCL-仓库基础包\"><a href=\"#4-（可选）安装-SCL-仓库基础包\" class=\"headerlink\" title=\"4. （可选）安装 SCL 仓库基础包\"></a>4. （可选）安装 SCL 仓库基础包</h3><p>多数情况下，步骤 2 添加的配置文件已足够，但若后续安装 GCC 时提示“仓库不存在”，可执行此步骤安装 SCL 仓库基础包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y centos-release-scl</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-安装高版本-GCC（GCC-9）\"><a href=\"#5-安装高版本-GCC（GCC-9）\" class=\"headerlink\" title=\"5. 安装高版本 GCC（GCC 9）\"></a>5. 安装高版本 GCC（GCC 9）</h3><p>通过 YUM 安装 <code>devtoolset-9</code>（对应 GCC 9 版本），并添加 <code>--nogpgcheck</code> 参数（跳过 GPG 密钥验证，因 CentOS 7 官方密钥源已失效，不影响包安全性）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils --nogpgcheck</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>devtoolset-9-gcc</code>：GCC 9 核心包</li>\n<li><code>devtoolset-9-gcc-c++</code>：C++ 编译组件（如需编译 C++ 项目必装）</li>\n<li><code>devtoolset-9-binutils</code>：二进制工具集（辅助编译）</li>\n</ul>\n<p>执行后等待安装完成（约 50MB 下载量），无报错则安装成功。</p>\n<h3 id=\"6-启用高版本-GCC\"><a href=\"#6-启用高版本-GCC\" class=\"headerlink\" title=\"6. 启用高版本 GCC\"></a>6. 启用高版本 GCC</h3><p>SCL 安装的 GCC 不会自动生效，需手动启用，支持 <strong>临时启用</strong> 和 <strong>永久启用</strong>，根据需求选择：</p>\n<h4 id=\"方式-1：临时启用（仅当前终端有效）\"><a href=\"#方式-1：临时启用（仅当前终端有效）\" class=\"headerlink\" title=\"方式 1：临时启用（仅当前终端有效）\"></a>方式 1：临时启用（仅当前终端有效）</h4><p>适用于“临时使用高版本 GCC”的场景，关闭终端后恢复默认 GCC 4.8.5：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scl <span class=\"built_in\">enable</span> devtoolset-9 bash</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方式-2：永久启用（推荐）\"><a href=\"#方式-2：永久启用（推荐）\" class=\"headerlink\" title=\"方式 2：永久启用（推荐）\"></a>方式 2：永久启用（推荐）</h4><p>若需每次登录终端都自动使用 GCC 9，可将启用命令写入环境变量文件，分“当前用户”和“全局所有用户”两种场景：</p>\n<h5 id=\"场景-A：仅当前用户生效（推荐普通用户）\"><a href=\"#场景-A：仅当前用户生效（推荐普通用户）\" class=\"headerlink\" title=\"场景 A：仅当前用户生效（推荐普通用户）\"></a>场景 A：仅当前用户生效（推荐普通用户）</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将启用命令写入当前用户的 .bashrc 文件</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 立即生效（无需重启终端）</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"场景-B：全局所有用户生效（需-root-权限）\"><a href=\"#场景-B：全局所有用户生效（需-root-权限）\" class=\"headerlink\" title=\"场景 B：全局所有用户生效（需 root 权限）\"></a>场景 B：全局所有用户生效（需 root 权限）</h5><p>适用于多用户服务器，所有用户登录后均使用 GCC 9：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到 root 用户（若当前非 root）</span></span><br><span class=\"line\">su root</span><br><span class=\"line\"><span class=\"comment\"># 将启用命令写入全局环境变量文件 /etc/profile</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt; /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 立即生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-验证-GCC-升级结果\"><a href=\"#7-验证-GCC-升级结果\" class=\"headerlink\" title=\"7. 验证 GCC 升级结果\"></a>7. 验证 GCC 升级结果</h3><p>执行以下命令查看当前 GCC 版本，确认是否升级成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -v</span><br></pre></td></tr></table></figure>\n\n<p>若输出类似以下内容（版本号为 9.3.1 及以上），则说明升级成功：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using built-in specs.</span><br><span class=\"line\">COLLECT_GCC=gcc</span><br><span class=\"line\">COLLECT_LTO_WRAPPER=/opt/rh/devtoolset-9/root/usr/libexec/gcc/x86_64-redhat-linux/9/lto-wrapper</span><br><span class=\"line\">Target: x86_64-redhat-linux</span><br><span class=\"line\">Configured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,lto --prefix=/opt/rh/devtoolset-9/root/usr --mandir=/opt/rh/devtoolset-9/root/usr/share/man --infodir=/opt/rh/devtoolset-9/root/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style=gnu --with-default-libstdcxx-abi=gcc4-compatible --enable-plugin --enable-initfini-array --with-isl=/builddir/build/BUILD/gcc-9.3.1-20200408/obj-x86_64-redhat-linux/isl-install --disable-libmpx --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\">gcc version 9.3.1 20200408 (Red Hat 9.3.1-2.2.el7) (GCC)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"四、常见问题与注意事项\"><a href=\"#四、常见问题与注意事项\" class=\"headerlink\" title=\"四、常见问题与注意事项\"></a>四、常见问题与注意事项</h2><ol>\n<li><p><strong>若需安装其他 GCC 版本</strong>：<br>本教程以 GCC 9 为例，若需安装 GCC 10，只需将命令中的 <code>devtoolset-9</code> 替换为 <code>devtoolset-10</code>（如 <code>devtoolset-10-gcc</code>），其他步骤一致。</p>\n</li>\n<li><p><strong>系统默认 GCC 未被覆盖</strong>：<br>SCL 安装的 GCC 位于 <code>/opt/rh/devtoolset-9/root/usr/bin/</code>，系统默认 GCC（4.8.5）仍在 <code>/usr/bin/gcc</code>，若需临时使用旧版本，可直接执行 <code>/usr/bin/gcc -v</code>。</p>\n</li>\n<li><p><strong>安装时提示“无可用软件包”</strong>：<br>重新执行步骤 3（清理并生成缓存），或检查步骤 2 的仓库配置文件是否正确（确保 <code>baseurl</code> 未写错）。</p>\n</li>\n</ol>\n<h2 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h2><p>通过本教程，可在 CentOS 7 上安全升级 GCC 至 9 版本（或更高），满足现代软件开发需求，且不影响系统原有依赖。若后续需编译软件（如 Python、C++ 项目），直接使用 <code>gcc</code> 或 <code>g++</code> 命令即可调用高版本工具。</p>\n<h2 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h2><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"Linux","path":"api/tags/Linux.json"},{"name":"系统","path":"api/tags/系统.json"}]},{"title":"What is RAG","slug":"What-is-RAG","date":"2025-08-03T08:49:01.000Z","updated":"2025-08-03T08:53:50.219Z","comments":true,"path":"api/articles/What-is-RAG.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/RAG.png","content":"<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/RAG.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/RAG.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"一图看懂RAG\"></p>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n\n","raw":null,"categories":[],"tags":[]},{"title":"一种用于多重图像处理与分析的端到端工作流程","slug":"一种用于多重图像处理与分析的端到端工作流程","date":"2025-06-30T12:42:04.000Z","updated":"2025-07-11T14:10:37.243Z","comments":true,"path":"api/articles/一种用于多重图像处理与分析的端到端工作流程.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig1.jpg","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>多重成像技术能够在单细胞分辨率下同时对组织中的数十种生物分子进行空间分析。从多重组织成像数据中提取生物学相关信息（如细胞表型的空间分布）涉及多项计算任务，包括图像分割、特征提取和空间分辨的单细胞分析。在此，我们提出了一种用于多重组织图像处理和分析的端到端工作流程，该流程整合了之前开发的计算工具，以用户友好和可定制的方式实现这些任务。在数据质量评估方面，我们强调了napari-imc在交互式检查原始成像数据方面的实用性，以及cytomapper R&#x2F;Bioconductor包在R中进行图像可视化的功能。使用steinbock工具包执行原始数据预处理、图像分割和特征提取。我们展示了两种基于监督像素分类和预训练深度学习模型的细胞分割替代方法。提取的单细胞数据随后在R中进行读取、处理和分析。该方案描述了使用社区建立的数据容器的方法，从而便于应用R&#x2F;Bioconductor包进行降维、单细胞可视化和表型分析。我们提供了使用imcRtools R&#x2F;Bioconductor包进行空间分辨单细胞分析的说明，包括群落分析、细胞邻域检测和细胞-细胞相互作用测试。该工作流程之前已应用于成像质谱细胞计数数据，但可以轻松适应其他高度多重成像技术。本方案可由具有基本生物信息学培训的研究人员实施，并且所提供的数据集的分析可在5–6小时内完成。扩展版本可在<a href=\"https://bodenmillergroup.github.io/IMCDataAnalysis/%E4%B8%8A%E8%8E%B7%E5%BE%97%E3%80%82\">https://bodenmillergroup.github.io/IMCDataAnalysis/上获得。</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>高度多重成像技术能够在组织中同时检测到数十种生物分子（如蛋白质和转录本，也称为“标志物”）。最近建立的多重组织成像技术依赖于荧光标记抗体的循环染色技术[1–3]，或使用寡核苷酸标记的[4,5]或金属标记的[6,7]抗体等技术。这些技术的关键优势在于，它们允许对组织空间环境中的单个细胞进行深入分析。因此，这些方法已经能够对肿瘤微环境的空间结构[1,8–10]、用于评估细胞类型和趋化因子空间共定位的核酸和蛋白质丰度[11]、病毒感染细胞的空间生态位[12]，以及2019年冠状病毒病（COVID-19）感染[13,14]、1型糖尿病进展[15]和自身免疫性疾病[16]期间的病理特征进行分析。</p>\n<p>为了充分利用多重成像数据中包含的信息进行生物学和临床分析，无论生物学问题是什么，都必须执行一系列计算步骤。这些步骤包括：（1）对图像进行目视检查，以初步评估数据质量；（2）生物图像处理与分割，以提取用于下游分析的单细胞特征；（3）单细胞分析，如将单细胞数据投影到低维空间、进行聚类和细胞表型分析，以支持探索性数据分析和量化样本之间的生物学差异[8,15,17]；（4）利用从多重成像数据中提取的空间信息来检测细胞表型之间的相互作用或避免作用[18]、表征细胞邻域（CNs）[5,10,19]和空间群落[8]，以及识别相似细胞的斑块[11]。存在许多计算工具和方法来执行上述步骤；然而，许多工具缺乏互操作性、可扩展性，并且依赖于复杂的自定义脚本。</p>\n<p>在此，我们提出了一种简化且易于扩展的多重图像分析端到端工作流程，该流程支持所有关键步骤，并与现有软件实现互操作性。该工作流程最初是为分析成像质谱细胞计数（IMC）数据而开发的，也适用于其他高度多重成像技术生成的数据。我们专门为可视化原始IMC数据开发的napari图像查看器插件napari-imc可实现交互式图像可视化。steinbock工具包可实现多重图像处理，包括数据提取、图像分割和数据导出。具体而言，我们展示了使用监督像素分类[21,22]和预训练深度学习模型[23]的分割方法，以从多重图像中提取空间分辨的单细胞信息。随后，imcRtools R&#x2F;Bioconductor包将生成的单细胞数据读入R编程语言。通过使用社区建立的数据容器，该工作流程集成了许多先前开发的R&#x2F;Bioconductor包，以执行信号溢出校正[24]，并允许进行低维可视化、质量控制、细胞表型分析、单细胞聚类和图像可视化[17,25]。最后，我们描述了如何以用户友好的方式使用imcRtools包执行空间群落分析、细胞邻域（CN）和空间上下文（SC）检测、细胞斑块表征和细胞表型相互作用分析。工作流程中使用的所有工具都记录详尽，并且旨在通过互操作性、可重复性和用户友好性分析，为接受过基本生物信息学培训的研究人员提供服务。我们描述了该工作流程，强调了常见陷阱，并讨论了针对各个步骤进行故障排除的方法。</p>\n<h1 id=\"程序概述\"><a href=\"#程序概述\" class=\"headerlink\" title=\"程序概述\"></a>程序概述</h1><p>本方案描述了分析由高度多重组织成像技术生成的数据的基本步骤。整个流程分为九个阶段：交互式成像数据可视化（步骤1-5）、数据预处理（步骤6）、图像分割（步骤7）、单细胞特征提取（步骤8）、将数据读入R（步骤9-13）、溢出校正（步骤14-21）、质量控制（步骤22-27）、细胞表型分析（步骤28-30）和空间分辨单细胞分析（步骤31-35）。图1给出了该程序的概览，而工作流程的详细描述可在<a href=\"https://bodenmillergroup.github.io/IMCDataAnalysis/%E4%B8%8A%E6%9F%A5%E9%98%85%E3%80%82\">https://bodenmillergroup.github.io/IMCDataAnalysis/上查阅。</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig1.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig1.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1 | 多重组织图像分析工作流程概述。原始成像数据可通过使用如napari-imc等napari插件进行交互式检查，以评估数据质量和进行探索性可视化（步骤1–5），适用于IMC（离子束成像）。数据预处理是从原始数据中提取TIFF格式的多通道图像（步骤6）。图像分割可通过应用预训练的深度学习模型（左侧）或通过监督像素分类（右侧）来执行。我们重点介绍了使用steinbook工具包进行深度学习分割，以及使用Ilastik和CellProfiler进行基于像素分类的分割（步骤7–8）。空间分辨单细胞数据可通过imcRtools（https://bioconductor.org/packages/release/bioc/html/imcRtools.html）和cytomapper R/Bioconductor软件包（https://bioconductor.org/packages/release/bioc/html/cytomapper.html）读入R（步骤9–13），这些软件包支持溢出校正、质量控制、细胞表型分析和空间分析（步骤14–35）。BiocStickers根据知识共享许可协议CC0 1.0从https://github.com/Bioconductor/BiocStickers重新印制。\"></p>\n<p>在计算分析之前，通过灵活可视化标记丰度对原始成像数据进行定性检查是手动评估数据质量的关键步骤26。最近开发的多维图像查看器<code>napari</code>能够实现多通道图像的快速交互式可视化20。为了方便检查原始离子束成像（IMC）数据，我们开发了<code>napari-imc</code>插件，该插件使napari能够加载<code>Hyperion</code>成像系统生成的<code>MCD/TXT</code>文件。使用napari-imc，研究人员可以将多重IMC采集数据与仪器获取的光学图像（用于区域选择，即“全景图”）进行叠加，从而便于对原始数据进行定性检查。对于其他多重成像技术，如多重离子束成像（MIBI）7、通过索引共检测（CODEX）5和循环免疫荧光（CyCIF）1，这些技术无法提供生物样本的固有多模态视图（这些数据相当于IMC采集数据，而非IMC全景图），成像数据通常可以转换为napari原生支持的文件格式。</p>\n<p>多通道图像处理能够实现多重成像捕获的生物实体的定量分析。单个处理步骤包括图像提取和预处理、图像分割以及生物对象（如细胞）的量化。本文介绍了如何使用<code>Ilastik</code><sup>21</sup>和<code>CellProfiler</code><sup>22</sup>执行基于随机森林的监督像素分类图像分割（以下简称“基于像素分类的分割”）。这种方法之前曾被用于从多重图像中提取单细胞信息，以进行组织空间表征<sup>8,13,15,27</sup>。作为一种替代策略，我们还提供了使用深度学习支持的Mesmer分割算法23（以下简称“基于深度学习的分割”）执行基于预训练神经网络的全自动细胞分割的指南。我们的<code>steinbock</code>多通道图像处理工具包提供了基于深度学习的分割方法。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig2.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig2.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2 | 图像处理后的数据输出及在R中的表示。在图像处理过程中，首先对所有提供的多通道图像进行分割，以检测并存储为分割掩膜的单个细胞。基于这些分割掩膜，提取单细胞特征，包括每个细胞和通道的平均像素强度、形态学特征、细胞的xy位置（区域属性）和空间细胞图。为了在R中处理生成的数据，将所有多通道图像读入一个单一的`CytoImageList`对象，将所有分割掩膜读入另一个单一的CytoImageList对象，并将所有图像的单细胞特征读入一个单一的`SpatialExperiment`对象。患者和图像级别的特征分别存储在每个CytoImageList对象的`elementMetadata`插槽和SpatialExperiment对象的`colData`插槽中。BiocStickers根据知识共享许可协议CC0 1.0从https://github.com/Bioconductor/BiocStickers重新印制。\"></p>\n<p>图像分割和空间分辨单细胞数据提取后，将执行下游分析步骤以表征组织环境中的细胞。为此，分别使用imcRtools和cytomapper R&#x2F;Bioconductor软件包将单细胞数据和图像读入R（图2）。初步数据处理步骤包括溢出校正，以纠正相邻通道间的伪信号24，以及分割和样本质量控制。通过将单细胞数据存储在R&#x2F;Bioconductor的SpatialExperiment28对象中，该工作流程促进了单细胞数据分析步骤，包括使用现有工具进行聚类、降维、可视化和批次校正17,29,30。为了检测具有相似标记表达（以下简称“细胞表型”）的细胞群，我们描述了两种基于标记真实数据的单细胞聚类和分类的替代方法。最后，我们描述了<code>imcRtools</code>软件包支持的一系列空间数据分析任务，以表征空间组织结构。我们展示了如何检测空间肿瘤和间质群落，这些群落可用于表征不同细胞表型之间的高阶相互作用8。为了结合细胞表型信息检测空间组织结构，我们使用imcRtools软件包将细胞聚合成<code>细胞邻域（CNs）</code>5,10和<code>超级细胞（SCs）</code>19。作为检测空间组织结构的另一种有监督方式，我们重点介绍了一种补丁检测方法，该方法可用于分析预定细胞表型的空间聚集11。最后，为了评估某些类型的细胞表型在图像中的空间相互作用是否增加或减少，我们描述了使用基于置换的测试策略18。</p>\n<p>要使用此工作流程，需要掌握R编程语言的基础知识。这包括安装软件包、执行函数、理解函数参数以及如何访问函数文档的能力。此外，研究人员应能够在命令行上执行简单操作，如更改目录。</p>\n<p>综上所述，本方案强调了使用最近开发的工具以用户友好和可重复的方式执行端到端的多重图像分析，包括图像可视化和分割、数据质量控制以及单细胞和空间分析。</p>\n<h1 id=\"工作流的应用\"><a href=\"#工作流的应用\" class=\"headerlink\" title=\"工作流的应用\"></a>工作流的应用</h1><h2 id=\"工作流的先前应用\"><a href=\"#工作流的先前应用\" class=\"headerlink\" title=\"工作流的先前应用\"></a>工作流的先前应用</h2><p>之前，所提出的方法已被用于从多重成像数据中提取空间分辨的单细胞特征，以表征组织结构和其与疾病进展的关系8,9,11,15。该方法中描述的图像可视化策略已被用于显示子宫内膜异位症样本的复合图像31，以及在胰岛32和淋巴组织33的分割掩膜上绘制细胞表型和细胞表达的空间图。基于监督像素分类的图像分割方法已被应用于从多重成像数据中提取和分析空间分辨的单细胞数据，以绘制乳腺癌8,9,18,27、1型糖尿病15、COVID-19感染期间的肺和皮肤损伤13,14以及人肾组织空间结构34的特征图。steinbock工具包支持的通过应用预训练的深度学习模型进行图像分割的方法，之前已被用于研究药物筛选期间非小细胞肺癌球体中的标记表达35，以及表征转移性黑色素瘤中的趋化因子环境11。在本文方法中，我们还描述了一种细胞表型分析策略，即根据图像中细胞的标记表达进行手动标记，然后用于分类。该策略之前已被用于识别转移性黑色素瘤11和COVID-19患者皮肤样本14中的细胞表型。在方法的最后部分，我们提供了空间单细胞分析策略的指导。空间群落检测方法之前已被用于表征乳腺癌的空间结构及其与单细胞病理学组的关系8。细胞邻域（CN）和超级细胞（SC）检测已被用于了解结直肠癌样本内空间域的作用和组装10,19。本文描述的补丁检测方法已被用于识别趋化因子环境的细胞成分11。最后，用于识别细胞表型之间相互作用或避免作用的测试策略，之前已被用于表征乳腺癌8,18,27、转移性黑色素瘤11和胰腺组织15中的局部细胞表型相互作用。</p>\n<p>对于图像分割，我们描述了两种基于监督像素分类和预训练深度学习模型的替代方法。基于监督像素分类的分割方法通过调整CellProfiler管道提供了灵活性，并可以通过训练特定的Ilastik分类器15扩展到分割更大的组织结构，如胰岛。该管道之前已在多项研究中用于从多重图像中提取单细胞信息8,9,13–15,18,27。然而，最初开发的基于像素分类的分割管道需要自定义脚本、手动软件安装，并且仅通过使用随机森林的监督像素分类提供图像分割策略。为了促进多通道图像处理，我们因此开发了<code>steinbock</code>工具包，该工具包可实现数据提取、图像分割并且以用户友好的方式实现数据导出。它还通过使用启用深度学习的Mesmer分割算法，基于预训练的神经网络提供全自动细胞分割。steinbock工具包易于使用，旨在通过提供版本化和容器化的环境，确保在不同运行和平台之间的可重复性。</p>\n<h2 id=\"工作流的技术中立应用\"><a href=\"#工作流的技术中立应用\" class=\"headerlink\" title=\"工作流的技术中立应用\"></a>工作流的技术中立应用</h2><p>所提出的方法之前已被用于IMC（多标记质谱流式细胞术）生成的数据的端到端分析。然而，除了个别明确指示且专门为IMC定制的步骤外，所提供的工具还可应用于其他多重成像技术生成的数据。但是，一些迭代式多重成像技术需要额外的预处理步骤，如图像拼接和配准1,5，而这些步骤并未包含在所提出的工作流中。为了使本文描述的工具适用于给定的多重组织成像数据集，图像必须作为（拼接和共配准的）多通道TIFF文件提供。</p>\n<p>此外，如果使用了免疫荧光通道来检测细胞核和细胞膜36，则所描述的工具还可用于分析空间转录组数据，如seqFISH。对于此类数据，steinbock工具包可用于图像分割和单细胞数据提取，imcRtools包可执行空间数据分析，而cytomapper包则允许在分割掩膜上可视化细胞表型。</p>\n<h2 id=\"工作流的扩展\"><a href=\"#工作流的扩展\" class=\"headerlink\" title=\"工作流的扩展\"></a>工作流的扩展</h2><p>所提出的方法提供了执行多重成像数据基本分析所需的所有工具。然而，根据研究问题，可以使用额外的工具和软件包来扩展所提出的方法。对于查看多通道图像，<code>QuPath</code>26提供了灵活且用户友好的可视化选项，这些选项可在TIFF图像上操作。<code>steinbock</code>工具包允许以流式细胞术标准（FCS）文件的形式导出单细胞数据，以便与FCS Express或Cytobank一起使用。此外，由于可以将单细胞数据以anndata对象37的形式导出，因此可以通过Python中的单细胞和空间数据分析来扩展该方法。可以使用<code>slingshot</code>38进行轨迹分析，<code>spicyR</code>支持检测细胞类型共定位变化32，而<code>edgeR</code>17,39可用于执行差异丰度测试。有关单细胞分析方法的全面概述，请参阅《使用Bioconductor编排单细胞分析》一书，该书可在<a href=\"https://bioconductor.org/books/release/OSCA/%E4%B8%8A%E8%8E%B7%E5%8F%96%E3%80%82\">https://bioconductor.org/books/release/OSCA/上获取。</a></p>\n<h1 id=\"与其他方法的比较\"><a href=\"#与其他方法的比较\" class=\"headerlink\" title=\"与其他方法的比较\"></a>与其他方法的比较</h1><h2 id=\"图像查看器\"><a href=\"#图像查看器\" class=\"headerlink\" title=\"图像查看器\"></a>图像查看器</h2><p>为了交互式多通道图像可视化，之前已开发了包括<code>histoCAT</code>18、<code>CytoMap</code>40、<code>cytokit</code>41和<code>vitessce</code>42在内的多个图像查看器。然而，现有的图像查看器不支持读取存储在专有数据格式中的原始IMC数据所包含的全部信息。本文描述了使用<code>napari-imc</code>专门读取原始IMC数据，并将多重IMC采集叠加到全景图上，从而能够在组织上下文中检查图像。</p>\n<h2 id=\"图像分割方法\"><a href=\"#图像分割方法\" class=\"headerlink\" title=\"图像分割方法\"></a>图像分割方法</h2><p>对于图像分割，之前应用的两种基于像素分类和深度学习模型的方法已被纳入工作流。基于像素分类的分割方法依赖于使用<code>Ilastik</code>进行像素分类和使用<code>CellProfiler</code>进行细胞分割。该分割方法的简化版本已在<code>imcyto</code>管道43中实现。近年来，已开发了诸如<code>StarDist</code>44、<code>Cellpose</code>45和<code>Mesmer</code>23等启用深度学习的图像分割方法，以在多种组织类型和成像平台上实现人类水平的分割性能23。这些方法通常需要自定义脚本和特定的数据预处理步骤。我们已将启用深度学习的<code>Mesmer</code>分割算法纳入<code>steinbock</code>，因为它已针对通过多种多重成像技术获取的数据进行了专门训练。</p>\n<h2 id=\"单细胞与空间分析工具\"><a href=\"#单细胞与空间分析工具\" class=\"headerlink\" title=\"单细胞与空间分析工具\"></a>单细胞与空间分析工具</h2><p>单细胞与空间数据分析依赖于一系列交互式和程序化工具的支持。专为某些多重成像平台设计的图形用户界面（GUI）软件操作简便，可实现多通道图像和单细胞数据的联合可视化<sup>18,40,41,46</sup>。然而，这些工具往往与其他框架的互操作性较差，且难以扩展到其开发数据类型之外的其他用例。本文介绍了一些用户友好的计算工具，能够以简化的方式执行所有关键分析步骤，并确保与现有软件包（如Bioconductor项目中的软件包47）的互操作性。对于程序化的单细胞与空间数据分析，最近开发了<code>squidpy</code>软件包48用于在Python中分析数据，而<code>giotto</code>49则在R中进行类似的分析。这两个软件包都提供了大量用于空间分辨单细胞分析的功能，<code>steinbock</code>工具包则允许导出数据以便与<code>squidpy</code>结合使用。相比之下，Bioconductor项目47中的<code>imcRtools</code>和<code>cytomapper</code>软件包用于空间数据分析和图像可视化，因此能够与使用标准化数据类的众多单细胞数据分析方法相结合17,28。</p>\n<h2 id=\"分析流程\"><a href=\"#分析流程\" class=\"headerlink\" title=\"分析流程\"></a>分析流程</h2><p><code>CellProfiler</code>22、<code>Ilastik</code>21、<code>QuPATH</code>26和<code>cytokit</code>41等单个工具，以及包含<code>imcyto</code>43、<code>MIRIAM</code>50和<code>mplexable</code>51的工作流，可执行图像处理和分割。这些工具和工作流侧重于多重图像分析的特定处理步骤，通常与空间分辨单细胞分析等下游分析任务缺乏互操作性。最近，开发了一个名为<code>MCMICRO</code>的全面流程，用于从使用各种成像技术获取的多通道图像中提取和分析单细胞数据52。MCMICRO流程允许执行迭代染色方法通常所需的图像处理步骤，包括图像拼接和配准、图像分割和特征提取。对于单细胞和空间数据分析，该流程提供了使用<code>phenograph</code>53进行单细胞聚类和使用CN检测54的模块，并且可以通过开发新模块来扩展该流程。本文所述的方案提供了超越MCMICRO流程中模块的空间分辨单细胞分析策略。具体而言，在简化图像分割、特征提取并将数据读入R之后，本文重点介绍了常用的单细胞分析工具，以执行降维、单细胞可视化、批次校正和聚类以及基于分类的表型分析。此外，通过使用<code>SpatialExperiment</code>容器来存储空间分辨单细胞数据，该工作流可与许多当前和未来开发的用于空间和单细胞数据分析的Bioconductor软件包相结合。</p>\n<h1 id=\"数据生成的实验设计\"><a href=\"#数据生成的实验设计\" class=\"headerlink\" title=\"数据生成的实验设计\"></a>数据生成的实验设计</h1><p>在应用本文所述的方案分析多重成像技术生成的数据之前，研究人员必须仔细考虑要成像的样本数量、测量的感兴趣区域的数量和位置、样本质量以及抗体鸡尾酒的特异性和敏感性55。样本大小和感兴趣区域（ROI）大小主要受研究性质和材料可用性的影响。建议进行预实验，以估算最佳采集数量和大小，从而描绘出感兴趣的组织特征56,57。</p>\n<p>在最终数据采集之前，需要针对感兴趣的组织类型和包埋策略（即福尔马林固定石蜡包埋（FFPE）或最佳切割温度复合物（OCT））专门评估每种抗体的染色质量。为了评估技术差异，如染色效率随时间的变化或实验变化，建议与实验样本平行地对控制样本（如细胞系团块）进行染色和采集。这些控制细胞团块也应使用与主要样本相同的流程进行分析，以评估技术差异。</p>\n<p><font color=\"#FF0000\">本文所述的数据分析方案假设所有样本都是使用相同的抗体面板采集的。如果使用不同的面板，则应对每个子批次样本分别应用该方案。下文讨论了评估数据质量的几种方法，并提出了在分析步骤中纠正和&#x2F;或避免技术偏差的方法。</font></p>\n<h1 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h1><h2 id=\"多通道图像处理的内存和存储限制\"><a href=\"#多通道图像处理的内存和存储限制\" class=\"headerlink\" title=\"多通道图像处理的内存和存储限制\"></a>多通道图像处理的内存和存储限制</h2><p>基于像素分类的分割方法在处理大量图像时会遇到内存和运行时问题。首先，在Ilastik中加载和标记许多大文件会消耗大量内存并减慢像素标注的速度。我们通过裁剪图像来解决这个问题，并需要决定是加载较小的裁剪图像还是较少的图像到Ilastik中。此外，通过启用Ilastik中的“实时模式”来即时重新训练分类器也会消耗大量内存。这个问题可以通过关闭“实时模式”进行标注来解决。最后，所提供的CellProfiler流程会从图像中提取所有可用特征。对于大型数据集，这可能会导致生成存储单细胞特征的大型（多个千兆字节）CSV文件。因此，我们建&#96;议手动选择对下游分析感兴趣的特征。</p>\n<h2 id=\"与其他工具的兼容性\"><a href=\"#与其他工具的兼容性\" class=\"headerlink\" title=\"与其他工具的兼容性\"></a>与其他工具的兼容性</h2><p>steinbock工具包主要处理存储在未压缩TIFF文件中的图像，这需要足够的计算资源。在使用steinbock时，可以通过压缩原始数据进行长期存储并启用图形处理单元（GPU）支持图像分割来减轻与数据集和&#x2F;或图像大小相关的问题。通过批量处理图像瓦片而不是完整图像来支持大型全玻片图像（大小为数十GB）的处理。此外，steinbock尽可能访问磁盘上的TIFF文件，而不是将完整图像加载到内存中。在使用深度学习支持的Mesmer算法进行全自动图像分割时，底层预训练神经网络可能并非对所有数据集都能立即表现出色。steinbock工具包可使用–preprocess&#x2F;–postprocess命令行选项来微调算法参数（参见“故障排除”部分）。或者，也可以采用基于像素分类的监督图像分割方法，其中用于分割的像素分类器可以根据当前数据集进行定制（重新训练）。</p>\n<h2 id=\"R中的图像可视化\"><a href=\"#R中的图像可视化\" class=\"headerlink\" title=\"R中的图像可视化\"></a>R中的图像可视化</h2><p>cytomapper包目前支持以HDF5格式在磁盘上存储图像，这有助于处理大型图像。然而，在R的原生图形设备中一次性显示大型全玻片图像计算成本高昂，我们建议先对图像进行分块，然后并排可视化单个图像块。</p>\n<h2 id=\"选择正确的聚类数量\"><a href=\"#选择正确的聚类数量\" class=\"headerlink\" title=\"选择正确的聚类数量\"></a>选择正确的聚类数量</h2><p>我们在两种情况下描述了聚类方法：首先，是识别细胞表型（第28步），其次，是检测拷贝数（CN）（第32步）。在这两种情况下，选择聚类方法和聚类数量都不简单，需要测试不同的参数，直到忠实地概括所研究系统的先前生物学知识或估计聚类稳定性（例如，一些聚类在不同的参数设置下不会发生变化）。我们在第28步中讨论了合适的参数扫描。然而，为了检测CN，如果可能的话，最好对要检测的组织结构有预先的预期，并相应地调整聚类参数。对于无监督的CN检测，可以测试多种聚类参数设置和方法来估计结果的稳健性。</p>\n<h2 id=\"随着细胞数量增加的可扩展性\"><a href=\"#随着细胞数量增加的可扩展性\" class=\"headerlink\" title=\"随着细胞数量增加的可扩展性\"></a>随着细胞数量增加的可扩展性</h2><p>本协议中介绍的大多数函数在分析空间解析的单细胞数据时都可以处理数百万个细胞。然而，在进行非线性降维、聚类（除k均值聚类外）、图像块检测（当扩展许多图像块时）和细胞表型相互作用测试时，可能会出现内存和运行时问题。这些问题可以通过imcRtools中实现的函数来缓解，这些函数易于并行化或使用近似方法来检测最近邻。对于相互作用测试函数，当同时分析数百万个细胞时，可能会出现内存问题。作为一种解决方法，可以按图像子集处理数据集，因为统计信息是按图像计算的。</p>\n<h1 id=\"材料\"><a href=\"#材料\" class=\"headerlink\" title=\"材料\"></a>材料</h1><h2 id=\"设备\"><a href=\"#设备\" class=\"headerlink\" title=\"设备\"></a>设备</h2><h3 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h3><p>• 要运行该工作流程，需要一台装有最新版本的Windows、Mac或Linux操作系统（OS）的电脑。随着数据集大小的增加，所需的内存也会增加，我们建议使用至少8GB的随机存取存储器（RAM）来分析所提供的数据集（14600×600像素的图像，40个通道，47859个细胞）。对于更大的数据集（数百万个细胞），我们建议使用至少64GB的RAM。或者，如果可以安装Docker（见“设备安装”部分），则可以使用高性能电脑。对于本手稿，工作流程是在MacOS Big Sur（11.7.4）、2.7 GHz四核Intel Core i7、16 GB 2133 MHz LPDDR3上运行的。</p>\n<h3 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件\"></a>软件</h3><p>• napari &amp; napari-imc（针对IMC）：使用多维图像查看器napari（<a href=\"https://napari.org)以及用于加载imc文件的napari-imc插件(https//github.com/BodenmillerGroup/napari-imc%EF%BC%89%E6%9D%A5%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E6%A3%80%E6%9F%A5%E5%8E%9F%E5%A7%8B%E7%9A%84%E5%A4%9A%E9%87%8D%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E3%80%82%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84conda%EF%BC%88https://conda.io%EF%BC%89%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AE%89%E8%A3%85%E4%BA%86Python\">https://napari.org）以及用于加载IMC文件的napari-imc插件（https://github.com/BodenmillerGroup/napari-imc）来可视化和检查原始的多重成像数据。我们在一个新的conda（https://conda.io）环境中安装了Python</a> 3.9.12（<a href=\"https://www.python.org)、napari/\">https://www.python.org）、napari</a> 0.4.16和napari-imc 0.6.5；安装说明见下文。</p>\n<p>• 基于深度学习的分割：使用多通道图像处理工具包steinbock（<a href=\"https://bodenmillergroup.github.io/steinbock%EF%BC%89%E5%AF%B9%E5%A4%9A%E9%87%8D%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E5%B9%B6%E6%8F%90%E5%8F%96%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE%E3%80%82%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8Docker\">https://bodenmillergroup.github.io/steinbock）对多重成像数据进行预处理，执行图像分割并提取单细胞数据。我们使用Docker</a> Desktop 4.9.0 for Mac从GitHub容器注册表中拉取了steinbock Docker容器v0.16.0；安装说明见“设备安装”部分。</p>\n<p>• 基于像素分类的分割：使用基于随机森林的像素分类和基于分水岭的细胞分割方法进行多通道图像处理，使用的是基于Ilastik&#x2F;CellProfiler的分割管道v3.6（<a href=\"https://bodenmillergroup.github.io/ImcSegmentationPipeline/%EF%BC%89%EF%BC%9B%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E8%A7%81%E2%80%9C%E8%AE%BE%E5%A4%87%E5%AE%89%E8%A3%85%E2%80%9D%E9%83%A8%E5%88%86%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AF%A5%E7%AE%A1%E9%81%93%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%E4%BB%A5%E4%B8%8B%E8%BD%AF%E4%BB%B6%EF%BC%9A\">https://bodenmillergroup.github.io/ImcSegmentationPipeline/）；安装说明见“设备安装”部分。此外，要使用该管道，还需要安装以下软件：</a></p>\n<p>  – Ilastik：在细胞分割之前用于像素分类的Ilastik软件21，可从<a href=\"https://www.ilastik.org/download.html%E5%AE%89%E8%A3%85%E3%80%82%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AFv1.4.0%E3%80%82\">https://www.ilastik.org/download.html安装。本工作流程使用的版本是v1.4.0。</a></p>\n<p>  – CellProfiler：用于分割单个细胞的CellProfiler软件22，可在Windows（64位）和MacOS（10.14+）上从<a href=\"https://cellprofiler.org/previous-releases%E5%AE%89%E8%A3%85%E3%80%82%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AFv4.2.1%E3%80%82\">https://cellprofiler.org/previous-releases安装。本工作流程使用的版本是v4.2.1。</a></p>\n<p>• R设置：图像处理后的下游分析使用的是统计编程语言R，可从<a href=\"https://cran.r-project.org/%E6%8C%89%E7%85%A7%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%B4%E6%98%8E%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AFv4.3.0%E3%80%82\">https://cran.r-project.org/按照特定操作系统的说明进行安装。本工作流程使用的版本是v4.3.0。</a></p>\n<p>RStudio软件为R中的数据分析提供了一个易于使用的图形用户界面（GUI）。它可以从<a href=\"https://www.rstudio.com/products/rstudio/download/%E5%AE%89%E8%A3%85%E3%80%82%E4%B8%BA%E4%BA%86%E6%89%A7%E8%A1%8C%E6%89%80%E5%B1%95%E7%A4%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BA%86RStudio\">https://www.rstudio.com/products/rstudio/download/安装。为了执行所展示的工作流程，我们使用了RStudio</a> Server版本2023.03.0。</p>\n<p>以下是本工作流程中使用的主要R库的版本。此外，补充说明1列出了工作流程中使用的所有R库的软件版本。</p>\n<p>SpatialExperiment版本1.10.0（参考文献28）<br>SingleCellExperiment 1.22.0（参考文献17）<br>CATALYST版本1.24.0（参考文献24）<br>imcRtools版本1.6.0<br>scuttle版本1.10.0（参考文献58）<br>scater版本1.28.0（参考文献58）<br>batchelor版本1.16.0（参考文献30）<br>bluster版本1.10.0<br>scran版本1.28.0（参考文献59）<br>caret版本6.0-94<br>Cytomapper 版本 1.12.0<br>DittoSeq 版本 1.12.0（参考文献29）<br>Tidyverse 版本 2.0</p>\n<h2 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h2><p>IMC 示例数据：我们提供了一个小型IMC数据集作为示例，以展示多通道图像处理和空间分辨单细胞数据分析。这些数据是使用Hyperion成像系统（Standard BioTools）在大型适应性癌症患者队列的综合免疫分析（IMMUcan）项目中生成的。数据可访问于<a href=\"https://zenodo.org/record/7575859%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E6%96%87%E4%BB%B6%EF%BC%9A\">https://zenodo.org/record/7575859，包含以下文件：</a></p>\n<ul>\n<li><p>Patient1.zip, Patient2.zip, Patient3.zip, Patient4.zip：四个患者样本的原始IMC数据。每个ZIP归档包含一个文件夹，其中包含一个MCD文件（所有采集的数据和元数据）和多个TXT文件（每个采集一个文件，无元数据）。</p>\n</li>\n<li><p>compensation.zip：此ZIP归档包含一个文件夹，其中包含一个MCD文件和多个TXT文件。采集了“溢出载玻片”的多个点，每个TXT文件根据点样金属命名。这些数据用于通道溢出校正（步骤14–21）。</p>\n</li>\n<li><p>sample_metadata.csv：此文件将每个患者与其癌症类型相关联（SCCHN，头颈癌；BCC，乳腺癌；NSCLC，肺癌；CRC，结直肠癌）。</p>\n</li>\n<li><p>我们还提供了steinbock格式的panel.csv文件，其中包含实验中使用的每个抗体或通道的元数据。在此文件中，“channel”列指示用于标记每个抗体的金属同位素。“name”列包含每个抗体的蛋白质靶点。“keep”列指示哪些通道是从原始数据中提取的，因此在下游分析中保留。重要的是，“keep”列设置为1的行的顺序与提取的多通道图像中通道的顺序相匹配。最后，“deepcell”列指示在使用DeepCell&#x2F;Mesmer进行自动图像分割时使用了哪些通道（即聚合）：核通道设置为1，细胞质通道设置为2，其他&#x2F;未使用的通道留空。该文件可访问于<a href=\"https://zenodo.org/record/7624451%E3%80%82\">https://zenodo.org/record/7624451。</a></p>\n</li>\n<li><p>此外，我们还提供了包含先前筛选细胞的SpatialExperiment对象。这些细胞构成了基于分类的表型分析中的真实细胞表型标签（步骤28）。数据可访问于<a href=\"https://zenodo.org/record/7647079%E3%80%82\">https://zenodo.org/record/7647079。</a></p>\n</li>\n</ul>\n<h2 id=\"设备设置\"><a href=\"#设备设置\" class=\"headerlink\" title=\"设备设置\"></a>设备设置</h2><h3 id=\"安装说明\"><a href=\"#安装说明\" class=\"headerlink\" title=\"安装说明\"></a>安装说明</h3><p>除非另有说明，否则本节中的命令必须在命令行上执行（Windows上的“命令提示符”或“Anaconda提示符”，Linux&#x2F;Mac OS上的“终端”）。</p>\n<ul>\n<li>napari 和 napari-imc：</li>\n</ul>\n<ol>\n<li><p>根据<a href=\"https://docs.conda.io/projects/conda/en/latest/user-guide/install/%E4%B8%8A%E7%9A%84%E8%AF%B4%E6%98%8E%E5%AE%89%E8%A3%85conda%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E3%80%82\">https://docs.conda.io/projects/conda/en/latest/user-guide/install/上的说明安装conda包管理器。</a></p>\n</li>\n<li><p>创建一个新的conda环境，包含Python 3.9：</p>\n</li>\n</ol>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n napari-imc -y python=<span class=\"number\">3.9</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>激活conda环境并安装napari和napari-imc：</li>\n</ol>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate napari-imc</span><br><span class=\"line\"></span><br><span class=\"line\">pip install <span class=\"string\">&quot;napari[all]==0.4.16&quot;</span> napari-imc==<span class=\"number\">0.6</span><span class=\"number\">.5</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>基于深度学习的分割：有关安装容器化steinbock工具包的说明，可在steinbock在线文档中找到（<a href=\"https://bodenmillergroup.github.io/steinbock/%EF%BC%89%E3%80%82%E7%89%B9%E5%88%AB%E6%98%AF%EF%BC%8C%E8%A6%81%E8%BF%90%E8%A1%8Csteinbock%E5%AE%B9%E5%99%A8%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%89%E8%A3%85Docker%EF%BC%88%E8%AF%B7%E5%8F%82%E9%98%85%E5%9C%A8%E7%BA%BF%E8%AF%B4%E6%98%8E%EF%BC%89%E3%80%82%E5%AF%B9%E4%BA%8E%E6%9C%AC%E6%89%8B%E7%A8%BF%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E5%88%AB%E5%90%8D%E8%BF%90%E8%A1%8Csteinbock%EF%BC%9A\">https://bodenmillergroup.github.io/steinbock/）。特别是，要运行steinbock容器，需要先安装Docker（请参阅在线说明）。对于本手稿，我们使用以下别名运行steinbock：</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> steinbock=<span class=\"string\">&quot;docker run -v /path/to/data/steinbock:/data -u (id−u):(id -g) ghcr.io/bodenmillergroup/steinbock:0.16.0&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>▲ 关键说明：在上述命令中，需要将&#x2F;path&#x2F;to&#x2F;data&#x2F;steinbock替换为预期的steinbock数据&#x2F;工作目录。</p>\n<ul>\n<li>基于像素分类的分割：基于像素分类的分割流程的预处理步骤是使用自定义脚本在Python中执行的。要设置预处理脚本，需要执行以下步骤：</li>\n</ul>\n<ol>\n<li>根据<a href=\"https://docs.conda.io/projects/conda/en/latest/user-guide/install/%E4%B8%8A%E7%9A%84%E8%AF%B4%E6%98%8E%E5%AE%89%E8%A3%85conda%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E3%80%82\">https://docs.conda.io/projects/conda/en/latest/user-guide/install/上的说明安装conda包管理器。</a></li>\n<li>克隆代码仓库</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/BodenmillerGroup/ImcSegmentationPipeline.git</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建imcsegpipe的conda环境：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ImcSegmentationPipeline</span><br><span class=\"line\">conda <span class=\"built_in\">env</span> create -f environment.yml</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>通过打开CellProfler的图形用户界面（GUI），选择Preferences并将CellProfler插件目录设置为path&#x2F;to&#x2F;ImcSegmentationPipeline&#x2F;resources&#x2F;ImcPluginsCP&#x2F;plugins，来配置CellProfler以使用所需的插件，然后重启CellProfler。</li>\n</ol>\n<p>▲ 关键说明：将此路径调整为下载的CellProfler插件所在的位置。按照上述方式克隆仓库时，插件位于resources&#x2F;ImcPluginsCP&#x2F;plugins中。</p>\n<ul>\n<li><p>R库：该工作流程强调了使用cytomapper、imcRtools和其他R包。以下R命令会安装所有相关的R包：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"punctuation\">(</span><span class=\"operator\">!</span>requireNamespace<span class=\"punctuation\">(</span><span class=\"string\">&quot;BiocManager&quot;</span><span class=\"punctuation\">,</span> quietly <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"> install.packages<span class=\"punctuation\">(</span><span class=\"string\">&quot;BiocManager&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">BiocManager<span class=\"operator\">::</span>install<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;pheatmap&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;viridis&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tiff&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;distill&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ggrepel&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;patchwork&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;mclust&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;RColorBrewer&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;uwot&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Rtsne&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;caret&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;randomForest&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ggridges&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;gridGraphics&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scales&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;CATALYST&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scuttle&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scater&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;dittoSeq&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tidyverse&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;batchelor&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;bluster&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;scran&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;cytomapper&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;imcRtools&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>可以从GitHub或Bioconductor直接安装R包的开发版本，同时指定开发版本。开发版本通常包含发行版中尚未提供的功能；然而，对于使用描述的工作流程，无需从开发源安装R包。<br>为确保工作流程的可重复性，我们还提供了一个Docker容器，该容器打包了所有相关的R库。以下命令行调用可获取Docker镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull ghcr.io/bodenmillergroup/imcdataanalysis:2023-05-01</span><br></pre></td></tr></table></figure>\n\n<p>使用Docker容器重现分析的说明可在<a href=\"https://github.com/BodenmillerGroup/IMCDataAnalysis/tree/main/publication%E4%B8%8A%E6%9F%A5%E7%9C%8B%E3%80%82%E6%AD%A4%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E5%88%86%E6%9E%90%E6%98%AF%E5%9C%A8Docker%E5%AE%B9%E5%99%A8%E5%86%85%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9B%E4%BD%86%E6%98%AF%EF%BC%8CR%E5%8C%85%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E4%B8%8A%E8%BF%B0%E8%AF%B4%E6%98%8E%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E3%80%82\">https://github.com/BodenmillerGroup/IMCDataAnalysis/tree/main/publication上查看。此工作流程中显示的分析是在Docker容器内执行的；但是，R包也可以按照上述说明手动安装。</a></p>\n<h2 id=\"数据下载\"><a href=\"#数据下载\" class=\"headerlink\" title=\"数据下载\"></a>数据下载</h2><p>在R语言中，可以按照以下步骤下载IMC示例数据和门控细胞：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">options<span class=\"punctuation\">(</span>timeout <span class=\"operator\">=</span> <span class=\"number\">10000</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 设置超时时间为10000秒</span></span><br><span class=\"line\">dir.create<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/raw&quot;</span><span class=\"punctuation\">,</span> recursive <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 创建数据存放目录，若上级目录不存在则一并创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载面板文件</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7624451/files/panel.csv&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/panel.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载患者数据</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient1.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient1.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient2.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient2.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient3.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient3.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient4.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient4.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载补偿文件并解压</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/compensation.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/compensation.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">unzip<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/compensation.zip&quot;</span><span class=\"punctuation\">,</span> exdir<span class=\"operator\">=</span><span class=\"string\">&quot;data&quot;</span><span class=\"punctuation\">,</span> overwrite<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 解压到data目录，若文件已存在则覆盖</span></span><br><span class=\"line\">unlink<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/compensation.zip&quot;</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 删除压缩包文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载样本元数据文件</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/sample_metadata.csv&quot;</span><span class=\"punctuation\">,</span> destfile <span class=\"operator\">=</span> <span class=\"string\">&quot;data/sample_metadata.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载门控细胞数据并解压</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7647079/files/gated_cells.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/gated_cells.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">unzip<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/gated_cells.zip&quot;</span><span class=\"punctuation\">,</span> exdir<span class=\"operator\">=</span><span class=\"string\">&quot;data&quot;</span><span class=\"punctuation\">,</span> overwrite<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 解压到data目录，若文件已存在则覆盖</span></span><br><span class=\"line\">unlink<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/gated_cells.zip&quot;</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 删除压缩包文件</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键说明：下载的数据和相关的面板文件用于steinbock。若要下载用于基于像素分类的分割流程的示例数据，请遵循步骤6B(iii)。</p>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><h2 id=\"原始成像数据检查（IMC专用）\"><a href=\"#原始成像数据检查（IMC专用）\" class=\"headerlink\" title=\"原始成像数据检查（IMC专用）\"></a>原始成像数据检查（IMC专用）</h2><p>● 耗时：20–40分钟</p>\n<p>除非另有说明，否则本节中的命令必须在命令行中执行（在Windows上为“命令提示符”或“Anaconda提示符”，在Linux&#x2F;Mac OS上为“终端”）。</p>\n<ol>\n<li>激活之前创建的napari-imc conda环境并启动napari：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate napari-imc</span><br><span class=\"line\">napari</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在napari中，使用“文件”→“打开文件(s)”打开包含原始IMC数据的MCD文件。打开文件后，将出现napari-imc小部件（图3，右侧）。</p>\n</li>\n<li><p>在MCD文件树（napari-imc小部件，顶部）中，选择要在napari主面板中以叠加方式可视化的全景图和&#x2F;或采集数据。</p>\n</li>\n<li><p>对于上一步中选择的采集数据，选择要可视化的通道（napari-imc小部件，中部），并调整通道属性，如颜色和对比度（napari-imc小部件，底部）。</p>\n</li>\n<li><p>使用napari中的平移&#x2F;缩放功能对合成图像进行定性检查。</p>\n</li>\n</ol>\n<h2 id=\"多重组织图像处理\"><a href=\"#多重组织图像处理\" class=\"headerlink\" title=\"多重组织图像处理\"></a>多重组织图像处理</h2><p>除非另有说明，否则本节中的命令必须在命令行中执行（在Windows上为“命令提示符”或“Anaconda提示符”，在Linux&#x2F;Mac OS上为“终端”）。</p>\n<p>多重组织图像处理通常包括图像提取和预处理、图像分割以及单细胞数据提取等步骤。在此，我们提出了两种用于分割多重组织成像数据的替代工作流程：</p>\n<p>（A）基于steinbock的深度学习工作流程，steinbock是我们用于多重组织图像处理的容器化工具包（图4，DeepCell变体）。该工作流程可通过命令行界面进行，并利用DeepCell包中实现的深度学习Mesmer算法，基于预训练神经网络以全自动方式分割细胞。所有steinbock命令的输入和输出文件及目录均可通过命令行选项进行控制。若未明确指定这些选项，steinbock命令行界面将预期以下数据&#x2F;工作目录结构：<br>steinbock数据&#x2F;工作目录<br>├── raw（用户提供，从原始数据开始）<br>├── panel.csv（用户提供或从原始数据生成，步骤6(A)）<br>├── img（用户提供，从TIFF文件开始，或从原始数据提取，步骤6(A)）<br>├── masks（步骤7(A)生成，细胞分割掩码）<br>├── intensities（步骤8(A)生成，平均细胞像素强度）<br>├── regionprops（步骤8(A)生成，形态细胞特征）<br>├── neighbors（步骤8(A)生成，空间细胞邻域列表）</p>\n<p>（B）使用Jupyter笔记本和CellProfiler管道简化的基于像素分类的工作流程（图5）。在此工作流程中，首先使用Ilastik软件手动训练一个针对当前数据集定制的随机森林像素分类器。然后，使用CellProfiler管道基于像素分类来分割单个细胞。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig3.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig3.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3 | napari和napari-imc的截图。可视化存储在Patient4.mcd文件中的原始IMC数据（采集6、8叠加在全景图9、10、11上）。展示的是CD163（黄色）、CD20（红色）、CD3（绿色）、E-钙黏蛋白（青色）和DNA（蓝色）。对比度限制已手动调整以便目视检查。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig4.png\" alt=\"图4 | 使用steinbock的典型多重图像处理工作流程。\n各个步骤用箭头表示，下方列出了相应的steinbock命令（命令行界面）和Python模块（编程使用）。进一步的参数和第三方软件（包含在steinbock Docker容器中）已叠加在箭头上。输入和输出数据以概念方式表示。图示步骤包括从平台特定的原始数据中提取图像的预处理步骤、（基于分类的）分割步骤以获得细胞掩膜（展示了两种替代工作流程）、测量步骤以提取细胞水平特征，并导出为与各种下游分析环境（例如Python、R、CytoScape76、histoCAT18）兼容的文件格式，以表示空间单细胞数据。\"></p>\n<p>基于像素分类的分割管道的文件夹结构如下所示。该管道期望将原始IMC数据放置在“raw”文件夹中，或将OME–TIFF数据放置在“ometiff”文件夹中。</p>\n<p>基于Ilastik&#x2F;CellProfiler的分割管道数据&#x2F;工作目录<br>├── raw（用户提供，当从原始数据开始时）<br>├── analysis<br> ├── cpin<br> ├── ometiff（用户提供，当从OME-TIFF开始时，或在步骤6(B)中从原始数据生成）<br> ├── cpout（在步骤6-8(B)中生成；最终输出文件）<br> ├── histocat（在步骤6(B)中生成；用于histoCAT导入的文件）<br> ├── crops（在步骤7(B)中生成；Ilastik裁剪图像）<br> ├── ilastik（在步骤6-7(B)中生成；与Ilastik相关的文件）<br>├── scripts（原始数据处理脚本）<br>├── resources（CellProfiler管道和插件）</p>\n<p>▲ 重要提示：steinbock工具包（图4）也支持此处所示的基于像素分类的分割方法（图5）。为简洁起见，在本方案中，仅展示了steinbock的深度学习工作流程；如需更多信息，请参阅steinbock的在线文档。</p>\n<p>这两个工作流程都接受用户提供的多通道图像作为输入，这些图像可以是TIFF文件（steinbock；需放置在“img”文件夹中），也可以是OME–TIFF格式（基于像素分类的分割管道；需放置在“analysis&#x2F;ometiff”文件夹中）。另外，也可以直接将原始IMC数据提供给这两个工作流程（需放置在“raw”文件夹中，适用于两个工作流程），并使用我们自主研发的readimc Python包（框1）将其自动转换为相应的文件格式。此外，这两种工作流程都需要一个CSV格式的面板文件，用于指定实验中使用的抗体以及在后续处理中应保留的任何额外通道（例如，用于复染的金属61）。这些面板文件可以自动从原始数据中生成（steinbock），也可以由用户手动指定（steinbock和基于像素分类的工作流程）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig5.png\" alt=\"图5 | 基于像素分类的分割管道概述。\n数据预处理步骤包括将原始MCD文件转换为OME–TIFF和TIFF文件。图像分割通过以下步骤完成：（i）裁剪图像，（ii）训练Ilastik分类器并提取像素概率，以及（iii）对像素概率进行细胞分割，从而生成分割掩膜。通过结合多通道图像（完整堆栈）和分割掩膜来执行单细胞数据提取。所得单细胞数据可以使用imcRtools包进行读取和分析，而多通道图像和分割掩膜可以使用cytomapper包进行可视化。BiocStickers图案根据Creative Commons CC0 1.0许可证从https://github.com/Bioconductor/BiocStickers重新印制。\"></p>\n<hr>\n<p>框1<br>原始IMC数据</p>\n<p>Hyperion成像系统生成专有MCD&#x2F;TXT格式的文件，这些文件存储在以下文件夹结构中：<br>├── {XYZ}_ROI_001_1.txt<br>├── {XYZ}_ROI_002_2.txt<br>├── {XYZ}_ROI_003_3.txt<br>├── {XYZ}.mcd</p>\n<p>在这里，{XYZ}定义了文件名，ROI_001、ROI_002、ROI_003是用户为所选ROI定义的名称（描述），而1、2、3表示唯一的采集标识符。在选择ROI时，可以在Standard BioTools软件中指定ROI描述条目。MCD文件包含所有采集到的ROI的原始成像数据和完整元数据，而每个TXT文件则包含单个ROI的数据（不包含元数据）。为了遵循一致的命名方案并捆绑所有元数据，我们建议将文件夹压缩为ZIP文件。每个ZIP文件应仅包含一个MCD文件及其对应的TXT文件，并且ZIP文件的名称应与MCD文件的名称相匹配。</p>\n<hr>\n<h2 id=\"数据预处理（特定于技术）\"><a href=\"#数据预处理（特定于技术）\" class=\"headerlink\" title=\"数据预处理（特定于技术）\"></a>数据预处理（特定于技术）</h2><p>● 选项A耗时5分钟，选项B耗时10–20分钟</p>\n<p>在本方案中，数据预处理是指从原始成像数据中提取多通道图像，并为后续处理做准备。所需步骤取决于成像技术；在此，我们展示了原始IMC数据的预处理，其中包括热点像素过滤步骤（框2）。在图像分割之前，可以进行额外的模态特异性预处理步骤，如IMC去噪62或通道间溢出校正（步骤14–21），以促进后续的图像分析步骤。以前，对于IMC数据，热点像素过滤就足以进行有效的分割。</p>\n<p>对于除IMC之外的多重组织成像模态，可以使用steinbock的预处理外部命令将外部预处理过的二维多通道图像转换为steinbock兼容的TIFF文件。例如，迭代多重组织成像方法的外部预处理通常包括诸如拼接和注册对应于单个成像周期的图像等任务63。有关更多详细信息，请参阅steinbock的在线文档。</p>\n<ol start=\"6\">\n<li><p>预处理多通道图像。<br>  （A）基于深度学习的工作流程<br> （i）在steinbock面板文件格式（表1；请参阅steinbock的在线文档）中手动创建一个panel.csv文件，并将其放置在steinbock的数据&#x2F;工作目录中。本方案中使用的完整steinbock面板文件可从<a href=\"https://zenodo.org/record/7624451%E4%B8%8B%E8%BD%BD%E3%80%82\">https://zenodo.org/record/7624451下载。</a></p>\n<p> ▲ 关键信息：在使用steinbock处理自定义IMC数据集时，可以使用steinbock的预处理imc面板命令（请参阅steinbock的在线文档），从放置在原始数据目录中的MCD&#x2F;TXT文件中自动生成模板面板文件。此命令将自动填充“通道”和“名称”列，并可作为创建有效面板文件的起点。<br> （ii）从MCD&#x2F;TXT文件中提取单个IMC采集，仅保留面板文件中“保留”列设置为1的通道。使用50的阈值过滤热点像素，并将生成的图像存储为TIFF文件。提取图像中通道的顺序由面板文件中通道的顺序（“通道”列）决定。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock preprocess imc images --hpf 50</span><br></pre></td></tr></table></figure>\n<p> ◆ 故障排除</p>\n</li>\n</ol>\n<p>  （B）基于像素分类的工作流程</p>\n<pre><code>（i）创建一个包含列条目“金属标签”、“full”和“ilastik”的面板文件（表2）。一个可用于所提供数据的示例面板文件可在https://zenodo.org/record/7575859上访问。\n\n（ii）在ImcSegmentationPipeline文件夹内，激活之前创建的imc-segpipe conda环境（参见“安装说明”），并启动jupyter-lab：\n\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate imcsegpipe</span><br><span class=\"line\">jupyter lab</span><br></pre></td></tr></table></figure>\n\n（iii）按照位于“scripts/imc_preprocessing.ipynb”的脚本执行以下预处理任务：\n\n    • 根据“scripts/download_examples.ipynb”脚本下载示例数据\n    • 将文件类型从MCD转换为OME–TIFF\n    • （可选）将OME–TIFF文件转换为单通道TIFF文件，以便在histoCAT18中使用\n    • 将OME–TIFF文件转换为热点像素过滤后的多通道TIFF堆栈，用于（1）图像分析（包含在“full”列中的通道）和（2）ilastik像素分类（指定在“ilastik”列中的通道）\n    \n</code></pre>\n<hr>\n<p>框2<br>热点像素过滤<br>热点像素过滤的工作原理是将每个像素与其八邻域（即切比雪夫距离为1的相邻像素）进行比较。如果某个像素与其八个相邻像素中的最大值之间的差异超过热点像素过滤阈值，则将该像素设置为最大相邻像素值（“热点像素过滤后”）。在这里，使用的热点像素过滤阈值为50；但是，该阈值可以根据具体的数据集进行调整。</p>\n<hr>\n<p><strong>表1 | steinbock面板文件格式中的示例面板文件（摘录）</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table1.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table1.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\"></p>\n<p>每一行对应于多重成像数据中的一个通道。在IMC（多重同位素标记质量细胞成像）数据中，“通道”列指示用于标记每种抗体的独特金属同位素，该列用于将面板文件和原始数据相关联。“名称”列包含唯一、用户定义的通道名称（例如，每种抗体的蛋白质靶点），这些名称将在派生的单细胞数据和下游分析中使用。“保留”列指示应从原始数据中提取并因此保留以供下游分析哪些通道。重要的是，保留列设置为1的行的顺序将与提取的多通道图像中通道的顺序相匹配。最后，“deepcell”列指示应使用（即聚合）哪些通道，以便使用DeepCell&#x2F;Mesmer进行全自动图像分割（核通道标记为1，细胞质通道标记为2，其他&#x2F;未使用的通道该列留空）。本方案中使用的完整steinbock面板文件已从“数据下载”部分的<a href=\"https://zenodo.org/record/7624451%E4%B8%8B%E8%BD%BD%E3%80%82\">https://zenodo.org/record/7624451下载。</a></p>\n<p><strong>表2 | 基于像素分类的工作流的面板规范</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table2.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table2.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\"></p>\n<p>“金属标签”列存储每个采集通道的金属同位素。“全部”和“ilastik”列设置为0或1。“全部”列中的1指定应写入图像堆栈的通道，该图像堆栈稍后将用于提取特征（也称为“全部堆栈”）。“ilastik”列中的1表示将用于Ilastik像素分类的通道，因此将用于图像分割（也称为“ilastik堆栈”）。</p>\n<h2 id=\"图像分割\"><a href=\"#图像分割\" class=\"headerlink\" title=\"图像分割\"></a>图像分割</h2><p>● 选项A耗时10–20分钟，选项B耗时2–3小时</p>\n<ol start=\"7\">\n<li>执行图像分割以检测单个细胞，生成并存储为TIFF文件的细胞掩膜。细胞掩膜是与相应输入图像大小相同的单通道灰度图像，其中对应于同一细胞的像素显示相同的灰度值（背景像素的像素值为0）。</li>\n</ol>\n<p>  （A）基于深度学习的工作流<br>    （i）使用DeepCell软件包中实现的启用深度学习的Mesmer算法，基于预训练神经网络执行全自动细胞分割。在以下命令中，将根据面板文件中的“deepcell”列对通道进行最小-最大归一化和均值聚合。</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock segment deepcell --minmax</span><br></pre></td></tr></table></figure>\n\n◆ 故障排除\n</code></pre>\n<p>  （B）基于像素分类的工作流<br>    （i）为Ilastik像素分类准备图像。</p>\n<pre><code>第一步，使用CellProfiler中的“resources/pipelines/1_prepare_ilastik.cppipe”管道为像素标记和分类准备图像。在CellProfiler中导入管道后，首先执行以下步骤：\n\n• 将“analysis/ilastik”文件夹拖放到“Images”下的窗口中\n\n• 在“输出设置”中，将“analysis/crops”文件夹设置为“默认输出文件夹”\n\n管道将读取“analysis/ilastik”文件夹中所有包含“_ilastik”后缀的多通道图像。以下步骤是管道的一部分：\n\n• 计算所有通道的平均强度，乘以100以匹配实际标记的范围，并将其作为第一通道添加到ilastik堆栈中\n\n• ilastik堆栈的像素按两倍比例放大。这将使图像中的像素数量增加四倍，并便于像素标记\n\n▲ 关键提示：为便于视觉像素标记，在使用如IMC等分辨率较低的复用成像技术时，我们建议放大像素。对于基于荧光的技术，可以跳过此步骤。\n\n• 将ilastik堆栈裁剪成较小的视野。默认情况下，这些是500×500像素的裁剪图像；对于大型数据集，较小的图像裁剪即可满足需求\n\n• 将放大的ilastik堆栈以HDF5格式（文件名以_s2.h5结尾）保存到“analysis/ilastik”文件夹中，并将裁剪后的图像保存到“analysis/crops”文件夹中\n</code></pre>\n<p>  （ii）训练和应用Ilastik像素分类器。可以在<a href=\"https://zenodo.org/record/7997296%E4%B8%8A%E8%AE%BF%E9%97%AE%E5%9C%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E4%B8%8A%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84Ilastik%E5%83%8F%E7%B4%A0%E5%88%86%E7%B1%BB%E5%99%A8%E3%80%82\">https://zenodo.org/record/7997296上访问在提供的示例数据上预训练的Ilastik像素分类器。</a></p>\n<p>  打开Ilastik并按照以下步骤操作：</p>\n<p>  • 创建一个新的“Pixel Classification”（像素分类）项目</p>\n<p>  • 在“Input Data”（输入数据）下，点击“Add New…”（添加新…）&gt;“Add separate Image(s)”（添加单独的图像），并选择“analysis&#x2F;crops”文件夹中的所有.h5文件</p>\n<p>  • 特征选择：我们一般建议选择与σ ≥ 1的所有特征</p>\n<p>  • 通过基于三类（标签1为“细胞核”，标签2为“细胞质”，标签3为“背景”）标记像素来训练Ilastik分类器。使用“Live Update”（实时更新）视图观察三类的预测结果。通过点击“Uncertainty”（不确定性）旁边的眼睛符号来观察不确定性，这将显示分类不确定性最高的区域。这些区域需要重新标记</p>\n<p>  ▲ 关键提示：为了在分割过程中分离单个细胞，建议在两个靠得很近的细胞核之间绘制一条“细胞质线”，并用“细胞质”圈住细胞核。不应标记图像的大片区域，而应跨不同细胞和组织区域相对稀疏地放置像素标签。当在细胞核&#x2F;细胞质和细胞质&#x2F;背景边界处不确定性最高，而在其他位置不确定性较低时，分类器训练良好。</p>\n<p>  • 分类器训练良好后，将预测结果导出为无符号的16位TIFF图像</p>\n<p>  • 通过选择“analysis&#x2F;ilastik”文件夹中的所有_s2.h5文件来批量处理所有文件。此步骤将生成包含图像分割像素概率的三通道（细胞核、细胞质、背景）图像</p>\n<p>（iii）分割单个细胞。</p>\n<p>将‘resources&#x2F;pipelines&#x2F;2_segment_ilastik.cppipe’流程导入CellProfiler，并执行以下步骤：</p>\n<p>•\t将‘analysis&#x2F;ilastik’文件夹拖放到“Images”（图像）窗口中<br>•\t在“Output Settings”（输出设置）中，将“Default Output Folder”（默认输出文件夹）调整为‘analysis&#x2F;cpout’<br>以下步骤将作为流程的一部分自动执行：<br>•\t读取像素概率，将其缩小以匹配初始图像的尺寸，并拆分为三个通道<br>•\t将核通道和细胞质通道相加，形成一个单一通道<br>•\t根据指定的面积阈值对细胞核进行分割和过滤<br>•\t通过扩展核分割掩码到全细胞概率的边缘来分割整个细胞<br>•\t将分割掩码作为16位单通道TIFF图像写入到‘analysis&#x2F;cpout&#x2F;masks’文件夹中<br>•\t将缩小后的像素概率图像作为16位三通道TIFF图像写入到‘analysis&#x2F;cpout&#x2F;probabilities’文件夹中<br>◆ 故障排除</p>\n<h2 id=\"单细胞数据提取\"><a href=\"#单细胞数据提取\" class=\"headerlink\" title=\"单细胞数据提取\"></a>单细胞数据提取</h2><p>● 选项A耗时5分钟，选项B耗时10分钟</p>\n<ol start=\"8\">\n<li>从分割后的图像（即多通道图像和相应细胞掩码的配对）中提取空间分辨的单细胞数据。</li>\n</ol>\n<p>(A) 基于深度学习的工作流程<br>  (i) 对于每张图像，提取每个细胞和标记物的平均像素强度。得到的细胞水平的强度值以单独的CSV文件存储（每张图像一个文件）：<br>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock measure intensities</span><br></pre></td></tr></table></figure></p>\n<p>  (ii) 对于每张图像，提取每个细胞的形态学特征（面积、质心、长轴&#x2F;短轴长度、默认离心率；若要计算其他形态学特征，请参阅steinbock在线文档）。得到的细胞水平特征以单独的CSV文件存储（每张图像一个文件）：<br>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock measure regionprops</span><br></pre></td></tr></table></figure></p>\n<p>  (iii) 在每张图像中，检测空间上接近的细胞。得到的空间细胞图（框3）以单独的CSV格式有向边列表存储（每张图像一个文件）：<br>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock measure neighbors --<span class=\"built_in\">type</span> expansion --dmax 4</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>框3</p>\n<p>空间细胞图</p>\n<p>空间细胞图（也称为“邻域图”）是有向或无向的图（网络），其中细胞对应于节点，空间上邻近的细胞通过边相连。空间细胞图可用于分析细胞表型的空间共现情况（步骤31–35）。存在多种类型的空间细胞图；此处展示的是通过像素扩展构建的无向空间细胞图，在这种图中，仅当细胞在各方向上最多扩展4个像素后“接触”时，才认为它们是相邻的。</p>\n<hr>\n<p>（B）基于像素分类的工作流程</p>\n<p>（i）测量细胞特征。</p>\n<p>“resources&#x2F;pipelines&#x2F;3_measure_mask.cppipe”流程用于测量单细胞和单图像特征。将其导入CellProfiler并执行以下步骤：</p>\n<p>•\t将“analysis&#x2F;cpout”文件夹拖放到“Images”（图像）窗口中<br>•\t在“Output Settings”（输出设置）中，将“Default Output Folder”（默认输出文件夹）调整为“analysis&#x2F;cpout”，并将“Default Input Folder”（默认输入文件夹）调整为“analysis&#x2F;cpinp”<br>以下步骤是该流程的一部分：<br>•\t以16位灰度图像的形式读取分割掩码，并在保留其原始标签的同时将其转换为对象<br>•\t通过定义的距离扩展掩码来检测每个细胞的邻居<br>•\t提取每个细胞的完整堆栈通道强度和形状特征<br>•\t提取每个细胞的概率堆栈通道强度<br>•\t提取每幅图像的完整堆栈和概率堆栈强度<br>•\t将细胞、图像和实验数据保存为CSV文件。单细胞强度值通过对应于位深度的缩放因子进行缩放。对于本方案中使用的16位无符号整数图像（uint16），这些值除以2^16 - 1 &#x3D; 65,535<br>•\t将空间细胞图导出为包含边列表的CSV文件</p>\n<p>◆ 故障排除</p>\n<h1 id=\"单细胞和空间数据分析\"><a href=\"#单细胞和空间数据分析\" class=\"headerlink\" title=\"单细胞和空间数据分析\"></a>单细胞和空间数据分析</h1><p>本节中的命令必须在R中执行，RStudio软件可以简化执行过程。</p>\n<h2 id=\"数据读取\"><a href=\"#数据读取\" class=\"headerlink\" title=\"数据读取\"></a>数据读取</h2><p>● 耗时5分钟</p>\n<ol start=\"9\">\n<li>使用imcRtools包将空间分辨的单细胞数据读入R。在本方案的其余部分，我们将继续使用下面（A）中读入的steinbock生成的数据。</li>\n</ol>\n<p>（A）读取使用steinbock工具包生成的数据</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>imcRtools<span class=\"punctuation\">)</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> read_steinbock<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（B）读取CellProfiler生成的数据</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spe2 <span class=\"operator\">&lt;-</span> read_cpout<span class=\"punctuation\">(</span><span class=\"string\">&quot;path/to/analysis/cpout/&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键操作：调整路径以指向生成的空间分辨单细胞数据所在的位置。</p>\n<ol start=\"10\">\n<li>在读取单细胞数据后，需要对SpatialExperiment对象（框4）进行进一步处理。首先，根据图像名称和细胞标识符设置列名。患者标识符和ROI标识符以及癌症类型也保存在对象中，这些信息可以从提供的“data&#x2F;sample_metadata.csv”文件中读取。为了后续方便访问，选择了包含生物变异的通道。最后，使用1作为共因子，对每个通道和细胞的平均像素强度进行arsinh变换。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>tidyverse<span class=\"punctuation\">)</span></span><br><span class=\"line\">colnames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> paste0<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>sample_id<span class=\"punctuation\">,</span> <span class=\"string\">&quot;_&quot;</span><span class=\"punctuation\">,</span> spe<span class=\"operator\">$</span>ObjectNumber<span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取患者元数据</span></span><br><span class=\"line\">meta <span class=\"operator\">&lt;-</span> read_csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/sample_metadata.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 从样本名称中提取患者ID和ROI ID</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>patient_id <span class=\"operator\">&lt;-</span> str_extract<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>sample_id<span class=\"punctuation\">,</span> <span class=\"string\">&quot;Patient[1-4]&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">spe<span class=\"operator\">$</span>ROI <span class=\"operator\">&lt;-</span> str_extract<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>sample_id<span class=\"punctuation\">,</span> <span class=\"string\">&quot;00[1-8]&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Store cancer type in SPE object</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>indication <span class=\"operator\">&lt;-</span> meta<span class=\"operator\">$</span>Indication<span class=\"punctuation\">[</span>match<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>patient_id<span class=\"punctuation\">,</span> meta<span class=\"operator\">$</span>`Sample ID`<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Specify which channels to use for downstream analysis</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel <span class=\"operator\">&lt;-</span> <span class=\"operator\">!</span>grepl<span class=\"punctuation\">(</span><span class=\"string\">&quot;DNA|Histone&quot;</span><span class=\"punctuation\">,</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Transform the counts</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> <span class=\"built_in\">asinh</span><span class=\"punctuation\">(</span>counts<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">/</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键提示 与通常使用5作为共因子的arsinh变换的CyTOF数据集相比，IMC数据集的强度通常要低得多。在这里，我们使用1作为共因子，这是对信号与噪声之间阈值的粗略估计。之前已有类似共因子值用于IMC数据9,11和MIBI数据64,65的分析。然而，对于不同类型的数据或信号强度更高&#x2F;更低的IMC数据集，需要调整这个共因子。虽然这通常是根据定性标准手动完成的，但最近已有基于细胞类型特异性标志物共表达来启发式优化共因子值的系统方法被提出66。另外，也可以在此阶段对数据应用其他数据处理方法，包括Jackson等人8所使用的对数&#x2F;平方根变换和数据截断。</p>\n<ol start=\"11\">\n<li>使用cytomapper包25将多通道图像作为CytoImageList容器读入。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>cytomapper<span class=\"punctuation\">)</span></span><br><span class=\"line\">images <span class=\"operator\">&lt;-</span> loadImages<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">channelNames<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键提示 在使用steinbock工具包时，面板文件、图像和单细胞数据中的通道顺序是相同的。但是，当使用其他框架（如基于像素分类的分割方法）时，在设置通道名称时需要格外小心。</p>\n<ol start=\"12\">\n<li>将分割掩码作为CytoImageList容器读入。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">masks <span class=\"operator\">&lt;-</span> loadImages<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/masks/&quot;</span><span class=\"punctuation\">,</span> as.is <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键提示 除非另有配置（见“故障排除”），否则steinbock工具包会将分割掩码导出为16位图像。为了正确读取16位图像，需要设置‘as.is &#x3D; TRUE’参数。在读取32位图像时，应使用默认参数设置（‘as.is &#x3D; FALSE’）。</p>\n<p>◆ 故障排除</p>\n<hr>\n<p>框4<br>R中的单细胞数据容器<br>单细胞数据可以以SpatialExperiment（默认）或SingleCellExperiment对象17,28的形式读入。每个通道和细胞的平均像素强度存储在counts槽中。列代表细胞，行代表通道。与单个细胞相关的元数据存储在colData槽中。在初始图像处理后，这些元数据包括标签（ObjectNumber）、面积和每个细胞的形态学特征。此外，sample_id条目存储了从中提取每个细胞的图像名称。该工作流程支持SpatialExperiment和SingleCellExperiment对象。这些数据对象之间的主要区别在于存储所有细胞空间位置的方式。对于SingleCellExperiment容器，位置存储在colData槽中，而SpatialExperiment容器则将它们存储在spatialCoords槽中。steinbock等工具生成的空间细胞图被读入SpatialExperiment（或SingleCellExperiment）对象的colPair槽中。最后，与通道相关的元数据存储在rowData槽中。</p>\n<hr>\n<ol start=\"13\">\n<li>对于下游的可视化和分析任务，需要在存储多通道图像和分割掩码的CytoImageList对象中添加额外的元数据。在这里，通过sample_id条目将单个图像、分割掩码和空间实验（SpatialExperiment）对象中的条目进行匹配。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从图像名称中提取患者ID</span></span><br><span class=\"line\">patient_id <span class=\"operator\">&lt;-</span> str_extract<span class=\"punctuation\">(</span><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Patient[1-4]&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 从元数据文件中检索每位患者的癌症类型</span></span><br><span class=\"line\">indication <span class=\"operator\">&lt;-</span> meta<span class=\"operator\">$</span>Indication<span class=\"punctuation\">[</span>match<span class=\"punctuation\">(</span>patient_id<span class=\"punctuation\">,</span> meta<span class=\"operator\">$</span>`Sample ID`<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># 在elementMetadata中存储患者和图像级别的信息</span></span><br><span class=\"line\">mcols<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> mcols<span class=\"punctuation\">(</span>masks<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> DataFrame<span class=\"punctuation\">(</span>sample_id <span class=\"operator\">=</span> <span class=\"built_in\">names</span><span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> patient_id <span class=\"operator\">=</span> patient_id<span class=\"punctuation\">,</span></span><br><span class=\"line\"> indication <span class=\"operator\">=</span> indication<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"溢出校正（IMC特有）\"><a href=\"#溢出校正（IMC特有）\" class=\"headerlink\" title=\"溢出校正（IMC特有）\"></a>溢出校正（IMC特有）</h2><p>● 耗时：20分钟</p>\n<p>在IMC^(24)、MIBI^(67)和CyCIF^(68)等多重免疫荧光成像中，观察到两个通道之间存在低信号溢出（也称为串扰）。溢出被定义为在主要通道中可以检测到相邻通道信号的一小部分。由于溢出与相邻通道的信号成线性关系，因此可以通过之前描述的补偿方法^(24)进行校正。此处介绍的溢出校正是IMC特有的，如果假设已采用其他溢出最小化&#x2F;校正方法，则在使用其他多重成像技术生成的数据时，可以跳过以下部分的步骤。</p>\n<p>▲ 重要提示：如果核和细胞质通道相邻，也可以在图像分割之前进行溢出校正，以避免偏差。在这种情况下，需要将溢出校正后的图像写入“img”文件夹以供steinbock重新处理。然而，基于深度学习的分割方法对相邻通道之间的微量溢出不太敏感，而基于像素分类的分割方法则学会区分真实的核&#x2F;细胞质信号和溢出信号。尽管如此，还是建议通过视觉检查确保用于分割的通道中的溢出量最小。</p>\n<ol start=\"14\">\n<li>根据Chevrier等人24的研究，从溢出玻片中读取数据进行通道间溢出校正。创建和获取溢出玻片的实验过程可见补充说明2。根据CATALYST R&#x2F;Bioconductor包69的建议，使用5作为辅因子对像素强度进行arsinh变换。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sce <span class=\"operator\">&lt;-</span> readSCEfromTXT<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/compensation/&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> <span class=\"built_in\">asinh</span><span class=\"punctuation\">(</span>counts<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span><span class=\"operator\">/</span><span class=\"number\">5</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 重要提示：提供的溢出玻片数据是专门为此数据集获取的，不能应用于其他数据集。因此，必须为每组使用的抗体-金属螯合物以及理想情况下为每个实验获取一个溢出玻片。</p>\n<ol start=\"15\">\n<li>通过可视化每个通道和点样金属的中位像素强度来评估溢出数据的质量（图6a）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plotSpotHeatmap<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 重要提示：评估每个通道和点样金属的中位像素强度有两个目的：首先，较小的中位像素强度（~200个计数）可能会妨碍对通道溢出的稳健估计。其次，每个点样金属（行）应在其对应的通道（列）中显示出最高的中位像素强度。</p>\n<p>◆ 故障排除</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig6.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig6.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图6 | 单细胞数据和多通道图像的溢出校正。\"></p>\n<p>a，热图可视化每个通道（列）和点样金属（行）的log10转换后的中位像素强度。<br>b，热图可视化正确和错误分配给每个点样金属的像素的log10转换后的计数。x轴表示点样金属，y轴表示每个像素被分配到的金属。<br>c，通过散点图中可视化相邻通道（CD303：Yb174；Ecad：Yb173）的共检测标记强度，评估单细胞溢出校正的有效性。<br>d，图像显示了由于相邻通道溢出而产生的伪影信号。溢出校正消除了这些伪影。</p>\n<ol start=\"16\">\n<li>（可选）执行像素分箱以增加中位像素强度。这仅在像素强度过低（中位值低于约200计数）时才需要。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sce2 <span class=\"operator\">&lt;-</span> binAcrossPixels<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> bin_size <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"17\">\n<li>过滤错误分配的像素。以下步骤使用CATALYST包提供的函数对像素进行“去条形码化”处理。基于所有通道的强度分布，将像素分配给其对应的条形码，这里即为已知的金属点。此过程会识别出无法稳健分配给点样金属的像素。此类像素可视为“噪声”、“背景”或“伪影”，并应在溢出估计之前去除。需要指定点样通道（bc_key）。</li>\n</ol>\n<p>像素去条形码化的一般工作流程如下：</p>\n<p>• 为每个像素分配一个初步的金属质量<br>• 对于每个像素，估计正像素集和负像素集之间距离的截断参数<br>• 应用估计的截断值来识别真正的正像素</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>CATALYST<span class=\"punctuation\">)</span></span><br><span class=\"line\">bc_key <span class=\"operator\">&lt;-</span> <span class=\"built_in\">as.numeric</span><span class=\"punctuation\">(</span>unique<span class=\"punctuation\">(</span>sce<span class=\"operator\">$</span>sample_mass<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">bc_key <span class=\"operator\">&lt;-</span> bc_key<span class=\"punctuation\">[</span>order<span class=\"punctuation\">(</span>bc_key<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> assignPrelim<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> bc_key <span class=\"operator\">=</span> bc_key<span class=\"punctuation\">)</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> estCutoffs<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> applyCutoffs<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"18\">\n<li>观察每个点正确和错误分配的像素数量。图6b中的热图描绘了对角线上分配给每个点的像素数量、非对角线上错误分配的像素以及第一行中无法分配给特定点的像素。对于当前数据集，所有像素要么被分配给相应的点，要么被标记为未分配。在以下代码块中，我们观察到有10%到55%的像素无法分配给其对应的点，这是可以预料的，因为点样抗体在溢出玻片上的空间分布可能是异质性的。在filterPixels函数中，minevents参数指定了正确分配的像素集被排除在溢出估计之外的阈值。correct_pixels参数指示是否将分配给除点样质量以外的质量的像素排除在溢出估计之外。默认值通常足以进行足够的像素过滤；但是，如果每个点测量的像素非常少（~100），则需要降低minevents参数的值。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>pheatmap<span class=\"punctuation\">)</span></span><br><span class=\"line\">cur_table <span class=\"operator\">&lt;-</span> table<span class=\"punctuation\">(</span>sce<span class=\"operator\">$</span>bc_id<span class=\"punctuation\">,</span> sce<span class=\"operator\">$</span>sample_mass<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 可视化正确和错误分配的像素</span></span><br><span class=\"line\">pheatmap<span class=\"punctuation\">(</span>log10<span class=\"punctuation\">(</span>cur_table <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> cluster_rows <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">,</span> cluster_cols <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 计算每个点未分配像素的比例</span></span><br><span class=\"line\">cur_table<span class=\"punctuation\">[</span><span class=\"string\">&quot;0&quot;</span><span class=\"punctuation\">,</span><span class=\"punctuation\">]</span> <span class=\"operator\">/</span> colSums<span class=\"punctuation\">(</span>cur_table<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 过滤分配给除点样质量以外的质量的像素</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> filterPixels<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> minevents <span class=\"operator\">=</span> <span class=\"number\">40</span><span class=\"punctuation\">,</span> correct_pixels <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<ol start=\"19\">\n<li>使用CATALYST包计算和存储溢出矩阵。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sce <span class=\"operator\">&lt;-</span> computeSpillmat<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br><span class=\"line\">sm <span class=\"operator\">&lt;-</span> metadata<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span><span class=\"operator\">$</span>spillover_matrix</span><br></pre></td></tr></table></figure>\n\n<ol start=\"20\">\n<li>使用CATALYST包执行单细胞数据补偿。compCytof函数使用先前估计的溢出矩阵直接在单细胞强度上校正通道间的溢出。CATALYST包提供的isotope_list变量需要扩展为包含不在此列表中的同位素。通过比较校正前后相邻通道（例如Yb173和Yb174）的标记强度可视化，可以评估溢出校正的有效性（图6c）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>dittoSeq<span class=\"punctuation\">)</span></span><br><span class=\"line\">library<span class=\"punctuation\">(</span>patchwork<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Specify the channel_name entry for use with CATALYST</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>channel_name <span class=\"operator\">&lt;-</span> paste0<span class=\"punctuation\">(</span>rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>channel<span class=\"punctuation\">,</span> <span class=\"string\">&quot;Di&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Add the missing metal isotope to the isotope_list variable</span></span><br><span class=\"line\">isotope_list <span class=\"operator\">&lt;-</span> CATALYST<span class=\"operator\">::</span>isotope_list</span><br><span class=\"line\">isotope_list<span class=\"operator\">$</span>Ar <span class=\"operator\">&lt;-</span> 80</span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> compCytof<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> sm<span class=\"punctuation\">,</span></span><br><span class=\"line\"> transform <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span> cofactor <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> isotope_list <span class=\"operator\">=</span> isotope_list<span class=\"punctuation\">,</span></span><br><span class=\"line\"> overwrite <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize biaxial plots before/after compensation</span></span><br><span class=\"line\">before <span class=\"operator\">&lt;-</span> dittoScatterPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> x.var <span class=\"operator\">=</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> y.var <span class=\"operator\">=</span> <span class=\"string\">&quot;CD303&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay.x <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> assay.y <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Before compensation&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">after <span class=\"operator\">&lt;-</span> dittoScatterPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> x.var <span class=\"operator\">=</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> y.var <span class=\"operator\">=</span> <span class=\"string\">&quot;CD303&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay.x <span class=\"operator\">=</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">,</span> assay.y <span class=\"operator\">=</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;After compensation&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">before <span class=\"operator\">+</span> after</span><br><span class=\"line\"><span class=\"comment\"># Replace uncompensated assays</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;counts&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compcounts&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compcounts&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> <span class=\"literal\">NULL</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"21\">\n<li>对多通道图像进行通道间溢出校正。为此，需要对先前计算得到的溢出矩阵进行调整，仅保留存储在多通道图像中的通道。通过可视化相邻通道，可以评估溢出校正的效果（图6d）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Use mass tags as channel names</span></span><br><span class=\"line\">channelNames<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>channel_name</span><br><span class=\"line\"><span class=\"comment\"># Adapt spillover matrix to retain channels contained</span></span><br><span class=\"line\"><span class=\"comment\"># in the multi-channel images</span></span><br><span class=\"line\">adapted_sm <span class=\"operator\">&lt;-</span> adaptSpillmat<span class=\"punctuation\">(</span>sm<span class=\"punctuation\">,</span> channelNames<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> isotope_list <span class=\"operator\">=</span> isotope_list<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Perform image compensation</span></span><br><span class=\"line\">images_comp <span class=\"operator\">&lt;-</span> compImage<span class=\"punctuation\">(</span>images<span class=\"punctuation\">,</span> adapted_sm<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize neighboring channels before/after compensation</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173 (Ecad) - before&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb173Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174 (CD303) - before&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb174Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173 (Ecad) - after&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb173Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174 (CD303) - after&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb174Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Switch back to using target names as channel names</span></span><br><span class=\"line\">channelNames<span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"质控\"><a href=\"#质控\" class=\"headerlink\" title=\"质控\"></a>质控</h2><p>● 时间：10分钟</p>\n<ol start=\"22\">\n<li>在组合图像上勾勒细胞轮廓，以便对分割质量进行视觉评估（图7）。为了可视化，我们从三组图像中选取子集，并在通道归一化后，在组合图像上勾勒出所有细胞的轮廓。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">20220118</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">img_ids <span class=\"operator\">&lt;-</span> sample<span class=\"punctuation\">(</span><span class=\"built_in\">seq_len</span><span class=\"punctuation\">(</span><span class=\"built_in\">length</span><span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"number\">3</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">cur_images <span class=\"operator\">&lt;-</span> images_comp<span class=\"punctuation\">[</span>img_ids<span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Normalize each channel between 0 and 1</span></span><br><span class=\"line\">cur_images <span class=\"operator\">&lt;-</span> cytomapper<span class=\"operator\">::</span>normalize<span class=\"punctuation\">(</span>cur_images<span class=\"punctuation\">,</span> separateImages <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Clip channel intensities at 0 and 0.2</span></span><br><span class=\"line\">cur_images <span class=\"operator\">&lt;-</span> cytomapper<span class=\"operator\">::</span>normalize<span class=\"punctuation\">(</span>cur_images<span class=\"punctuation\">,</span> inputRange <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">0.2</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>cur_images<span class=\"punctuation\">,</span></span><br><span class=\"line\"> mask <span class=\"operator\">=</span> masks<span class=\"punctuation\">[</span>img_ids<span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> missing_colour <span class=\"operator\">=</span> <span class=\"string\">&quot;white&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colour_by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;CD163&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;CD20&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;CD3&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;DNA1&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colour <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>CD163 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;yellow&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> CD20 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;red&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> CD3 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;green&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> Ecad <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;cyan&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> DNA1 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;blue&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>colour_by.title.cex <span class=\"operator\">=</span> <span class=\"number\">0.9</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colour_by.labels.cex <span class=\"operator\">=</span> <span class=\"number\">0.9</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p> ▲ 关键信息：这种可视化方法有助于识别图像中分割错误的细胞。建议可视化多张图像并放大以评估分割质量。如果单个细胞核由其各自的细胞掩膜勾勒出来，而没有明显的细胞聚集或分裂现象，则图像分割足够准确。如果测量的标志物定位于细胞核内或在细胞内相对均匀分布，则仅对细胞核进行分割，以减少来自相邻细胞的侧向溢出。这可以选择性地与steinbock utils的expand命令（参见steinbock在线文档）结合使用，以略微扩大细胞掩膜捕获的细胞区域11,70。</p>\n<p>◆ 故障排除</p>\n<ol start=\"23\">\n<li>可视化细胞面积的分布（图8）并过滤掉小细胞。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dittoPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;area&quot;</span><span class=\"punctuation\">,</span> group.by <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span> plots <span class=\"operator\">=</span> <span class=\"string\">&quot;boxplot&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> ylab<span class=\"punctuation\">(</span><span class=\"string\">&quot;细胞面积&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> xlab<span class=\"punctuation\">(</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>area <span class=\"operator\">&gt;=</span> <span class=\"number\">5</span><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：组织切片的多重成像通常不会捕获完整的细胞，而是测量细胞的切片。因此，可能无法准确代表相应细胞的小细胞切片应从分析中排除。所选阈值特定于数据集，应通过可视化细胞面积的分布进行微调。</p>\n<p>◆ 故障排除</p>\n<ol start=\"24\">\n<li>可视化每幅图像中细胞覆盖的图像区域（图9）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计算细胞覆盖的图像面积的比例</span></span><br><span class=\"line\">cell_density <span class=\"operator\">&lt;-</span> colData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> as.data.frame<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> group_by<span class=\"punctuation\">(</span>sample_id<span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> <span class=\"comment\"># Compute the number of pixels covered by cells and</span></span><br><span class=\"line\"> <span class=\"comment\"># the total number of pixels</span></span><br><span class=\"line\"> summarize<span class=\"punctuation\">(</span>cell_area <span class=\"operator\">=</span> <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>area<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> no_pixels <span class=\"operator\">=</span> mean<span class=\"punctuation\">(</span>width_px<span class=\"punctuation\">)</span> <span class=\"operator\">*</span> mean<span class=\"punctuation\">(</span>height_px<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> <span class=\"comment\"># Divide the total number of pixels</span></span><br><span class=\"line\"> <span class=\"comment\"># by the number of pixels covered by cells</span></span><br><span class=\"line\"> mutate<span class=\"punctuation\">(</span>covered_area <span class=\"operator\">=</span> cell_area <span class=\"operator\">/</span> no_pixels<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize the image area covered by cells per image</span></span><br><span class=\"line\">ggplot<span class=\"punctuation\">(</span>cell_density<span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> geom_point<span class=\"punctuation\">(</span>aes<span class=\"punctuation\">(</span>sample_id<span class=\"punctuation\">,</span> covered_area<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme_minimal<span class=\"punctuation\">(</span>base_size <span class=\"operator\">=</span> <span class=\"number\">15</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>axis.text.x <span class=\"operator\">=</span> element_text<span class=\"punctuation\">(</span>angle <span class=\"operator\">=</span> <span class=\"number\">90</span><span class=\"punctuation\">,</span> hjust <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">15</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ylim<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ylab<span class=\"punctuation\">(</span><span class=\"string\">&quot;% covered area&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> xlab<span class=\"punctuation\">(</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：在选择致密组织区域进行采集时，我们预期图像像素的大部分将被细胞覆盖。然而，由于稀疏组织结构（如血管）的存在或组织丢失，覆盖比例可能会降低。</p>\n<p>◆ 故障排除</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig7.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig7.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图7 | 分割质量的视觉评估。在由六种标志物（CD163，黄色，髓系细胞；CD20，红色，B细胞；CD3，绿色，T细胞；E-钙粘蛋白，青色，上皮细胞；DNA1，蓝色，细胞核）伪彩色合成的图像上勾勒出分割后的细胞轮廓。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig8.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig8.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图8 | 细胞面积分布。以箱线图的形式显示每幅图像（x轴）上的细胞面积分布（y轴）。黑条表示中位数，铰链表示分布的第一四分位数和第三四分位数。\"></p>\n<ol start=\"25\">\n<li>可视化选定标志物在样本间的染色差异。结合低维细胞可视化（步骤26），图10显示了样本间标志物表达的差异。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multi_dittoPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> vars <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;HLADR&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;CD3&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;PDGFRb&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> group.by <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span> plots <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;ridgeplot&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"26\">\n<li>可视化单细胞的低维嵌入。这里，我们使用scater包58来计算均匀流形近似和投影（UMAP）嵌入，并在低维空间中可视化细胞（图11a）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scater<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220225</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> runUMAP<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> subset_row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span></span><br><span class=\"line\"> exprs_values <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize the UMAP embedding and color cells by patient ID</span></span><br><span class=\"line\">dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Patient ID on UMAP&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig9.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig9.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图9 | 每幅图像中细胞覆盖的图像区域可视化。显示每幅图像（x轴）上细胞覆盖的像素比例（y轴）。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig10.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig10.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图10 | 患者间标志物分布差异的可视化。脊线图显示了数据集中每个患者选定标志物的每个细胞的arsinh转换平均像素强度分布。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig11.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig11.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图11 | 单细胞的低维表示。a，按患者标识符着色的单细胞的UMAP表示。b，经过fastMNN批次校正后按患者着色的UMAP表示。\"></p>\n<p>▲ 关键信息：在UMAP可视化（步骤25-26，图10和11a）中，标志物分布的差异或非重叠样本可能表明样本间的染色差异或生物学差异。当样本处理方式不同或使用不同批次的抗体混合物进行染色时，可能会出现染色差异。</p>\n<p>◆ 故障排除</p>\n<ol start=\"27\">\n<li>执行批次校正以消除样本间的差异（图11b）。这里，我们使用batchelor包的fastMNN方法30。在以下代码块中，为了可重复性，在设置种子后依次执行非确定性的fastMNN和runUMAP函数。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>batchelor<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220228</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Perform batch correction</span></span><br><span class=\"line\">out <span class=\"operator\">&lt;-</span> fastMNN<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> batch <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>patient_id<span class=\"punctuation\">,</span></span><br><span class=\"line\"> auto.merge <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> subset.row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay.type <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Store corrected embeddings in SPE object</span></span><br><span class=\"line\">reducedDim<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> reducedDim<span class=\"punctuation\">(</span>out<span class=\"punctuation\">,</span> <span class=\"string\">&quot;corrected&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute UMAP on corrected embeddings</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> runUMAP<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> dimred<span class=\"operator\">=</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">,</span> name <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize corrected UMAP</span></span><br><span class=\"line\">dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Patient ID on UMAP after correction&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：需要视觉评估批次校正的准确性，以估计是否除了技术变异外还消除了生物变异。这可以通过根据已知在某些细胞表型中表达的标志物对UMAP嵌入进行着色来实现。这些标志物应在UMAP嵌入中聚类的细胞中表达。可以使用其他批次效应校正方法来改进数据整合71,72。</p>\n<p>◆ 故障排除</p>\n<h2 id=\"细胞表型分析\"><a href=\"#细胞表型分析\" class=\"headerlink\" title=\"细胞表型分析\"></a>细胞表型分析</h2><p>● 时间：选项A需30分钟，选项B需1-2小时（更大数据集需要更多时间）</p>\n<ol start=\"28\">\n<li>定义细胞表型。为此，可以对单细胞进行聚类（A）或通过分类进行表型分析（B）。</li>\n</ol>\n<p>（A）通过聚类进行细胞表型分析</p>\n<p>使用bluster和scran R&#x2F;Bioconductor包59中的函数进行基于图的聚类。另外，也可以使用其他方法，如phenograph53或FlowSOM73对单细胞进行聚类。</p>\n<p>（i）在批次校正后的细胞嵌入上估计基于图的聚类的最佳聚类参数。我们遍历聚类参数的所有可能组合（图12），包括要考虑的最近邻数（k）和边权重方法（类型）。我们保持社区检测算法（cluster.fun）固定，因为Louvain方法74是基于图的聚类中最常用的算法之一。为了评估聚类的稳定性，我们计算所有细胞的平均轮廓宽度，并选择平均轮廓宽度最高的聚类参数组合。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig12.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig12.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图12 | 用于最优参数估计的聚类参数遍历。数据集使用四种聚类参数组合（x轴）进行聚类。对于每种组合，计算了所有细胞的平均轮廓宽度。较高的值表示聚类分离度更好。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>bluster<span class=\"punctuation\">)</span></span><br><span class=\"line\">library<span class=\"punctuation\">(</span>BiocParallel<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Select the corrected cell embeddings for clustering</span></span><br><span class=\"line\">mat <span class=\"operator\">&lt;-</span> reducedDim<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Perform the cluster sweep</span></span><br><span class=\"line\">combinations <span class=\"operator\">&lt;-</span> clusterSweep<span class=\"punctuation\">(</span>mat<span class=\"punctuation\">,</span> BLUSPARAM<span class=\"operator\">=</span>SNNGraphParam<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> k<span class=\"operator\">=</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">10L</span><span class=\"punctuation\">,</span> <span class=\"number\">20L</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;rank&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;jaccard&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> cluster.fun <span class=\"operator\">=</span> <span class=\"string\">&quot;louvain&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BPPARAM <span class=\"operator\">=</span> SerialParam<span class=\"punctuation\">(</span>RNGseed <span class=\"operator\">=</span> <span class=\"number\">230214</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the average silhouette width per parameter combination</span></span><br><span class=\"line\">sil <span class=\"operator\">&lt;-</span> vapply<span class=\"punctuation\">(</span>as.list<span class=\"punctuation\">(</span>combinations<span class=\"operator\">$</span>clusters<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>x<span class=\"punctuation\">)</span> mean<span class=\"punctuation\">(</span>approxSilhouette<span class=\"punctuation\">(</span>mat<span class=\"punctuation\">,</span> x<span class=\"punctuation\">)</span><span class=\"operator\">$</span>width<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"number\">0</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize the average silhouette width per parameter</span></span><br><span class=\"line\"><span class=\"comment\"># combination</span></span><br><span class=\"line\">ggplot<span class=\"punctuation\">(</span>data.frame<span class=\"punctuation\">(</span>method <span class=\"operator\">=</span> <span class=\"built_in\">names</span><span class=\"punctuation\">(</span>sil<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> sil <span class=\"operator\">=</span> sil<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> geom_point<span class=\"punctuation\">(</span>aes<span class=\"punctuation\">(</span>method<span class=\"punctuation\">,</span> sil<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">3</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme_classic<span class=\"punctuation\">(</span>base_size <span class=\"operator\">=</span> <span class=\"number\">15</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>axis.text.x <span class=\"operator\">=</span> element_text<span class=\"punctuation\">(</span>angle <span class=\"operator\">=</span> <span class=\"number\">45</span><span class=\"punctuation\">,</span> hjust <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> xlab<span class=\"punctuation\">(</span><span class=\"string\">&quot;Cluster parameter combination&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ylab<span class=\"punctuation\">(</span><span class=\"string\">&quot;Average silhouette width&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：对于每个数据集，应独立进行参数估计。对于大型数据集，该函数运行时间较长，为了近似处理，可以对数据集进行子采样以加快聚类遍历的速度。</p>\n<p>（ii）基于所选参数，使用基于图的算法对细胞进行聚类。如前所述，将参数设置为k&#x3D;20和类型“rank”应该能得到分离度较好的聚类。然后，将聚类标识符保存在SpatialExperiment对象中。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scran<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220621</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">clusters <span class=\"operator\">&lt;-</span> clusterCells<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> use.dimred <span class=\"operator\">=</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BLUSPARAM <span class=\"operator\">=</span> SNNGraphParam<span class=\"punctuation\">(</span>k <span class=\"operator\">=</span> <span class=\"number\">20</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> cluster.fun <span class=\"operator\">=</span> <span class=\"string\">&quot;louvain&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;rank&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>nn_clusters <span class=\"operator\">&lt;-</span> clusters</span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<p>（iii）为了根据各聚类中包含的细胞表型对其进行注释，可以以热图的形式可视化每个聚类的标志物表达（图13）。为了可视化目的，从数据集中随机选择了2000个细胞。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>viridis<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220619</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">cur_cells <span class=\"operator\">&lt;-</span> sample<span class=\"punctuation\">(</span><span class=\"built_in\">seq_len</span><span class=\"punctuation\">(</span>ncol<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"number\">2000</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">dittoHeatmap<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>cur_cells<span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> genes <span class=\"operator\">=</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">[</span>rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> heatmap.colors <span class=\"operator\">=</span> viridis<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> annot.by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;nn_clusters&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig13.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig13.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图13 | 聚类特异性表达模式的可视化。2000个随机选取的细胞的arsinh转换后的标志物表达显示出聚类特异性的表达模式。每一列代表一个单独的细胞，每一行包含一个单独的标志物。细胞根据其所属的聚类和患者ID进行标记。\"></p>\n<p>（iv）在观察到聚类特异性表达模式后，可以对各个聚类进行注释。例如，聚类12显示出B细胞标志物CD20的高表达，因此可以标记为“Bcell”。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster_celltype <span class=\"operator\">&lt;-</span> recode<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>nn_clusters<span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;1&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tumor_proliferating&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;2&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Myeloid&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;3&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;4&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;5&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Stroma&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;6&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Proliferating&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;7&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Myeloid&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;8&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Plasma_cell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;9&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;CD8&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;10&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;CD4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;11&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Neutrophil&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;12&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Bcell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;13&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Stroma&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（B）基于分类的细胞表型分析</p>\n<p>（i）使用cytomapper包中包含的cytomapperShiny函数，根据标志物的表达来界定单个细胞的表型。对于每张图像，细胞根据其标志物表达的层次结构进行界定，以定义预期的细胞表型。然后，将界定的细胞以轮廓的形式显示在伪彩色合成图像上。一旦正确标记了细胞，就可以将它们作为仅包含选定细胞的SpatialExperiment对象下载。在下载时，可以指定细胞标签，该标签存储在colData插槽的cytomapper_CellLabel条目中，以便稍后用于训练分类器（步骤28B(iv)）。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cytomapperShiny<span class=\"punctuation\">(</span>object <span class=\"operator\">=</span> spe<span class=\"punctuation\">,</span> mask <span class=\"operator\">=</span> masks<span class=\"punctuation\">,</span> image <span class=\"operator\">=</span> images_comp<span class=\"punctuation\">,</span></span><br><span class=\"line\"> cell_id <span class=\"operator\">=</span> <span class=\"string\">&quot;ObjectNumber&quot;</span><span class=\"punctuation\">,</span> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：由于分割不完全，侧向溢出会导致某些标志物的表达水平不正确。因此，我们建议仅对表达其特定细胞表型标志物的细胞进行界定。</p>\n<p>（ii）读取包含界定细胞的文件，并将它们合并成一个SpatialExperiment对象。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>SingleCellExperiment<span class=\"punctuation\">)</span></span><br><span class=\"line\">label_files <span class=\"operator\">&lt;-</span> list.files<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/gated_cells&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> full.names <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span> pattern <span class=\"operator\">=</span> <span class=\"string\">&quot;.rds$&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Read in individual files containing gated cells</span></span><br><span class=\"line\">spes <span class=\"operator\">&lt;-</span> lapply<span class=\"punctuation\">(</span>label_files<span class=\"punctuation\">,</span> readRDS<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Concatenate the individual objects into one</span></span><br><span class=\"line\">concat_spe <span class=\"operator\">&lt;-</span> do.call<span class=\"punctuation\">(</span><span class=\"string\">&quot;cbind&quot;</span><span class=\"punctuation\">,</span> spes<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（iii）移除被多次标记的细胞，并重新分配肿瘤细胞。由于采用多步骤标记方法，一些细胞可能被标记了多次。在细胞同时被标记为肿瘤细胞和免疫细胞的情况下，我们保留免疫细胞标签，因为这些细胞很可能是驻留在肿瘤内的免疫细胞。所有其他被多次标记的细胞都被移除。最后，将标签存储在主要的SpatialExperiment对象中。我们首先定义一个辅助函数，该函数返回仅被标记一次的细胞的标签。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter_labels <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>object<span class=\"punctuation\">,</span></span><br><span class=\"line\"> label <span class=\"operator\">=</span> <span class=\"string\">&quot;cytomapper_CellLabel&quot;</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"> cur_tab <span class=\"operator\">&lt;-</span> <span class=\"built_in\">unclass</span><span class=\"punctuation\">(</span>table<span class=\"punctuation\">(</span>colnames<span class=\"punctuation\">(</span>object<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> object<span class=\"punctuation\">[[</span>label<span class=\"punctuation\">]</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"> cur_labels <span class=\"operator\">&lt;-</span> colnames<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">)</span><span class=\"punctuation\">[</span>apply<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> which.max<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"> <span class=\"built_in\">names</span><span class=\"punctuation\">(</span>cur_labels<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">)</span></span><br><span class=\"line\"> cur_labels <span class=\"operator\">&lt;-</span> cur_labels<span class=\"punctuation\">[</span>rowSums<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">)</span> <span class=\"operator\">==</span> <span class=\"number\">1</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"> <span class=\"built_in\">return</span><span class=\"punctuation\">(</span>cur_labels<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来，应用此函数来检索所有仅被标记一次的细胞。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">labels <span class=\"operator\">&lt;-</span> filter_labels<span class=\"punctuation\">(</span>concat_spe<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>再次对所有细胞应用该函数，同时排除“Tumor”标签。这种方法可以识别那些既被标记为肿瘤细胞又被标记为免疫细胞的细胞。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cur_spe <span class=\"operator\">&lt;-</span> concat_spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>concat_spe<span class=\"operator\">$</span>cytomapper_CellLabel <span class=\"operator\">!=</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">non_tumor_labels <span class=\"operator\">&lt;-</span> filter_labels<span class=\"punctuation\">(</span>cur_spe<span class=\"punctuation\">)</span></span><br><span class=\"line\">additional_cells <span class=\"operator\">&lt;-</span> setdiff<span class=\"punctuation\">(</span><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>non_tumor_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>labels<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，将两组细胞标签合并并存储在SpatialExperiment对象中。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final_labels <span class=\"operator\">&lt;-</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span>labels<span class=\"punctuation\">,</span> non_tumor_labels<span class=\"punctuation\">[</span>additional_cells<span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Transfer labels to SPE object</span></span><br><span class=\"line\">spe_labels <span class=\"operator\">&lt;-</span> <span class=\"built_in\">rep</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;unlabeled&quot;</span><span class=\"punctuation\">,</span> ncol<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>spe_labels<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> colnames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span></span><br><span class=\"line\">spe_labels<span class=\"punctuation\">[</span><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>final_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span> <span class=\"operator\">&lt;-</span> final_labels</span><br><span class=\"line\">spe<span class=\"operator\">$</span>cell_labels <span class=\"operator\">&lt;-</span> spe_labels</span><br></pre></td></tr></table></figure>\n\n<p>（iv）为未标记细胞的表型分类训练一个随机森林分类器。首先，将细胞分为标记细胞和未标记细胞。然后，我们对标记细胞进行75&#x2F;25的划分，以分别选择训练集和测试集。基于训练集，我们进行五折交叉验证来调整随机森林模型的参数。在以下代码块中，为了可重复性，在设置随机种子后，依次执行了非确定性的createDataPartition函数和train函数。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>caret<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Split between labeled and unlabeled cells</span></span><br><span class=\"line\">lab_spe <span class=\"operator\">&lt;-</span> spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>cell_labels <span class=\"operator\">!=</span> <span class=\"string\">&quot;unlabeled&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">unlab_spe <span class=\"operator\">&lt;-</span> spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>cell_labels <span class=\"operator\">==</span> <span class=\"string\">&quot;unlabeled&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Randomly split into train and test data</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">221029</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">trainIndex <span class=\"operator\">&lt;-</span> createDataPartition<span class=\"punctuation\">(</span>factor<span class=\"punctuation\">(</span>lab_spe<span class=\"operator\">$</span>cell_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">p <span class=\"operator\">=</span> <span class=\"number\">0.75</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">train_spe <span class=\"operator\">&lt;-</span> lab_spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>trainIndex<span class=\"operator\">$</span>Resample1<span class=\"punctuation\">]</span></span><br><span class=\"line\">test_spe <span class=\"operator\">&lt;-</span> lab_spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span><span class=\"operator\">-</span>trainIndex<span class=\"operator\">$</span>Resample1<span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Define fit parameters for 5-fold cross validation</span></span><br><span class=\"line\">fitControl <span class=\"operator\">&lt;-</span> trainControl<span class=\"punctuation\">(</span>method <span class=\"operator\">=</span> <span class=\"string\">&quot;cv&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> number <span class=\"operator\">=</span> <span class=\"number\">5</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Select the arsinh-transformed counts for training</span></span><br><span class=\"line\">cur_mat <span class=\"operator\">&lt;-</span> t<span class=\"punctuation\">(</span>assay<span class=\"punctuation\">(</span>train_spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>train_spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Train a random forest classifier</span></span><br><span class=\"line\">rffit <span class=\"operator\">&lt;-</span> train<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> y <span class=\"operator\">=</span> factor<span class=\"punctuation\">(</span>train_spe<span class=\"operator\">$</span>cell_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> method <span class=\"operator\">=</span> <span class=\"string\">&quot;rf&quot;</span><span class=\"punctuation\">,</span> ntree <span class=\"operator\">=</span> <span class=\"number\">1000</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> tuneLength <span class=\"operator\">=</span> <span class=\"number\">5</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> trControl <span class=\"operator\">=</span> fitControl<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<p>（v）通过计算测试集的混淆矩阵来评估分类器的性能。confusionMatrix函数将预测的细胞标签与真实的细胞标签进行比较，并计算多个性能指标。期望每个细胞表型标签都具有高灵敏度和高特异性。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Select the arsinh-transformed counts of the test data</span></span><br><span class=\"line\">cur_mat <span class=\"operator\">&lt;-</span> t<span class=\"punctuation\">(</span>assay<span class=\"punctuation\">(</span>test_spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>test_spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Predict the cell phenotype labels of the test data</span></span><br><span class=\"line\">cur_pred <span class=\"operator\">&lt;-</span> predict<span class=\"punctuation\">(</span>rffit<span class=\"punctuation\">,</span> newdata <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the confusion matrix between predicted</span></span><br><span class=\"line\"><span class=\"comment\"># and actual labels</span></span><br><span class=\"line\">confusionMatrix<span class=\"punctuation\">(</span>data <span class=\"operator\">=</span> cur_pred<span class=\"punctuation\">,</span></span><br><span class=\"line\"> reference <span class=\"operator\">=</span> factor<span class=\"punctuation\">(</span>test_spe<span class=\"operator\">$</span>cell_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> mode <span class=\"operator\">=</span> <span class=\"string\">&quot;everything&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（vi）预测未标记细胞的标签。对于最高类别概率低于40%的细胞，将其标记为“未知”。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Select the arsinh-transformed counts of</span></span><br><span class=\"line\"><span class=\"comment\"># the unlabeled data for prediction</span></span><br><span class=\"line\">cur_mat <span class=\"operator\">&lt;-</span> t<span class=\"punctuation\">(</span>assay<span class=\"punctuation\">(</span>unlab_spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>unlab_spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Predict the cell phenotype labels of the unlabeled data</span></span><br><span class=\"line\">cell_class <span class=\"operator\">&lt;-</span> <span class=\"built_in\">as.character</span><span class=\"punctuation\">(</span>predict<span class=\"punctuation\">(</span>rffit<span class=\"punctuation\">,</span></span><br><span class=\"line\"> newdata <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;raw&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>cell_class<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>cur_mat<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Extract prediction probabilities for each cell</span></span><br><span class=\"line\">cell_prob <span class=\"operator\">&lt;-</span> predict<span class=\"punctuation\">(</span>rffit<span class=\"punctuation\">,</span></span><br><span class=\"line\"> newdata <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;prob&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Label cells with a low prediction probability as undefined</span></span><br><span class=\"line\">cell_class<span class=\"punctuation\">[</span>rowMax<span class=\"punctuation\">(</span>as.matrix<span class=\"punctuation\">(</span>cell_prob<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;</span> <span class=\"number\">0.4</span><span class=\"punctuation\">]</span> <span class=\"operator\">&lt;-</span> <span class=\"string\">&quot;undefined&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># Store cell phenotype labels in SPE object</span></span><br><span class=\"line\">cell_labels <span class=\"operator\">&lt;-</span> spe<span class=\"operator\">$</span>cell_labels</span><br><span class=\"line\">cell_labels<span class=\"punctuation\">[</span>colnames<span class=\"punctuation\">(</span>unlab_spe<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span> <span class=\"operator\">&lt;-</span> cell_class</span><br><span class=\"line\">spe<span class=\"operator\">$</span>celltype <span class=\"operator\">&lt;-</span> cell_labels</span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：将细胞标记为未定义的阈值需要根据每个数据集进行调整。当预测更多的细胞类别时，阈值可能会降低；而当预测较少的类别时，阈值可以相应提高。</p>\n<ol start=\"29\">\n<li>在UMAP嵌入上可视化细胞表型和注释后的聚类标签，以定性评估细胞表型（图14）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 <span class=\"operator\">&lt;-</span> dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> do.label <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Cell types on UMAP, integrated cells&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">p2 <span class=\"operator\">&lt;-</span> dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;cluster_celltype&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> do.label <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Cluster cell types on UMAP, integrated cells&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">p1 <span class=\"operator\">+</span> p2</span><br></pre></td></tr></table></figure>\n\n<ol start=\"30\">\n<li>以热图的形式可视化每个细胞表型和每个注释后的聚类的平均标志物表达（图15）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scuttle<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Calculate the mean of the arsinh-transformed counts per cell phenotype</span></span><br><span class=\"line\">celltype_mean <span class=\"operator\">&lt;-</span> aggregateAcrossCells<span class=\"punctuation\">(</span>as<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;SingleCellExperiment&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> ids <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>celltype<span class=\"punctuation\">,</span></span><br><span class=\"line\">  statistics <span class=\"operator\">=</span> <span class=\"string\">&quot;mean&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> use.assay.type <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> subset_row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">)</span></span><br><span class=\"line\">dittoHeatmap<span class=\"punctuation\">(</span>celltype_mean<span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> cluster_cols <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> heatmap.colors <span class=\"operator\">=</span> viridis<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> annot.by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ncells&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Calculate the mean of the arsinh-transformed counts per annotated </span></span><br><span class=\"line\"><span class=\"comment\"># cluster</span></span><br><span class=\"line\"> cluster_mean <span class=\"operator\">&lt;-</span> aggregateAcrossCells<span class=\"punctuation\">(</span>as<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;SingleCellExperiment&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> ids <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>cluster_celltype<span class=\"punctuation\">,</span></span><br><span class=\"line\"> statistics <span class=\"operator\">=</span> <span class=\"string\">&quot;mean&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> use.assay.type <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> subset_row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">)</span></span><br><span class=\"line\">dittoHeatmap<span class=\"punctuation\">(</span>cluster_mean<span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> cluster_cols <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> heatmap.colors <span class=\"operator\">=</span> viridis<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> annot.by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;cluster_celltype&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ncells&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：我们期望单个细胞表型能够显示出其特异性标志物的最高平均表达。此外，在如UMAP这样的低维嵌入中，细胞表型应能在视觉上被区分开来。</p>\n<p>◆ 故障排除</p>\n<h2 id=\"空间分析\"><a href=\"#空间分析\" class=\"headerlink\" title=\"空间分析\"></a>空间分析</h2><p>● 预计时间：20分钟</p>\n<p>本方案介绍了一系列空间分析方法，旨在研究细胞在组织环境中的分布情况。如需概览，请见图16。</p>\n<ol start=\"31\">\n<li>使用Jackson等人提出的空间群落分析方法8（图17），并借助imcRtools软件包提供的detectCommunity函数。该方法通过先前构建的空间细胞图，仅根据细胞在组织中的位置对细胞进行分组。我们分别对肿瘤细胞和非肿瘤细胞进行了群落检测。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig14.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig14.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14 | UMAP嵌入上展示的细胞表型。a，细胞在低维UMAP空间中展示，并根据通过细胞分类确定的表型进行着色。b，UMAP空间中的细胞根据其注释的聚类标识符进行着色。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig15.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig15.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图15 | 平均标志物表达热图。a，热图可视化了通过细胞分类定义的每个细胞表型的平均arsinh转换后的标志物表达。b，热图展示了每个注释聚类的平均arsinh转换后的标志物表达。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define if cells are part of the tumor or stroma</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>tumor_stroma <span class=\"operator\">&lt;-</span> ifelse<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>celltype <span class=\"operator\">==</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Stroma&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Detect spatial communities</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> detectCommunity<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;neighborhood&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> size_threshold <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;tumor_stroma&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BPPARAM <span class=\"operator\">=</span> SerialParam<span class=\"punctuation\">(</span>RNGseed <span class=\"operator\">=</span> <span class=\"number\">220819</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize spatial tumor communities</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>celltype <span class=\"operator\">==</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_community&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>legend.position <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_manual<span class=\"punctuation\">(</span>values <span class=\"operator\">=</span> rev<span class=\"punctuation\">(</span>colors<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>在检测到空间群落之后，可以进行一系列下游分析。这些分析包括（i）计算用于元聚类的每个群落的细胞表型比例，（ii）识别样本间的共享群落以进行比较分析，以及（iii）计算单个群落的大小以估计组织分隔。</p>\n<ol start=\"32\">\n<li>按照Schürch等人10和Goltsev等人5的提议执行拷贝数（CN）分析（图18）。拷贝数是具有特征细胞表型组成的组织区域，它们代表了独特的局部生物过程和相互作用的位点。我们首先基于细胞的质心构建一个空间20近邻图，与先前使用steinbock构建的空间细胞图相比，该图包含了更多的邻居。然后，使用imcRtools包的aggregateNeighbors函数计算每个细胞在其20近邻中的细胞表型比例。接着，使用k均值聚类对细胞进行聚类以检测拷贝数。最后，可以根据细胞的拷贝数对其进行空间可视化和着色，并计算每个拷贝数的细胞表型比例。在图18中，拷贝数3代表B细胞的空间聚集，而拷贝数1主要包含肿瘤组织。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig16.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig16.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图16 | 空间分析方法的输入、可解释性和输出。本方案强调了一系列用于研究组织结构的空间分析方法。所提供的函数需要SpatialExperiment或SingleCellExperiment对象作为输入，并在内部使用存储在对象的colData、spatialCoords和colPairs槽中的信息。每个任务下的示例图像下方展示了一些可以解决的生物学问题。各个分析方法的输出要么是添加了额外colData条目的SpatialExperiment对象，要么是数据框。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Construct a 20-nearest neighbor graph</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> buildSpatialGraph<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span> type <span class=\"operator\">=</span> <span class=\"string\">&quot;knn&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">k <span class=\"operator\">=</span> <span class=\"number\">20</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the fraction of cell phenotypes in each cells neighborhood</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> aggregateNeighbors<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;knn_interaction_graph&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> aggregate_by <span class=\"operator\">=</span> <span class=\"string\">&quot;metadata&quot;</span><span class=\"punctuation\">,</span> count_by <span class=\"operator\">=</span> <span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220705</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Cluster cells based on cell phenotype fractions</span></span><br><span class=\"line\">cn_1 <span class=\"operator\">&lt;-</span> kmeans<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>aggregatedNeighbors<span class=\"punctuation\">,</span> centers <span class=\"operator\">=</span> <span class=\"number\">6</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>cn_celltypes <span class=\"operator\">&lt;-</span> as.factor<span class=\"punctuation\">(</span>cn_1<span class=\"operator\">$</span>cluster<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize cellular neighborhoods</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;cn_celltypes&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_brewer<span class=\"punctuation\">(</span>palette <span class=\"operator\">=</span> <span class=\"string\">&quot;Set3&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the fraction of cell phenotypes in each cellular </span></span><br><span class=\"line\"><span class=\"comment\"># neighborhood</span></span><br><span class=\"line\">mat <span class=\"operator\">&lt;-</span> prop.table<span class=\"punctuation\">(</span>table<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>cn_celltypes<span class=\"punctuation\">,</span> spe<span class=\"operator\">$</span>celltype<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> margin <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize cell phenotype fractions in each cellular neighborhood</span></span><br><span class=\"line\">pheatmap<span class=\"punctuation\">(</span>mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> color <span class=\"operator\">=</span> colorRampPalette<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;dark blue&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;white&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;dark red&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;column&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键步骤：与第28步类似，应通过参数扫描来估计k的最优值。但是，如果事先了解要检测的组织结构，则可以相应地设置k值。或者，也可以根据细胞邻域内细胞的平均标志物表达来对细胞进行聚类。此外，lisaClust R&#x2F;Bioconductor包还提供了检测拷贝数（CNs）的其他策略75。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig17.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig17.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图17 | 空间肿瘤群落。使用先前构建的空间细胞图，根据肿瘤细胞的空间位置将其聚类成群落，并根据其空间群落标识符进行着色。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig18.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig18.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图18 | 细胞邻域检测。a，根据细胞20个最近邻中的细胞表型频率对细胞进行聚类，并根据其细胞邻域进行着色。b，热图展示了每个细胞邻域内的细胞表型比例。列数据已进行z分数标准化。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig19.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig19.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图19 | 空间背景检测。a，根据细胞的空间背景进行着色，空间背景定义为可在每个细胞邻域中找到的拷贝数（CNs）的组合（例如，处于SC 1_6中的细胞是位于CN 1和CN 6之间的细胞）。b，空间背景图显示了哪些空间背景存在相互作用。节点的颜色由每个空间背景中的细胞数量决定。\"></p>\n<ol start=\"33\">\n<li>按照Bhate等人19的提议执行空间背景（SC）分析（图19）。空间背景建立在拷贝数（CNs）的概念之上，是拷贝数的局部生物过程相互作用并发生特殊生物事件的区域。我们构建了第二个k近邻图，其中k值较大（k&#x3D;40），以包含可在生物信号交换的长度尺度上的细胞。对于每个细胞，aggregateNeighbors函数计算其40个最近邻中拷贝数的比例。detectSpatialContext函数将拷贝数比例从高到低排序，并将每个细胞的空间背景分配为累积超过用户定义阈值（此处为0.9）的最小拷贝数组合。在过滤检测到的空间背景后，我们可以对其进行空间可视化，并将空间背景相互作用表示为分层图。我们观察到，SC 1（以肿瘤为主）、SC 1_6（肿瘤与肿瘤-间质界面）和SC 4_5（浆细胞&#x2F;T细胞和髓系细胞&#x2F;中性粒细胞界面）是该数据集中最常见的空间背景。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Construct a 40-nearest neighbor graph</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> buildSpatialGraph<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;knn&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;knn_spatialcontext_graph&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> k <span class=\"operator\">=</span> <span class=\"number\">40</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the fraction of cellular neighborhoods around each cell</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> aggregateNeighbors<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;knn_spatialcontext_graph&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> aggregate_by <span class=\"operator\">=</span> <span class=\"string\">&quot;metadata&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> count_by <span class=\"operator\">=</span> <span class=\"string\">&quot;cn_celltypes&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;aggregatedNeighborhood&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Detect spatial contexts</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> detectSpatialContext<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> entry <span class=\"operator\">=</span> <span class=\"string\">&quot;aggregatedNeighborhood&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> threshold <span class=\"operator\">=</span> <span class=\"number\">0.90</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Filter out small and infrequent spatial contexts</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> filterSpatialContext<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> entry <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_threshold <span class=\"operator\">=</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> cells_threshold <span class=\"operator\">=</span> <span class=\"number\">100</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context_filtered&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize cell location colored by their spatial context</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context_filtered&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize spatial contexts as graph</span></span><br><span class=\"line\">plotSpatialContext<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> entry <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context_filtered&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;n_cells&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_by <span class=\"operator\">=</span> <span class=\"string\">&quot;n_group&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_label_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;n_cells&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_viridis<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"34\">\n<li>按照Hoch等人11的提议执行斑块检测分析（图20）。imcRtools包的patchDetection函数检测感兴趣细胞的完全连接成分，在每个成分周围构造凹包，并将此凹包扩展以包含相邻细胞。在下文中，我们检测包含至少十个细胞的连接肿瘤成分，并稍微扩展凹包以包含斑块内的细胞。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spe <span class=\"operator\">&lt;-</span> patchDetection<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> patch_cells <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>celltype <span class=\"operator\">==</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> expand_by <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> min_patch_size <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;neighborhood&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;patch_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>legend.position <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_manual<span class=\"punctuation\">(</span>values <span class=\"operator\">=</span> rev<span class=\"punctuation\">(</span>colors<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"35\">\n<li>按照Schapiro等人18的提议执行相互作用分析（图21）。该方法检测与细胞表型的随机分布相比表现出更强（“相互作用”）或更弱（“避免”）共定位的细胞表型对。使用先前构建的空间细胞图（此处为使用steinbock创建的图），imcRtools包的testInteraction函数计算每幅图像中每对细胞表型的平均相互作用次数，并将其与通过随机置换所有细胞标签获得的经验空分布进行比较。返回的数据框包含每幅图像中每对细胞表型的一个条目，指示经验P值和统计显著性（相互作用：1；无显著性：0；避免：-1）。这些显著性值可以跨所有图像求和，并以热图的形式可视化。我们观察到，肿瘤细胞大多被分隔开，并与其他细胞类型相互避免，而调节性T细胞则位于CD4+ T细胞和CD8+ T细胞旁边。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig20.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig20.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图20 | 空间斑块检测。检测出肿瘤细胞的完全连接成分以及位于肿瘤斑块内的细胞。每个细胞根据其斑块标识符进行着色。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig21.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig21.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图21 | 细胞-细胞相互作用测试。热图显示了所有图像中每对细胞表型的显著性值之和。每幅图像和每对细胞表型的显著性值定义如下：1表示相互作用的细胞表型（红色）；0表示无相互作用或避免（白色）；-1表示细胞表型之间的避免（蓝色）。这些显著性值在所有14幅图像中相加，得出的可能范围在-14到14之间。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scales<span class=\"punctuation\">)</span></span><br><span class=\"line\">out <span class=\"operator\">&lt;-</span> testInteractions<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> label <span class=\"operator\">=</span> <span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;neighborhood&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BPPARAM <span class=\"operator\">=</span> SerialParam<span class=\"punctuation\">(</span>RNGseed <span class=\"operator\">=</span> <span class=\"number\">221029</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Sum interaction values across all images</span></span><br><span class=\"line\">summed_sigvals <span class=\"operator\">&lt;-</span> out <span class=\"operator\">%&gt;%</span> as_tibble<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> group_by<span class=\"punctuation\">(</span>from_label<span class=\"punctuation\">,</span> to_label<span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> summarize<span class=\"punctuation\">(</span>sum_sigval <span class=\"operator\">=</span> <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>sigval<span class=\"punctuation\">,</span> na.rm <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize summed interaction values in form of a heatmap</span></span><br><span class=\"line\">ggplot<span class=\"punctuation\">(</span>summed_sigvals<span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> geom_tile<span class=\"punctuation\">(</span>aes<span class=\"punctuation\">(</span>from_label<span class=\"punctuation\">,</span> to_label<span class=\"punctuation\">,</span> fill <span class=\"operator\">=</span> sum_sigval<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_fill_gradient2<span class=\"punctuation\">(</span>low <span class=\"operator\">=</span> muted<span class=\"punctuation\">(</span><span class=\"string\">&quot;blue&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> mid <span class=\"operator\">=</span> <span class=\"string\">&quot;white&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> high <span class=\"operator\">=</span> muted<span class=\"punctuation\">(</span><span class=\"string\">&quot;red&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>axis.text.x <span class=\"operator\">=</span> element_text<span class=\"punctuation\">(</span>angle <span class=\"operator\">=</span> <span class=\"number\">45</span><span class=\"punctuation\">,</span> hjust <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>Windhager J , Zanotelli V R T , Schulz D ,et al.An end-to-end workflow for multiplexed image processing and analysis[J].Nature Protocols, 2023, 18(11).DOI:10.1038&#x2F;s41596-023-00881-0.</li>\n</ul>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"生物信息","path":"api/categories/生物信息.json"}],"tags":[{"name":"图像识别","path":"api/tags/图像识别.json"},{"name":"单细胞测序","path":"api/tags/单细胞测序.json"}]}]}