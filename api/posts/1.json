{"total":146,"pageSize":10,"pageCount":15,"data":[{"title":"基因组语言模型的机遇与挑战","slug":"基因组语言模型的机遇与挑战","date":"2025-11-11T15:08:16.000Z","updated":"2025-11-11T15:11:03.321Z","comments":true,"path":"api/articles/基因组语言模型的机遇与挑战.json","excerpt":null,"keywords":null,"cover":"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig01.png","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>大型语言模型（LLMs）正在对广泛的科学领域产生变革性影响，尤其是在生物医学领域。正如自然语言处理（NLP）的目标是理解单词序列一样，生物学的一个主要目标是理解生物序列。基因组语言模型（gLMs）是在DNA序列上训练的大型语言模型，有望显著增进我们对基因组的理解，以及不同尺度的DNA元件如何相互作用以产生复杂功能。为展示这一潜力，我们重点介绍了基因组语言模型的关键应用，包括<code>功能约束预测</code>、<code>序列设计</code>和<code>迁移学习</code>。然而，尽管近期取得了显著进展，开发有效且高效的基因组语言模型仍面临诸多挑战，特别是对于具有大型复杂基因组的物种。在此，我们探讨了开发和评估基因组语言模型的主要考量因素。</p>\n<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h2><p>人工智能&#x2F;机器学习（AI&#x2F;ML）的最新进展对广泛的科学学科产生了深远影响，彻底改变了建模、数据分析、解释和发现的方法。这一发展的关键支柱之一是自监督学习，通过在大量未标记数据上进行训练，模型能够学习复杂特征及其相互作用。这种范式尤其改变了自然语言处理领域，使人工智能模型在多个具有挑战性的任务上达到人类水平，包括翻译、语音识别，甚至回答标准化专业和学术考试中的问题。</p>\n<p>正如自然语言处理的目标是理解自然语言序列一样，计算生物学的一个主要目标是理解生物序列。因此，近年来人们对将自然语言处理中的现代技术应用于生物序列（DNA、RNA、蛋白质）产生了浓厚兴趣。特别是，蛋白质序列数据库（如UniProt）在过去十年中呈指数级增长，在这些海量数据上训练的蛋白质语言模型（pLMs）在复杂问题上取得了令人印象深刻的性能，例如结构预测和变异效应预测等记的蛋白质序列数据集有望包含重要的生物信息。</p>\n<p>类似地，在DNA序列上训练的大型语言模型（LLMs）有望改变基因组学，但为基因组开发有效的模型面临额外的挑战。例如，与作为功能重要单元且尺寸相对较小的蛋白质不同，大多数基因组要大得多，并且通常包含大量复杂的非功能区域，这些区域在数量上超过了功能元件。此外，与数亿个蛋白质序列相比，整个生命树中可用的全基因组序列数量极少，这限制了训练数据中功能重要的DNA元件的多样性。尽管存在这些问题，我们认为在基因组上训练的语言模型——即基因组语言模型（gLMs）——对生物学具有巨大潜力。在本文中，我们回顾了该领域的一些关键机遇和挑战，<u>并概述了开发和评估对基因组学界有用的基因组语言模型应解决的主要考量因素</u>。</p>\n<h2 id=\"2-应用\"><a href=\"#2-应用\" class=\"headerlink\" title=\"2 应用\"></a>2 应用</h2><p>语言模型的通用框架总结在<code>BOX 1</code>中。下面，我们详细阐述基因组语言模型的三个主要应用领域：功能约束预测、序列设计和迁移学习。</p>\n<h3 id=\"2-1-功能约束预测\"><a href=\"#2-1-功能约束预测\" class=\"headerlink\" title=\"2.1 功能约束预测\"></a>2.1 功能约束预测</h3><p>基因组语言模型一个有趣的应用是在无需任何任务监督的情况下预测基因组位点的功能约束。这种方法的一个显著优势是它不依赖于标记（例如某个变异是否致病），而标记通常数量有限且存在偏差。其核心思想是，参考基因组（通常来自健康个体）中有害变异的含量相对较低。因此，在这些数据上训练的模型倾向于给有害变异分配较低的概率。这一观察结果为使用<strong>两个等位基因之间的对数似然比</strong>（LLR）——即$(\\log[\\mathbb{P}(X_{i}&#x3D;a|X_{-i})&#x2F;\\mathbb{P}(X_{i}&#x3D;b|X_{-i})])$——来估计它们的相对适应性提供了依据。</p>\n<p><font size=2 color='grey'><strong>BOX 1</strong>：通用语言模型框架</p>\n<p>从高层次来看，语言模型的训练目标是学习如下形式的条件概率分布：</p>\n<p>在掩码语言建模（MLM）中为 $(\\mathbb{P}[X_{i}|X_{- \\text{Masked}}])$（其中$(i \\in \\text{Masked})$），在因果语言建模（CLM）中为 $(\\mathbb{P}[X_{k}|X_{1:k-1}])$。这里，$(X&#x3D;(X_{1},X_{2},\\dots))$ 表示“标记”（如核苷酸或氨基酸）序列，“Masked”表示被掩码的位置集合。自然语言处理近期取得进展的关键在于，不再手动设计简单的上下文依赖参数模型，而是让数据自己说话，并通过利用强大的深度学习架构，随着观测数据的增加来拟合更复杂的模型。图1展示了用于DNA的语言建模框架。虽然模型训练的目的是利用未掩码位点的信息预测每个掩码位点的核苷酸，但它会学习位置特异性的上下文表示（称为嵌入，即一个高维向量），随后该向量会转换为在 ${A,C,G,T}$ 上的概率分布。这些嵌入和概率分布均具有位置特异性，可应用于基因组学中的许多问题。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig01.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig01.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1：基因组语言模型的训练和应用\"></p>\n<p><font size=2 color='grey'>左侧示意图展示了基因组语言模型的训练过程。两个等位基因之间的对数似然比（LLR，具体为$(\\log[\\mathbb{P}(X_{i}&#x3D;a|X_{-i})&#x2F;\\mathbb{P}(X_{i}&#x3D;b|X_{-i})])$）是功能约束的良好无监督预测因子（功能约束预测）。通过从学习到的概率分布中采样，可以生成新的序列（序列设计）。输入序列中每个标记的向量表示（称为嵌入）可以被提取出来，并适配于不同的下游任务（迁移学习）。</font></p>\n<p>在蛋白质序列模型中，最初引入了使用对数似然比进行功能约束预测的方法，在预测错义变异效应方面取得了出色成果。将这种方法扩展到基因组范围，GPN首次使用基因组语言模型进行全基因组功能约束预测，在模式植物拟南芥（<em>Arabidopsis thaliana</em>）中取得了最先进的结果。为说明基因组语言模型如何预测功能约束，我们注意到基因组语言模型能够学习<code>转录因子结合位点（TFBS）基序</code>，理解哪些位置受到约束，哪些位置不受约束（<strong>图2a</strong>）。此外，尽管<code>GPN</code>模型仅在拟南芥的一个基因组上训练，但它的对数似然比得分与拟南芥自然种群中的等位基因频率相关（<strong>图2b</strong>）。随后，<code>AgroNT</code>和<code>PlantCaduceus</code>在其他植物物种中也取得了优异结果。然而，对于人类基因组，核苷酸转换器（NT）的对数似然比性能低于现有的基准模型。与此同时，<code>GPNMSA</code>利用跨多种脊椎动物物种的全基因组多序列比对（MSA），实现了最先进的性能。需要注意的是，<u>观察到的核苷酸分布不仅受功能约束驱动，还受突变偏差影响；将此信息明确纳入功能约束预测是未来研究的一个有前景的方向</u>。</p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig02.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig02.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2：应用示例\"></p>\n<p><font size=2 color='grey'>（a）基因组语言模型在启动子区域预测的序列标志图（顶部），突出显示了与假定功能性转录因子结合位点匹配的基序（底部序列标志图）。（b）变异次要等位基因频率（MAF）与基因组语言模型得分（对数似然比）之间的相关性。（c）基因组语言模型可以用不同的控制标签提示，设计在特定细胞类型中驱动高表达或低表达的启动子序列。（d）不同基因组窗口类别的基因组语言模型嵌入可视化，表明学习到的表示包含有用信息，如基因区域。注：面板a、b、d使用GPN模型生成。</font></p>\n<p>对于单核苷酸多态性（SNP），在掩码语言模型中只需对变异位置进行一次掩码查询即可计算对数似然比，而在因果语言模型中则需要对参考序列和替代序列进行两次查询。因果语言模型可以轻松处理多个替换、插入和缺失，而掩码语言模型必须采用更耗时的伪对数似然比方法。除对数似然比外，还提出了其他用于功能约束预测的得分，例如嵌入空间中的距离或突变周围位置核苷酸概率的变化。尽管对数似然比在蛋白质语言模型和基因组语言模型领域都被广泛使用，但深入理解这些替代得分在哪些场景下有用仍然很重要。</p>\n<p>基因组学中有两类主要的变异效应预测器：<strong>一类是功能约束预测器</strong>，包括基因组语言模型和传统的保守性得分；<strong>另一类是活性预测器</strong>，如基因表达预测器<code>Enformer</code>或剪接预测器<code>SpliceAI</code>。这两类模型存在关联：如果某个位点的变异受到选择，它会在某些情况下诱导活性变化（例如，在肢体发育过程中某个基因的转录变化），最终影响高级性状（例如，多指畸形）。功能约束模型涵盖了影响整体生物体适应性的所有可能机制和场景，而活性模型仅反映了它们明确训练过的机制和场景（某些数据，如人类大脑发育过程中的蛋白质表达，获取难度较大）。另一方面，活性模型可以指出变异发挥作用的特定机制和场景，而功能约束模型则不提供机制解释。</p>\n<p>关于功能性变异的优先排序，还有一些额外的考量。对于两个在不同基因中引起相似表达倍数变化的变异，即使它们的表达水平在生理耐受性上存在巨大差异，活性模型通常也会给出相似的得分。另一方面，不受可检测选择影响的性状仍可能具有科学或医学意义。在这种情况下，功能约束模型在优先排序影响该性状的变异方面能力有限，尤其是当这些变异效应量较小时（如在复杂性状全基因组关联研究（GWAS）中常见的情况）。然而，尽管基因组语言模型的对数似然比在这种情况下可能效果不佳，但基因组语言模型学习到的嵌入（<strong>BOX 1</strong>）在有标记数据的额外监督下仍可能具有价值。</p>\n<h3 id=\"2-2-序列设计\"><a href=\"#2-2-序列设计\" class=\"headerlink\" title=\"2.2 序列设计\"></a>2.2 序列设计</h3><p>设计新的生物序列对学术界和工业界研究团体都极具吸引力，因为它在药物发现与递送、农业改良、生物修复以及生物研究工具开发等方面具有巨大潜力。在此，我们描述使用<code>因果语言模型</code>（<strong>BOX 1</strong>）进行序列生成的方法，这是最常用的方法。具体而言，序列生成任务被分解为一系列下一个标记预测问题。从给定的序列片段（称为提示或控制标签）开始，语言模型可以递归地预测下一个标记，从而生成完整的新序列。蛋白质语言模型已被证明是蛋白质设计的强大工具。除编码序列外，非编码序列的设计也至关重要，因为它在基因和细胞治疗以及合成生物学等领域有应用。此类设计任务以前通过有监督的活性模型解决，但最近有多项研究探索使用基因组语言模型来应对这一挑战，如下所述。</p>\n<p><code>regLM</code>模型基于因果基因组语言模型<code>HyenaDNA</code>构建，用于<strong>从头生成启动子和增强子序列</strong>。HyenaDNA模型在带有前置控制标签的调控序列上进行训练或微调。然后，使用训练好的模型生成带有给定标签的新调控序列（<strong>图2c</strong>）。作者在酵母和人类细胞系中对生成序列的多样性和活性进行了计算评估，证明这些序列具有预期的功能以及真实且多样的序列特征。</p>\n<p>基因组语言模型在多模态设计任务中具有独特潜力，例如通过将蛋白质-RNA复合物统一为DNA序列设计来生成此类复合物。<u>例如，在原核生物基因组上训练的基因组语言模型EVO被用于设计新的CRISPR-Cas系统</u>。该模型使用带有前置Cas亚型特异性提示的CRISPR-Cas序列数据集进行微调。微调后的模型能够生成与亚型提示匹配的新CRISPR-Cas序列，且其预测结构与天然存在的系统相似。</p>\n<p>此外，<u>基因组语言模型还有可能用于在染色体或基因组尺度上设计有组织的功能性DNA序列</u>。最近，两个基因组语言模型<code>MegaDNA</code>和<code>EVO</code>探索了原核生物基因组的此类设计任务。EVO用于生成20个约650 Mbp大小的序列。研究发现，生成的序列具有真实的编码序列密度、具有预测二级结构和球状折叠的蛋白质序列，以及合理的tRNA序列。MegaDNA用于生成长达96 kbp的完整噬菌体基因组。除验证编码序列外，作者还在生成的序列中识别出包括启动子和核糖体结合位点在内的功能性调控元件。然而，此类大规模DNA序列设计任务仍然具有挑战性。研究发现，<u>EVO生成的序列缺乏功能原核生物基因组中通常存在的高度保守标记基因，且预测的蛋白质结构与天然蛋白质数据库的匹配度有限。最近的一项独立评估表明，MegaDNA生成的基因组序列组成与天然基因组仍有很大差异</u>。因此，需要进一步研究改进方法，以实现使用基因组语言模型从头设计完全功能性的基因组。</p>\n<h3 id=\"2-3-迁移学习\"><a href=\"#2-3-迁移学习\" class=\"headerlink\" title=\"2.3 迁移学习\"></a>2.3 迁移学习</h3><p>通过功能基因组学实验训练的用于预测注释的神经网络已被广泛用于解释基因组元件的功能。<u>一个重要的应用是预测变异对分子表型的影响，例如基因表达和剪接</u>。神经网络能够解释基因组位点之间复杂相互作用的能力，使其成为解决这些重要问题的必备工具，但合适的训练数据通常难以收集，因此数量有限。为了在预测任务上实现泛化，模型需要能够识别广泛的功能重要序列元件，这可能需要大量的数据和计算资源。为克服单个任务数据不足的限制，开发者采用了迁移学习方法——即利用在一个任务上训练模型获得的知识来改进相关任务性能的技术。具体而言，大多数用于预测功能注释的神经网络都经过训练以同时预测多种注释，迫使这些模型学习单一的统一表示。这进而提高了它们的泛化性能。</p>\n<p>语言模型也可用于迁移学习（有关迁移学习在自然语言处理中的应用，请参见<strong>BOX 2</strong>）。一种技术是特征提取：在学习预测核苷酸的上下文依赖分布时，基因组语言模型将输入的基因组序列转换为中间向量表示<strong>BOX 1</strong>）。这些表示可能提炼了相关信息，因此可用作另一个模型的特征。例如，<u>基因组语言模型嵌入的可视化显示，在没有任何监督的情况下，模型已经学会区分不同类别的基因组元件，如编码序列和非翻译区（<strong>图2d</strong>）</u>。不同层的嵌入可以为不同任务提供有用信息。利用语言模型进行迁移学习的另一种方法是将其用作预训练模型，即在下游任务上继续训练它们。这种技术称为微调。在某个任务上微调预训练的神经网络，会隐式地对其参数进行正则化，使得网络的预测综合了来自两个任务的知识。因此，对神经网络进行预训练通常会提高其在下游任务上的泛化性能。在最近的研究中，<code>SegmentNT</code>模型（通过微调核苷酸转换器（NT）基因组语言模型以实现<strong>基因和顺式调控元件注释</strong>任务而开发）在该任务上取得了最先进的性能。研究表明，使用预训练模型是其取得成功的关键。类似地，NT家族的另一个模型<code>AgroNT</code>在多种植物物种上进行预训练，然后在选定的作物物种上微调以预测染色质可及性和基因表达。<code>DNABERT-S</code>将对比学习与预训练的<code>DNABERT-2</code>嵌入相结合，用于<strong>宏基因组分箱</strong>。<code>IsoFormer</code>是DNA和蛋白质语言模型之间多模态迁移学习的一个例子，用于<strong>预测转录本亚型表达</strong>。这些最近的成功表明，微调后的基因组语言模型可能在各种基因组解释任务上取得显著进展。</p>\n<p>最近有两项研究评估了多个基因组语言模型在人类基因组预测任务中的性能，发现它们通常不会优于非基因组语言模型基准。这些结果基于冻结的嵌入；评估完整的微调过程将提供更多见解。尽管基因组语言模型已经非常适合展示迁移学习在研究较少的生物体中的价值，但要使其在人类遗传学（已有高质量标记数据和精心设计的模型）中提供显著价值，可能还需要进一步的创新。一个重要的问题是，缩放假设对基因组语言模型的适用程度如何，即增加未标记数据和计算资源在多大程度上能持续提高模型性能。最近的一项蛋白质语言模型研究发现，缩放仅改进了蛋白质结构预测，而没有改进大多数其他任务（如功能或性质预测），因此基因组语言模型任务也应受到同样的审视。</p>\n<p><font size=2 color='grey'> <strong>BOX 2</strong>：自然语言处理中的迁移学习<br>为了在大多数任务（包括情感分析、问答和词性标注等典型任务）上实现泛化，自然语言处理模型需要理解语法和语义。然而，这些任务的特定数据通常有限。利用在原始文本数据（来源于文章、书籍和网站）上训练的大型语言模型进行迁移学习，已在这些问题上取得了突破性进展。如今，几乎所有最先进的自然语言处理模型都是从大型语言模型改编而来。</font></p>\n<p>迁移学习技术是近年来自然语言模型蓬勃发展的基础。特别是，可广泛适配于下游任务的预训练模型（称为“基础模型”）的出现，使得机器学习模型的开发方式发生了重大转变。</p>\n<h2 id=\"3-开发\"><a href=\"#3-开发\" class=\"headerlink\" title=\"3 开发\"></a>3 开发</h2><p>现在，我们描述开发有用的基因组语言模型的关键组成部分；<strong>图3</strong>展示了总结开发流程的示意图。我们首先阐述选择和准备训练数据的重要性，然后讨论架构和训练决策，接着考虑基因组语言模型的解释和基准测试。我们的目标是<u>深入了解开发有效且高效的基因组语言模型所涉及的方法和挑战</u>。为全面展示该领域的当前状况，我们在<strong>表1</strong>中列出了一些我们已知的现有基因组语言模型，并总结了它们的设计决策。</p>\n<h3 id=\"3-1-训练数据\"><a href=\"#3-1-训练数据\" class=\"headerlink\" title=\"3.1 训练数据\"></a>3.1 训练数据</h3><p>机器学习模型的性能在很大程度上受其架构和训练数据的影响。卷积神经网络（CNNs）、Transformer 和状态空间模型（SSMs）等各种模型架构已成功应用于广泛的领域，包括自然语言、图像、音频、蛋白质和基因组学。然而，为预训练选择合适的数据需要对特定领域有深入的理解，尤其是<u>在基因组学领域，目前尚无类似于自然语言处理（如Pile）或蛋白质生物学（如UniProt）中那样被普遍接受的精选数据集</u>。</p>\n<p><strong>一个关键的考量因素是数据质量</strong>。例如，在自然语言处理中，数据质量可能指经过编辑或同行评审的数据源，如科学文章或书籍。<u>在蛋白质领域，质量控制包括去除预测的假基因或不再具有功能的截断蛋白质</u>。然而，最近的一项研究发现，作为最常用的基因组语言模型训练数据集（<strong>表1</strong>）的人类参考基因组中，仅有3.3%的碱基受到显著约束且可能具有功能。重要的是，<u>用于训练基因组语言模型的典型基因组序列既包含<code>功能位点</code>，也包含<code>非功能位点</code>，且通常无法将训练样本明确分为<code>高质量</code>和<code>低质量</code>两类</u>。一个提出的解决方案是根据功能证据对训练损失进行碱基级加权。</p>\n<p>在自然语言处理和蛋白质领域，<strong>过滤重复序列</strong>是标准做法，这有助于提高训练效率并减少记忆。尽管人类基因组中高达50%的序列是重复序列（在真核生物中这一比例普遍较高），但很少有基因组语言模型研究提出解决方案（如降低权重或下采样），甚至很少有研究承认这一问题。如果语言模型困惑度的研究也能分别报告非重复区域的困惑度，以区分泛化改进和记忆改进，那将很有启发意义。</p>\n<p><strong>另一个关键问题是如何确保数据量充足</strong>。单个基因组可能不足以训练大型模型，尤其是当非功能区域被下采样或降低权重时。一种方法是添加同一物种的序列变异。然而，在包括人类在内的许多物种中，个体之间的变异相对较少。更常用的方法是<code>跨多个物种进行训练</code>（<strong>表1</strong>），这与蛋白质语言模型的做法类似。随着物种亲缘关系的疏远，调控逻辑的分化速度快于蛋白质。一种提出的方法是<strong>将物种标识符作为额外输入明确添加到模型中</strong>。尽管如此，一个足够大的模型，在有足够基因组上下文的情况下，仍有可能自然地对远缘基因组进行建模，类似于大型语言模型处理多语言数据集的方式。</p>\n<p>如前所述，在原核生物中，已有模型（MegaDNA和EVO）将整个基因组作为上下文。目前，这在真核生物中还不可行，因此产生了<strong>如何将基因组划分为可单独建模的上下文窗口的问题</strong>。许多相互作用局限于邻近位置（如转录因子结合位点基序），这推动了具有相对较小上下文（&lt;6 kb）的模型的开发（**表1**）。然而，也存在明显的长程相互作用，例如同一基因的外显子之间或增强子与启动子之间（可达1 Mb）。如此长的上下文长度带来了计算和统计挑战，研究人员已在努力克服这些挑战。无论选择何种上下文长度，将基因组划分为独立单元（类似于按蛋白质划分蛋白质组的方式）仍然并非易事。例如，<u>一个基因的增强子可能位于另一个基因的内含子中，且多个基因可能由同一个增强子调控。尤其是在跨物种训练时，避免因直系同源和旁系同源导致的数据泄露非常具有挑战性</u>。</p>\n<p>训练数据的选择可能会显著影响基因组语言模型的输出和学习到的表示。自然界中观察到的DNA序列是各种进化过程的结果，其中最主要的是突变和选择。对于某些应用，可能需要精心选择训练数据，以突出这些过程中的某一个。例如，为了进行适应性预测，可能需要排除&#x2F;降低高突变位点（如CpG位点）和非功能区域（如某些类型的重复元件）的权重。</p>\n<h3 id=\"3-2-模型架构\"><a href=\"#3-2-模型架构\" class=\"headerlink\" title=\"3.2 模型架构\"></a>3.2 模型架构</h3><p>在Transformer架构出现之前，<code>卷积神经网络</code>模型已被广泛用于基因组学中的有监督任务。卷积神经网络通过对输入数据应用<code>过滤器</code>，特别<u>擅长捕捉基因组序列中的局部依赖关系和基序</u>。这些模型在预测<strong>DNA-蛋白质结合位点</strong>、<strong>调控元件</strong>和<strong>转录因子结合位点</strong>方面取得了成功。前面提到的用于拟南芥全基因组变异效应预测的基因组语言模型GPN，借鉴了自然语言处理和蛋白质建模中带有改进卷积神经网络层的语言模型的成功经验，用<code>扩张卷积神经网络层</code>替换了Transformer<code>编码器中的自注意力层</code>。</p>\n<p><code>Transformer</code>模型彻底改变了各种机器学习领域，尤其是自然语言处理，并且最近被广泛应用于基因组学建模。自注意力机制允许每个标记同时关注输入序列中的所有位置，使模型能够动态关注序列的相关部分。这种能力在有监督的基因表达任务中检测调控机制方面取得了显著进展。</p>\n<p>尽管Transformer模型具有优势，但它们在基因组学建模中面临一些独特的<strong>挑战</strong>。一个重要问题是，<u>Transformer对相互作用的局部性几乎没有或没有归纳偏置，这使得它们在建模转录因子结合位点等局部基序时数据效率较低</u>。这促使人们开发<strong>卷积神经网络-Transformer混合模型</strong>，如<code>LOGO</code>，其借鉴了<code>Enformer</code>等有监督模型的思路。</p>\n<p><strong>另一个挑战是上下文长度</strong>：自注意力机制导致<strong>计算时间和内存随输入序列长度呈二次方增长</strong>，这使得将Transformer应用于极长的基因组序列变得不切实际。因此，传统基于注意力的基因组语言模型目前能够处理的最长输入长度是<code>NT-v2的12 kb</code>。为解决这一限制，一些基于Transformer的基因组语言模型采用了<code>近似注意力</code>或<code>分层注意力</code>方法，牺牲了所有标记之间的完全成对注意力。这些方法包括在<code>GENA-LM</code>中使用稀疏注意力（将上下文长度扩展到<code>36 kb</code>），以及在<code>MegaDNA</code>中采用MEGABYTE亚二次方分层自注意力（实现<code>了96 kb</code>的上下文长度）。</p>\n<p>为克服自注意力的二次方缩放问题，人们提出了各种状态空间模型（SSMs）作为Transformer的高效替代方案，用于基因组语言模型，其<strong>计算复杂度随序列长度接近线性增长</strong>。基于·层次结构的<code>HyenaDNA</code>能够支持长达<code>100万</code>个核苷酸的输入上下文。<code>EVO</code>是一种结合了Hyena和Transformer架构的混合模型，在8 kb序列上进行预训练，然后在上下文扩展阶段使用<code>131 kb</code>序列进行微调。基于Mamba的状态空间模型构建的<code>Caduceus</code>在<code>131 kb</code>序列上进行训练，同时融入了反向互补等变。</p>\n<h3 id=\"3-3-学习目标\"><a href=\"#3-3-学习目标\" class=\"headerlink\" title=\"3.3 学习目标\"></a>3.3 学习目标</h3><p>如<strong>BOX 1</strong>所述，掩码语言模型（MLM）任务（有时也称为“掩码标记预测”）要求模型根据剩余标记预测以预定概率（通常为15%）随机掩码的标记身份。这一框架已用于训练开创性的大型语言模型BERT和蛋白质语言模型<code>ESM-1b</code>，此后被广泛用于训练基因组语言模型。因果语言模型（CLM）任务（也称为“自回归语言建模”或“下一个标记预测”）要求模型根据前面的标记预测序列中的标记；该任务已用于训练GPT系列大型语言模型。在该任务中，模型以单向从左到右的顺序，根据前面的标记预测下一个标记。这两个任务的共同点是，它们都要求模型根据其他组件作为上下文来预测数据的组件。为了在这些任务上实现泛化，模型必须学习数据的低维表示。这种能力使基因组语言模型能够通过捕捉基因组内的潜在模式和依赖关系来理解和生成基因组序列。<u>在蛋白质建模中，掩码语言模型在表示学习和迁移学习能力方面通常优于因果语言模型</u>。另一方面，因果语言模型是生成任务的传统选择，但最近通过渐进式掩码，掩码语言模型在生成任务上也取得了优异结果。</p>\n<p>为减少输入序列长度并建模更长的上下文，k-mer和字节对编码（BPE）创建了比天然核苷酸词汇表（{A,C,G,T}）更大的人工定义核苷酸词汇表。另一方面，单核苷酸标记化简化了模型解释和归因，并增强了模型处理基因组变异的能力。</p>\n<p>研究人员探索了对训练目标的多种修改，以提供额外的信号并提高性能。例如，<code>GPN-MSA</code>通过脊椎动物物种的全基因组多序列比对（MSA）增强了在人类参考基因组上的掩码语言模型训练，利用相关物种间的保守性获取额外上下文。其局限性在于，全基因组多序列比对仅针对某些物种生成，要在植物中有效应用可能需要进一步开发。此外，即使顺式调控元件的活性保守，其序列也可能快速分化，这限制了通过比对提取的直系同源信息。<code>Species LM</code>通过为每个酵母物种分配一个专用标记，并在训练和推理期间将物种标记附加到输入序列，直接整合了物种信息。核苷酸序列的预训练已扩展到支持与其他模态的交互，如表观遗传学、RNA、蛋白质和自然语言。</p>\n<h3 id=\"3-4-解释\"><a href=\"#3-4-解释\" class=\"headerlink\" title=\"3.4 解释\"></a>3.4 解释</h3><p>尽管深度学习模型在各种预测任务中取得了显著性能，但它们通常缺乏可解释性，常被视为“黑箱”。然而，理解这些模型如何生成预测对于实现更广泛的应用和推进模型开发至关重要。因此，研究人员开发了一系列解释深度学习模型的方法，包括专门针对基因组学的方法。尽管基因组语言模型的解释仍是一个新兴的研究方向，但已有研究表明，一些模型已经学习到了有意义的生物模式。</p>\n<p>从语言模型中提取的序列嵌入通常被用作捕捉丰富上下文信息和序列特征的表示。<u>对基因组语言模型编码的序列嵌入进行无监督聚类，发现输入序列形成了对应于不同基因组类别（如编码序列、内含子、非翻译区等）的明显聚类</u>（<strong>图2d</strong>）。此外，<u>对<code>SpliceBERT</code>嵌入的典型剪接位点和非剪接GT&#x2F;AG位点进行无监督聚类，发现了对应于这两组位点的明显聚类</u>。这些结果表明，模型已经学会捕捉表征基因组中功能元件的关键上下文模式。</p>\n<p>Transformer模型中的注意力机制旨在捕捉输入标记之间的交互模式。因此，解释给定输入序列的注意力权重或注意力图，可以揭示模型学习到的基因组特征。<u>在SpliceBERT中，剪接供体位点和受体位点之间的注意力权重显著高于随机位点对之间的注意力权重；此外，真实供体-受体对之间的交互强度往往高于其他供体和受体位点组合</u>。这些发现表明，模型已经学会了功能交互位点之间的关系。</p>\n<p>一些基因组语言模型还采用核苷酸重建方法来发现模型学习到的序列基序。具体而言，将输入序列的各个位置逐一掩码，然后由训练好的模型根据基因组上下文预测核苷酸的概率分布。每个位点获得的分布可以揭示模型学习到的基序。GPN中采用了这种方法，在重建核苷酸的分布中发现了显著模式。特别是，<strong>模型在功能重要位点的预测通常更有信心</strong>。例如，编码序列和剪接供体&#x2F;受体位点的预测信心通常高于深层内含子位点。此外，在编码序列中，密码子的第三个核苷酸位置（对翻译的氨基酸决定作用最小）的预测信心通常低于前两个核苷酸位置。通过适配<code>TF-MoDISco</code>（一种利用模型预测识别新转录因子结合位点的专用工具），作者还发现了与转录因子结合位点数据库和相关文献中已知基序匹配的序列基序（<strong>图2a</strong>）。类似地，Species LM重建的序列基序也与训练中未见过的物种中已知的DNA和RNA结合蛋白的结合位点匹配，基序重建的准确性取决于正确反映体内结合位点的上下文和基因组区域。此外，重建基序的组成、存在和位置表现出物种特异性模式，这表明<u>基因组语言模型可能成为研究序列基序和调控密码进化的强大工具</u>。</p>\n<p>最近，研究人员通过在某个位置引入点突变并量化其他位置核苷酸概率的变化，研究了基因组语言模型学习到的基因组位置之间的依赖关系。核苷酸依赖分析揭示了模型学习到的功能元件（如转录因子结合位点、剪接位点和RNA）内部和之间的相互作用，包括已知的二级和三级结构接触。值得注意的是，与之前基于预测边际概率分布的方法相比，核苷酸依赖分析能够更稳健地检测结合的转录因子结合位点。</p>\n<h3 id=\"3-5-评估\"><a href=\"#3-5-评估\" class=\"headerlink\" title=\"3.5 评估\"></a>3.5 评估</h3><p>在本节中，我们将讨论如何针对前面描述的三个应用领域对模型性能进行基准测试：预测等位基因的功能约束、生成新的可行序列以及迁移学习。</p>\n<p>有多种类型的数据可以反映等位基因的功能约束，可用于基准测试变异效应预测器。<strong>一类</strong>数据来自将<code>遗传变异的功能差异与读数</code>(readouts)（如报告基因的表达或细胞生长）相关联的实验。这些读数可用于对变异的功能性进行排序，由于影响功能的变异通常也受到选择，因此我们期望这些排序与模型预测的排序相关。这类数据的一个来源是<code>ProteinGym</code>，这是一个广泛使用的实验数据集集合，可用于基准测试错义变异效应预测器。<strong>另一类</strong>数据是<code>临床标记</code>，指示变异是否有致病证据（即是否会增加疾病风险）。致病性变异可能影响生育能力，因此可能具有有害性。因此，我们可以通过评估变异效应预测器作为致病性分类器的性能来对其进行基准测试。在人类遗传学中，变异临床标记的主要来源包括<code>ClinVar</code>、<code>HGMD</code>和<code>OMIM</code>数据库。<strong>第三类</strong>数据是<code>变异频率</code>。由于常见变异不太可能具有高度有害性，它们的预测约束水平应相对高于罕见变异。因此，我们可以根据预测器识别常见变异的能力对其进行基准测试。人类不同祖先群体中等位基因频率数据的主要来源是<code>gnomAD</code>数据库。总之，这些数据可以作为模型泛化性能的独立证据。</p>\n<p>变异效应预测器评估的一个问题是，验证数据与功能约束之间的关系可能不明确。因此，模型可能通过利用数据未能捕捉功能约束的方面在基准测试中表现出色。例如，使用临床标记的一个关键问题是，变异的分类基于是否有充分证据证明它们是良性的或致病性的。由于预测器也可能利用这些证据，它们在标记变异上的基准测试性能可能无法反映其在未标记变异上的真实性能（有关泛化性能的简要讨论，请参见<strong>BOX 3</strong>）。使用等位基因频率数据也存在关键问题：例如，除自然选择的直接作用外，等位基因频率还受突变率、遗传漂变、背景选择和遗传搭车等因素影响。因此，预测器可能通过预测这些过程的影响而非功能约束在基准测试中表现良好。这些问题凸显了需要仔细解释预测器性能原因的重要性，并促使人们呼吁提高预测器训练所使用的数据和方法的透明度。</p>\n<p>生成式序列模型的评估面临一系列独特挑战。评估语言模型生成能力的一种基本方法是比较它们在有效序列集上的困惑度。然而，要评估模型设计新序列的能力，需要衡量它们是否能够识别既可行又新颖的序列。因此，模型在测试集上的困惑度可能无法可靠地表明其在设计任务中的实用性。相反，可能需要采用全面的方法，检查生成序列的广泛特性。例如，最近用于调控序列设计的基准测试工具<code>Polygraph</code>提出了一系列分析方法，用于研究序列组成、基序模式和预测的功能活性。对于全基因组或染色体设计任务，可能还需要评估必需基因和功能性调控元件的存在和位置，以及它们之间的相互作用。最终，设计的序列需要通过实验评估，以确定它们是否能实现预期功能。</p>\n<p>最后，评估基因组语言模型在迁移学习中的性能面临一个独特挑战：任何基准测试集（可能需要结合多个基准测试集）都必须能够可靠地表明模型在相关任务上的性能。功能基因组学数据（如来自ENCODE或Roadmap表观基因组学项目的数据）可用于注释基因组区域和变异，这类数据可构建一系列任务，广泛反映模型适应基因组解释的能力。我们期望，模型在适应后从基因组序列预测这些注释的性能，能够表明其识别功能相似基因组元件的能力。为便于模型之间的比较，这些注释已被整合到各种标准化的训练和测试数据集集合中。</p>\n<p>由于迁移学习基准测试有助于凸显当前模型的局限性，并为发表建立标准，因此它们可能成为基因组语言模型开发者和用户的重要资产。然而，尽管当前基准测试在任务选择和方法上存在差异，但它们对基因组语言模型能力的见解似乎存在冗余。未来，计算基因组学界需要开发广泛认可的标准化且可扩展的基准测试。</p>\n<p><font size=2 color='grey'> <strong>BOX 3</strong>：评估泛化性能<br>评估预测模型的目的是建立对其泛化能力的信任，即对未标记数据做出令人满意的预测。估计模型泛化性能的一种直接且标准的方法是在代表目标未标记数据的标记“测试集”上评估其准确性。这种方法是大多数机器学习基准测试的基础。</p>\n<p>重要的是，为使这种评估成为泛化性能的可靠指标，不得向模型提供任何可用于区分测试集数据和最终部署数据的信息。否则，模型可能会以牺牲泛化性能为代价降低测试集误差。因此，通常会组织向参与者隐瞒测试数据的机器学习竞赛。<br></font></p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Table01.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Table01.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"表1：现有基因组语言模型总结\"></p>\n<p><font size=2 color='grey'>提供了各种基因组语言模型的概述，重点介绍了它们的预训练数据集、任务、架构、标记化方法和独特特征。模型按公开发布日期排序。缩写包括：SSM（状态空间模型）、CNN（卷积神经网络）、BPE（字节对编码）、CLM（因果语言建模）、MLM（掩码语言建模）。</font></p>\n<p><img src=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig03.png\" class=\"lazyload placeholder\" data-srcset=\"https://raw.githubusercontent.com/liaochenlanruo/cdn/master/images/post/BioAI/02/Fig03.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3：开发流程\"></p>\n<p><font size=2 color='grey'>该图展示了本综述中描述的基因组语言模型通用开发流程，从模型构思到部署。我们首先选择和准备训练数据集，强调数据质量和数量的重要性（训练数据）。随后，在模型架构和学习目标部分，我们探讨了设计和训练基因组语言模型的各种选择，讨论了不同方法的优缺点。我们还研究了混合模型如何结合多种架构的元素以缓解特定局限性。在解释部分，我们讨论了分析和解释基因组语言模型输出的方法。最后，在评估部分，我们通过当前基准测试介绍了评估方法，强调了使模型性能与实际生物功能保持一致的复杂性。</font></p>\n<h2 id=\"4-结论与未来展望\"><a href=\"#4-结论与未来展望\" class=\"headerlink\" title=\"4 结论与未来展望\"></a>4 结论与未来展望</h2><p>在基因组序列数量庞大且不断增长的时代，基因组语言模型正成为提取复杂模式的强大工具，可应用于功能约束估计、序列设计和迁移学习等多个领域。然而，正如“人工智能”一词可能暗示的那样，它们尚未实现神奇的突然突破。相反，我们将其视为另一种有用的建模工具，类似于隐马尔可夫模型刚出现时的情况。基因组语言模型通常被称为“基础模型”，这一术语最近被创造出来，指在广泛数据上训练、可适应各种下游任务的模型。这一新术语的引入受到了批评，因为“基础”一词意味着在下游任务性能上有显著改进，而这是一个实证问题，而非预训练模型的固有属性。在基因组学等新领域，这种批评更为强烈，因为建立足够的基准测试可能需要一些时间。</p>\n<p>早期的基因组语言模型或多或少是自然语言处理模型的直接改编，我们期望通过深入结合基因组学专业知识，能获得最大的收益。我们注意到，评估基因组语言模型的能力具有挑战性，因为指标可能具有误导性，尤其是在过度优化的情况下。自然语言处理的一个优势是人类是自然语言的专家，因此可以根据自身专业知识校准基准测试。然而，在基因组学中，我们必须依靠数据和专家知识来验证模型。问题的这一方面使其特别具有挑战性，并可能意味着需要与领域专家合作，并有意识地进行实验以开发基准测试。在本综述的最后，我们提出了一些我们认为值得进一步研究的方向（列于未解决的问题中）。</p>\n<h3 id=\"未解决的问题\"><a href=\"#未解决的问题\" class=\"headerlink\" title=\"未解决的问题\"></a>未解决的问题</h3><ol>\n<li>如何最好地对从基序到基因再到全基因组的各种尺度模式进行建模？</li>\n<li>哪些应用需要对长程相互作用进行建模？如何确定合适的感受野大小？</li>\n<li>如何将结构变异纳入基因组语言模型？</li>\n<li>训练基因组语言模型时，利用群体遗传数据的最佳方式是什么？</li>\n<li>如何最好地将基因组语言模型与其他复杂模态（如转录组学和表观遗传学数据）整合？</li>\n<li>在开发基因组语言模型时，如何更好地理解为什么某些基因组比其他基因组更难建模？</li>\n<li>缩放假设对基因组语言模型是否成立？能成立多久？考虑到大多数数据可能是非功能性的，是否真的有足够的数据可用？</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li>Gonzalo Benegas, Chengzhong Ye, Carlos Albors, Jianan Canal Li, Yun S. Song. arXiv:2407.11435v2. doi: <a href=\"https://doi.org/10.48550/arXiv.2407.11435\">https://doi.org/10.48550/arXiv.2407.11435</a></li>\n</ul>\n<h2 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h2><p>关注公众号“生信之巅”，聊天窗口回复“85d7”获取下载链接。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"AI 在生物信息学的方法革新与应用全景","slug":"AI 在生物信息学的方法革新与应用全景","date":"2025-11-11T11:33:35.000Z","updated":"2025-11-11T11:56:38.573Z","comments":true,"path":"api/articles/AI 在生物信息学的方法革新与应用全景.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig00.png","content":"<p><strong>摘要</strong>：随着人工智能（AI）技术的快速迭代，从传统深度学习到预训练模型、大型语言模型（LLMs）的演进，生物信息学领域正经历从“数据驱动”到“知识赋能”的范式转变。本文整合2024-2025年最新综述成果，系统梳理AI在生物信息学中的核心方法体系（语言模型、图模型、多模态模型）、技术演进脉络（从单一任务模型到基础模型）、典型应用领域（基因组分析、蛋白质研究、微生物组挖掘等），并总结当前面临的数据质量、可解释性、计算成本等挑战，展望多模态融合、小样本学习、临床转化等未来方向。本文旨在为读者建立AI赋能生物信息学的全局认知框架，为后续细分模型与场景篇章奠定基础。</p>\n<p><strong>关键词</strong>：人工智能；生物信息学；大型语言模型；基础模型；预训练模型</p>\n<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h2><p>生物信息学的核心目标是解析生物分子序列（DNA、RNA、蛋白质）中的信息编码规律，揭示基因表达、蛋白质功能、细胞代谢等生命过程的分子机制。传统研究依赖实验测序与手工分析，难以应对高通量测序技术带来的“数据爆炸”——截至2025年，全球基因组数据库已积累超过100万个人类基因组序列、10亿条蛋白质序列<sup>[1]</sup>。AI技术的兴起为这一困境提供了破局方案：从2015年卷积神经网络（CNN）用于DNA motif预测，到2021年首个DNA预训练模型<code>DNABERT</code>问世，再到2024-2025年基因组语言模型（gLMs）、蛋白质语言模型（PLMs）实现跨模态功能预测，AI已成为生物信息学从<strong>描述性研究</strong>向<strong>预测性研究</strong>跨越的核心工具<sup>[2]</sup>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig00.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig00.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图0 可视化大模型工具，专为提升生物信息学各应用领域的研究效能而开发&lt;sup&gt;[2]&lt;/sup&gt;。\"></p>\n<p>本文通过整合多篇权威综述，从<strong>技术演进-方法体系-应用领域-挑战展望</strong>四个维度，构建AI在生物信息学的全景图谱，为后续章节深入探讨细分模型（DNA模型、蛋白质模型等）提供理论与方法基础。</p>\n<h2 id=\"2-AI赋能生物信息学的技术演进\"><a href=\"#2-AI赋能生物信息学的技术演进\" class=\"headerlink\" title=\"2 AI赋能生物信息学的技术演进\"></a>2 AI赋能生物信息学的技术演进</h2><p>AI在生物信息学的应用可分为三个阶段，各阶段的技术特征、代表模型与核心突破存在显著差异，其演进逻辑与生物数据复杂度、计算能力提升高度契合<sup>[3]</sup>。</p>\n<h3 id=\"2-1-阶段1：传统深度学习（2015-2020）——任务特异性建模\"><a href=\"#2-1-阶段1：传统深度学习（2015-2020）——任务特异性建模\" class=\"headerlink\" title=\"2.1 阶段1：传统深度学习（2015-2020）——任务特异性建模\"></a>2.1 阶段1：传统深度学习（2015-2020）——任务特异性建模</h3><p>此阶段以“<strong>单一任务、手工特征</strong>”为核心，模型设计针对具体生物问题（如DNA结合位点预测、蛋白质二级结构预测），依赖领域专家提取特征（如k-mer频率、序列保守性）。</p>\n<ul>\n<li><p><strong>代表技术</strong>：CNN（捕捉局部序列 motif）、循环神经网络（LSTM&#x2F;GRU，捕捉序列长程依赖）、图神经网络（GNN，处理蛋白质相互作用网络）；</p>\n</li>\n<li><p><strong>典型应用</strong>：</p>\n<ul>\n<li>CNN用于转录因子结合位点（TFBS）预测（如Basset模型，2016）；</li>\n<li>LSTM用于RNA剪接位点识别（如SpliceAI，2019）；</li>\n</ul>\n</li>\n<li><p><strong>局限</strong>：泛化能力弱（换用数据集需重新训练）、依赖手工特征、难以处理多模态生物数据（如DNA+表观遗传数据）。</p>\n</li>\n</ul>\n<h3 id=\"2-2-阶段2：预训练模型（2021-2023）——跨任务知识迁移\"><a href=\"#2-2-阶段2：预训练模型（2021-2023）——跨任务知识迁移\" class=\"headerlink\" title=\"2.2 阶段2：预训练模型（2021-2023）——跨任务知识迁移\"></a>2.2 阶段2：预训练模型（2021-2023）——跨任务知识迁移</h3><p>受自然语言处理（NLP）中BERT模型启发，生物信息学领域开始构建“<strong>预训练-微调</strong>”范式：先在大规模无标注生物序列（如人类基因组、UniProt蛋白质库）上预训练，再针对下游任务（如变异效应预测）微调，实现知识跨任务迁移。</p>\n<ul>\n<li><p><strong>代表模型</strong>：</p>\n<ul>\n<li><code>DNA领域</code>：DNABERT（2021，首个DNA-BERT模型，基于k-mer tokenization）、Nucleotide Transformer（2023，多物种基因组预训练）；</li>\n<li><code>蛋白质领域</code>：ProteinBERT（2022，统一蛋白质序列与功能建模）、ESM系列（2021-2023，蛋白质结构预测）；</li>\n</ul>\n</li>\n<li><p><strong>核心突破</strong>：摆脱手工特征依赖，模型可自动学习生物序列的“<strong>语义信息</strong>”（如DNA的调控语法、蛋白质的结构-功能关联），泛化能力显著提升（2021-DNABERT）。</p>\n</li>\n</ul>\n<h3 id=\"2-3-阶段3：基础模型-大模型（2024-2025）——跨模态与通用智能\"><a href=\"#2-3-阶段3：基础模型-大模型（2024-2025）——跨模态与通用智能\" class=\"headerlink\" title=\"2.3 阶段3：基础模型&#x2F;大模型（2024-2025）——跨模态与通用智能\"></a>2.3 阶段3：基础模型&#x2F;大模型（2024-2025）——跨模态与通用智能</h3><p>此阶段模型具备“<strong>大规模数据输入、跨模态融合、多任务适配</strong>”特征，被称为“生物信息学基础模型（Foundation Models）”，可同时处理DNA、RNA、蛋白质、表观遗传等多类型数据，适配从序列分析到功能设计的全链条任务。</p>\n<ul>\n<li><p><strong>代表模型</strong>：</p>\n<ul>\n<li><code>基因组领域</code>：Genomic Touchstone（2025，gLMs基准测试框架，跨DNA&#x2F;RNA&#x2F;蛋白质功能预测）、Generator（2025，长序列基因组生成模型）；</li>\n<li><code>多模态领域</code>：LucaOne（2025，统一核酸与蛋白质语言的基础模型）、CD-GPT（2024，连接中心法则的跨分子模型）；</li>\n</ul>\n</li>\n<li><p><strong>核心突破</strong>：实现“<strong>从数据到知识</strong>”的跨越，可解释性与实用性同步提升（如gLMs可解析基因组功能元件的进化规律，2025-Genomic Touchstone）。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig01.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig01.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1 生物信息学领域大型语言模型（LLMs）整合的里程碑：在DNA、RNA、蛋白质及单细胞RNA（scRNA）应用方面取得的突破&lt;sup&gt;[3]&lt;/sup&gt;。\"></p>\n<h2 id=\"3-AI-在生物信息学的核心方法体系\"><a href=\"#3-AI-在生物信息学的核心方法体系\" class=\"headerlink\" title=\"3 AI 在生物信息学的核心方法体系\"></a>3 AI 在生物信息学的核心方法体系</h2><p>AI赋能生物信息学的方法可分为三大类：<strong>语言模型（主导序列建模）、图模型（主导网络建模）、多模态模型（主导跨类型数据融合）</strong>，各类方法的核心原理、适用场景与代表技术存在显著差异。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig02.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig02.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2 生物信息学领域大型语言模型（LLMs）整合的里程碑：在DNA、RNA、蛋白质及单细胞RNA（scRNA）应用方面取得的突破&lt;sup&gt;[6]&lt;/sup&gt;。\"></p>\n<h3 id=\"3-1-语言模型：生物序列的“语义解析”工具\"><a href=\"#3-1-语言模型：生物序列的“语义解析”工具\" class=\"headerlink\" title=\"3.1 语言模型：生物序列的“语义解析”工具\"></a>3.1 语言模型：生物序列的“语义解析”工具</h3><p>语言模型是当前生物信息学最主流的AI方法，核心思想是将生物序列（如DNA、蛋白质）视为“生物语言”，通过预训练学习序列的上下文依赖关系，适配序列分类、预测、生成等任务。  </p>\n<h4 id=\"3-1-1-核心训练目标\"><a href=\"#3-1-1-核心训练目标\" class=\"headerlink\" title=\"3.1.1 核心训练目标\"></a>3.1.1 核心训练目标</h4><p>语言模型的训练目标决定其对序列信息的捕捉能力，主流目标包括：</p>\n<ol>\n<li><p><strong>掩码语言模型（Masked Language Modeling, MLM）</strong></p>\n<p>随机掩码序列中的部分“token”（如DNA中的k-mer、蛋白质中的氨基酸），模型预测掩码位置的真实token，适用于序列理解任务（如变异效应预测）。</p>\n<p>数学表达：给定序列 $( X &#x3D; (X_1, X_2, …, X_n) )$，随机选择掩码集合 {Masked}，模型学习条件概率分布：</p>\n<p>$\\mathbb{P}[X_i | X_{-i}] \\quad (i \\in \\text{Masked})$</p>\n</li>\n<li><p><strong>因果语言模型（Causal Language Modeling, CLM）</strong></p>\n<p>模型按“从左到右”顺序预测下一个token，适用于序列生成任务（如DNA调控序列设计）。</p>\n<p>数学表达：模型学习条件概率分布：</p>\n<p>$\\mathbb{P}[X_k | X_{1:k-1}] \\quad (k &#x3D; 1, 2, …, n)$</p>\n</li>\n</ol>\n<h4 id=\"3-1-2-关键技术：Tokenization\"><a href=\"#3-1-2-关键技术：Tokenization\" class=\"headerlink\" title=\"3.1.2 关键技术：Tokenization\"></a>3.1.2 关键技术：Tokenization</h4><p>Tokenization是将生物序列转化为模型可处理<code>词汇</code>的过程，直接影响模型对序列特征的捕捉能力，主流方法对比见表1：  </p>\n<p><strong>表1 DNA序列分析的Tokenization方法对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>Tokenization方法</th>\n<th>原理</th>\n<th>优势</th>\n<th>劣势</th>\n<th>代表模型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单核苷酸（Nucleotide-level）</td>\n<td>每个碱基（A&#x2F;C&#x2F;G&#x2F;T）作为1个token</td>\n<td>可解释性强，适配变异分析</td>\n<td>上下文信息少，计算成本高</td>\n<td>GPN（2023）、HyenaDNA（2023）</td>\n</tr>\n<tr>\n<td>重叠k-mer</td>\n<td>滑动窗口截取k个连续碱基作为1个token（如6-mer）</td>\n<td>捕捉局部 motif 信息</td>\n<td>存在序列冗余，词汇表大</td>\n<td>DNABERT（2021）、SpliceBERT（2024）</td>\n</tr>\n<tr>\n<td>非重叠k-mer</td>\n<td>固定窗口截取k个连续碱基作为1个token</td>\n<td>无冗余，计算效率高</td>\n<td>可能割裂长程依赖</td>\n<td>Nucleotide Transformer（2023）</td>\n</tr>\n<tr>\n<td>字节对编码（BPE）</td>\n<td>基于序列频率合并高频子序列</td>\n<td>适配长序列，词汇表小</td>\n<td>可解释性弱</td>\n<td>DNABERT-2（2023）、GENA-LM（2023）</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-2-图模型：生物网络的“关系挖掘”工具\"><a href=\"#3-2-图模型：生物网络的“关系挖掘”工具\" class=\"headerlink\" title=\"3.2 图模型：生物网络的“关系挖掘”工具\"></a>3.2 图模型：生物网络的“关系挖掘”工具</h3><p>生物系统中大量存在网络结构（如蛋白质-蛋白质互作网络、微生物共丰度网络），图模型通过将节点（如蛋白质、微生物）与边（如互作关系、共丰度）建模，挖掘网络中的隐藏关联。  </p>\n<h4 id=\"3-2-1-核心模型类型\"><a href=\"#3-2-1-核心模型类型\" class=\"headerlink\" title=\"3.2.1 核心模型类型\"></a>3.2.1 核心模型类型</h4><ol>\n<li><p><strong>图注意力网络（GAT）</strong>：通过注意力机制分配节点权重，突出关键节点对（如核心蛋白质），适用于蛋白质互作预测（如PGAT-ABPp，2024）；</p>\n</li>\n<li><p><strong>图卷积网络（GCN）</strong>：通过邻接矩阵聚合节点特征，适用于微生物组-疾病关联分析（如2023-Leveraging pre-trained language models）；</p>\n</li>\n</ol>\n<h4 id=\"3-2-2-典型应用\"><a href=\"#3-2-2-典型应用\" class=\"headerlink\" title=\"3.2.2 典型应用\"></a>3.2.2 典型应用</h4><ul>\n<li><strong>蛋白质互作预测</strong>：输入蛋白质序列特征与已知互作网络，GAT模型预测未发现的互作关系（2025-PLM-interact）；  </li>\n<li><strong>微生物组分层</strong>：GCN模型基于微生物共丰度网络，识别疾病相关的微生物集群（2025-AI-empowered human microbiome research）。</li>\n</ul>\n<h3 id=\"3-3-多模态模型：跨类型数据的“融合建模”工具\"><a href=\"#3-3-多模态模型：跨类型数据的“融合建模”工具\" class=\"headerlink\" title=\"3.3 多模态模型：跨类型数据的“融合建模”工具\"></a>3.3 多模态模型：跨类型数据的“融合建模”工具</h3><p>生物数据具有多模态特征（如DNA序列+表观遗传标记+蛋白质结构），多模态模型通过统一表示空间融合不同类型数据，解决“单一数据信息有限”的问题。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig03.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig03.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3 多模态基础模型的计算组件。a、多模态基础模型的预期组件。该模型由多模态输入数据构成，通过混合统一标记和多级注意力操作进行处理。可采用多种自监督和监督学习目标进行预训练和迁移学习。b、多模态内/跨模态注意力机制的放大模型，展示模型中使用的多头注意力变体。放大面板直观呈现单个注意力头的跨模态与模态内操作，密集方块表示对应查询(Q)与键(K)对之间的注意力计算，虚线方块则表示未进行注意力计算。查询、键和值(V)均为Transformer模型计算的实数向量。Nx表示连续堆叠的注意力块数量&lt;sup&gt;[4]&lt;/sup&gt;。\"></p>\n<h4 id=\"3-3-1-核心融合策略\"><a href=\"#3-3-1-核心融合策略\" class=\"headerlink\" title=\"3.3.1 核心融合策略\"></a>3.3.1 核心融合策略</h4><ol>\n<li><p><strong>早期融合</strong>：将多模态数据（如DNA序列嵌入+ histone修饰信号）在输入层拼接，共同输入模型（如Enformer，2021，用于基因表达预测）；</p>\n</li>\n<li><p><strong>晚期融合</strong>：各模态数据单独建模，在输出层融合预测结果（如LucaOne，2025，融合核酸与蛋白质特征）；</p>\n</li>\n</ol>\n<h4 id=\"3-3-2-代表应用\"><a href=\"#3-3-2-代表应用\" class=\"headerlink\" title=\"3.3.2 代表应用\"></a>3.3.2 代表应用</h4><ul>\n<li><strong>跨模态功能预测</strong>：Genomic Touchstone（2025）通过多模态模型，从DNA序列预测RNA稳定性与蛋白质结构，准确率超单一模态模型15%-20%；  </li>\n<li><strong>细胞分子建模</strong>：整合DNA、RNA、蛋白质与细胞影像数据，解析细胞功能调控网络<sup>[4]</sup>。</li>\n</ul>\n<h2 id=\"4-AI-在生物信息学的典型应用领域\"><a href=\"#4-AI-在生物信息学的典型应用领域\" class=\"headerlink\" title=\"4 AI 在生物信息学的典型应用领域\"></a>4 AI 在生物信息学的典型应用领域</h2><p>AI技术已渗透生物信息学的全链条研究，从基础分子序列分析到临床应用，形成多维度应用体系。以下按“基因组→蛋白质组→微生物组→单细胞组学”分类，结合2024-2025年综述成果<sup>[5,6]</sup>，总结各领域的核心应用、代表模型与数据来源。  </p>\n<h3 id=\"4-1-基因组领域：从序列解读到功能设计\"><a href=\"#4-1-基因组领域：从序列解读到功能设计\" class=\"headerlink\" title=\"4.1 基因组领域：从序列解读到功能设计\"></a>4.1 基因组领域：从序列解读到功能设计</h3><p>基因组是生物信息学的基础，AI的核心作用是“<strong>解析DNA序列中的功能编码</strong>”，应用场景涵盖基因注释、变异分析、序列设计等。  </p>\n<h4 id=\"4-1-1-核心应用场景\"><a href=\"#4-1-1-核心应用场景\" class=\"headerlink\" title=\"4.1.1 核心应用场景\"></a>4.1.1 核心应用场景</h4><ol>\n<li><strong>基因组功能注释</strong>：预测DNA中的功能元件（如启动子、增强子、CTCF结合位点），代表模型包括：  <ul>\n<li>gLMs（如GPN，2023）：通过MLM预训练，识别拟南芥基因组中的转录因子结合位点（TFBS），准确率达0.86（F1 score）；  </li>\n<li>基准框架（如Genomic Touchstone，2025）：评估gLMs在人类基因组注释的性能，Top模型（如NTv2-500m-Multi）的增强子预测F1 score达0.55；</li>\n</ul>\n</li>\n<li><strong>遗传变异效应预测</strong>：判断变异（如SNP、Indel）是否影响基因功能，代表模型包括：  <ul>\n<li>Nucleotide Transformer（2023）：预测人类基因组中SNP的致病性，AUC达0.89；  </li>\n<li>GPN-MSA（2023）：结合多物种序列比对（MSA），提升罕见变异效应预测准确率；</li>\n</ul>\n</li>\n<li><strong>DNA序列设计</strong>：生成具有特定功能的DNA序列（如启动子、CRISPR向导RNA），代表模型包括：  <ul>\n<li>regLM（2024）：基于HyenaDNA，生成酵母与人类细胞的启动子序列，功能验证成功率达78%；  </li>\n<li>EVO（2024）：设计新型CRISPR-Cas系统，预测结构与天然系统相似度达0.92。</li>\n</ul>\n</li>\n</ol>\n<p><strong>表2 基因组领域AI应用总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>应用场景</th>\n<th>代表模型</th>\n<th>数据来源</th>\n<th>核心指标（准确率&#x2F;F1 score）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>启动子注释</td>\n<td>NTv2-500m-Multi</td>\n<td>人类基因组（hg38）</td>\n<td>0.86</td>\n</tr>\n<tr>\n<td>增强子分类</td>\n<td>DNABERT2</td>\n<td>ENCODE SCREEN数据库</td>\n<td>0.55</td>\n</tr>\n<tr>\n<td>SNP致病性预测</td>\n<td>Nucleotide Transformer</td>\n<td>ClinVar数据库</td>\n<td>0.89（AUC）</td>\n</tr>\n<tr>\n<td>启动子生成</td>\n<td>regLM</td>\n<td>酵母&#x2F;人类调控序列</td>\n<td>0.78（功能成功率）</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-2-蛋白质领域：从结构预测到功能优化\"><a href=\"#4-2-蛋白质领域：从结构预测到功能优化\" class=\"headerlink\" title=\"4.2 蛋白质领域：从结构预测到功能优化\"></a>4.2 蛋白质领域：从结构预测到功能优化</h3><p>蛋白质是生命活动的执行者，AI的核心作用是“破解蛋白质序列-结构-功能的关联”，应用场景涵盖结构预测、功能注释、酶工程等。  </p>\n<h4 id=\"4-2-1-核心应用场景\"><a href=\"#4-2-1-核心应用场景\" class=\"headerlink\" title=\"4.2.1 核心应用场景\"></a>4.2.1 核心应用场景</h4><ol>\n<li><strong>蛋白质结构预测</strong>：预测二级（α-螺旋&#x2F;β-折叠）与三级结构，代表模型包括：  <ul>\n<li>ESM-2（2023）：基于650M参数PLM，二级结构预测Q3 score达0.86；  </li>\n<li>AlphaFold3（2024）：多模态模型，整合序列与结构数据，三级结构预测TM-score达0.92；</li>\n</ul>\n</li>\n<li><strong>蛋白质功能注释</strong>：预测蛋白质的酶分类、翻译后修饰（PTM）位点，代表模型包括：  <ul>\n<li>ProteinBERT（2022）：酶分类准确率达0.74，PTM位点预测F1 score达0.72；  </li>\n<li>DPFunc（2025）：结合结构域信息，蛋白质功能预测准确率超传统模型12%；</li>\n</ul>\n</li>\n<li><strong>酶工程优化</strong>：改造酶的动力学参数（如催化效率、稳定性），代表模型包括：  <ul>\n<li>UniKP（2023）：统一框架预测酶的Km&#x2F;Kcat值，预测误差比传统方法降低30%；  </li>\n<li>强化学习模型（2025）：优化脂肪酶的温度稳定性，Tm值提升15℃。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-3-微生物组领域：从群落解析到疾病关联\"><a href=\"#4-3-微生物组领域：从群落解析到疾病关联\" class=\"headerlink\" title=\"4.3 微生物组领域：从群落解析到疾病关联\"></a>4.3 微生物组领域：从群落解析到疾病关联</h3><p>微生物组与人类健康密切相关（如肠道微生物影响代谢疾病），AI的核心作用是“挖掘微生物群落的组成规律与功能关联”，应用场景涵盖群落分类、疾病关联、功能预测等。  </p>\n<h4 id=\"4-3-1-核心应用场景\"><a href=\"#4-3-1-核心应用场景\" class=\"headerlink\" title=\"4.3.1 核心应用场景\"></a>4.3.1 核心应用场景</h4><ol>\n<li><strong>微生物群落分类</strong>：识别样本中的微生物种类与丰度，代表模型包括：  <ul>\n<li>ViBE（2022）：基于Transformer，病毒序列分类准确率达0.91；  </li>\n<li>预训练模型（2023）：基于16S rRNA序列，微生物物种分类F1 score达0.88；</li>\n</ul>\n</li>\n<li><strong>微生物组-疾病关联</strong>：挖掘影响疾病的关键微生物，代表模型包括：  <ul>\n<li>预训练语言模型（2023）：分析肠道微生物与糖尿病的关联，AUC达0.83；  </li>\n<li>图模型（2025）：基于微生物共丰度网络，识别肥胖相关微生物集群，准确率达0.79；</li>\n</ul>\n</li>\n<li><strong>微生物功能预测</strong>：预测微生物的代谢通路与酶功能，代表模型包括：  <ul>\n<li>MetaBERT（2024）：基于宏基因组序列，代谢通路预测准确率达0.81；  </li>\n<li>多模态模型（2025）：整合微生物序列与代谢组数据，酶功能预测F1 score达0.76。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-4-单细胞组学领域：从细胞分型到调控解析\"><a href=\"#4-4-单细胞组学领域：从细胞分型到调控解析\" class=\"headerlink\" title=\"4.4 单细胞组学领域：从细胞分型到调控解析\"></a>4.4 单细胞组学领域：从细胞分型到调控解析</h3><p>单细胞组学（如单细胞RNA-seq）可解析细胞异质性，AI的核心作用是“从高维单细胞数据中提取生物学信息”，应用场景涵盖细胞分型、轨迹推断、调控网络构建等。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig04.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/BioAI/01/Fig04.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图4 单细胞组学的Transformer模型。该模型的输入可为单细胞组学的单一或多种检测模式，其核心架构由M层Transformer构成，通过多层结构对输入数据进行特征转换。这类单细胞Transformer通常通过自监督学习任务（如预测细胞内特定基因的表达模式）进行预训练，可广泛应用于下游任务，既可用于细胞层面的注释分析，也可用于基因层面的功能预测&lt;sup&gt;[7]&lt;/sup&gt;。\"></p>\n<h4 id=\"4-4-1-核心应用场景\"><a href=\"#4-4-1-核心应用场景\" class=\"headerlink\" title=\"4.4.1 核心应用场景\"></a>4.4.1 核心应用场景</h4><ol>\n<li><strong>细胞分型</strong>：识别单细胞数据中的细胞类型，代表模型包括：  <ul>\n<li>Transformer-based模型（2024）：处理人类PBMC单细胞数据，细胞分型准确率达0.94；  </li>\n<li>基础模型（2024）：Large-scale foundation model，跨数据集细胞分型泛化率达0.89；</li>\n</ul>\n</li>\n<li><strong>细胞轨迹推断</strong>：预测细胞分化&#x2F;发育路径，代表模型包括：  <ul>\n<li>图神经网络（2024）：分析胚胎干细胞分化轨迹，与实验结果一致性达0.91；  </li>\n<li>多模态模型（2025）：整合单细胞RNA-seq与ATAC-seq数据，轨迹推断准确率提升15%；</li>\n</ul>\n</li>\n<li><strong>单细胞调控网络</strong>：构建细胞内基因调控关系，代表模型包括：  <ul>\n<li>注意力模型（2024）：预测TF-gene调控对，AUC达0.87；  </li>\n<li>因果推断模型（2025）：解析单细胞中的基因因果关系，假阳性率降低20%。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-AI-在生物信息学面临的挑战\"><a href=\"#5-AI-在生物信息学面临的挑战\" class=\"headerlink\" title=\"5 AI 在生物信息学面临的挑战\"></a>5 AI 在生物信息学面临的挑战</h2><p>尽管AI在生物信息学取得显著进展，但2024-2025年综述普遍指出，当前技术仍面临<strong>数据质量、可解释性、计算成本、临床转化</strong>四大核心挑战。  </p>\n<h3 id=\"5-1-数据质量：生物数据的“先天缺陷”\"><a href=\"#5-1-数据质量：生物数据的“先天缺陷”\" class=\"headerlink\" title=\"5.1 数据质量：生物数据的“先天缺陷”\"></a>5.1 数据质量：生物数据的“先天缺陷”</h3><ol>\n<li><strong>标注稀缺与偏差</strong>：  <ul>\n<li>功能标注数据不足（如人类基因组中仅3.3%碱基有明确功能标注）；  </li>\n<li>临床数据偏差（如ClinVar数据库中欧洲人群变异占比超80%，导致模型对其他人群的预测准确率下降15%-20%）；</li>\n</ul>\n</li>\n<li><strong>序列重复与冗余</strong>：  <ul>\n<li>基因组中50%以上为重复序列（如人类基因组），导致模型过度拟合重复区域，对功能区域预测精度下降；  </li>\n<li>蛋白质数据库中同源序列占比超40%，影响模型泛化能力；</li>\n</ul>\n</li>\n<li><strong>多模态数据异构</strong>：  <ul>\n<li>不同类型生物数据（如DNA序列、蛋白质结构、表观数据）的格式与尺度差异大，融合难度高，易导致模型“偏倚”（如过度依赖序列数据，忽视表观信息）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>表3 AI 在生物信息学的主要挑战分类</strong></p>\n<table>\n<thead>\n<tr>\n<th>挑战类型</th>\n<th>具体表现</th>\n<th>对模型的影响</th>\n<th>潜在解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据质量</td>\n<td>标注稀缺、重复序列多、多模态异构</td>\n<td>泛化能力弱、预测偏差大</td>\n<td>半监督学习、重复序列降权、统一模态表示</td>\n</tr>\n<tr>\n<td>可解释性</td>\n<td>模型“黑箱”，难以解析预测逻辑</td>\n<td>临床应用信任度低、难以指导实验设计</td>\n<td>注意力可视化、 motif 解析、因果推断</td>\n</tr>\n<tr>\n<td>计算成本</td>\n<td>大模型训练需千卡GPU时，推理速度慢</td>\n<td>小实验室难以使用、实时分析困难</td>\n<td>模型压缩、高效架构（如Mamba）、蒸馏</td>\n</tr>\n<tr>\n<td>临床转化</td>\n<td>模型性能与临床需求脱节（如假阳性率高）</td>\n<td>难以落地疾病诊断、药物研发</td>\n<td>临床数据微调、多中心验证</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-2-可解释性：AI-模型的“黑箱困境”\"><a href=\"#5-2-可解释性：AI-模型的“黑箱困境”\" class=\"headerlink\" title=\"5.2 可解释性：AI 模型的“黑箱困境”\"></a>5.2 可解释性：AI 模型的“黑箱困境”</h3><ol>\n<li><strong>预测逻辑不可追溯</strong>：  <ul>\n<li>大模型（如2.5B参数的Nucleotide Transformer）的预测依赖复杂的注意力权重，难以解析“为何某变异被预测为致病性”；  </li>\n<li>对比传统方法（如 conservation score），gLMs的功能元件预测缺乏明确的生物学解释（如未直接关联进化保守性）；</li>\n</ul>\n</li>\n<li><strong>缺乏机制性解释</strong>：  <ul>\n<li>模型可预测“某DNA序列为增强子”，但无法解释“该序列通过何种机制调控基因表达”（如结合哪些TF）；  </li>\n<li>蛋白质结构预测模型（如AlphaFold3）可输出结构，但难以解析“结构如何决定功能”<sup>[6]</sup>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-3-计算成本：大模型的“资源门槛”\"><a href=\"#5-3-计算成本：大模型的“资源门槛”\" class=\"headerlink\" title=\"5.3 计算成本：大模型的“资源门槛”\"></a>5.3 计算成本：大模型的“资源门槛”</h3><ol>\n<li><strong>训练成本高昂</strong>：  <ul>\n<li>基础模型（如LucaOne）训练需1000+ GPU时，硬件成本超100万美元，小实验室难以承担；  </li>\n<li>长序列模型（如HyenaDNA，处理1M碱基）推理时间是传统模型的5-10倍，难以满足实时分析需求；</li>\n</ul>\n</li>\n<li><strong>数据存储与预处理</strong>：  <ul>\n<li>多物种基因组数据（如850个物种）存储量超10TB，预处理需专门的分布式系统；  </li>\n<li>单细胞数据维度超10<sup>5</sup>，需降维处理，易丢失关键信息<sup>[7]</sup>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-4-临床转化：从“实验室”到“病床”的鸿沟\"><a href=\"#5-4-临床转化：从“实验室”到“病床”的鸿沟\" class=\"headerlink\" title=\"5.4 临床转化：从“实验室”到“病床”的鸿沟\"></a>5.4 临床转化：从“实验室”到“病床”的鸿沟</h3><ol>\n<li><strong>模型性能与临床需求脱节</strong>：  <ul>\n<li>变异致病性预测模型在数据库中的AUC达0.89，但在真实临床样本中假阳性率超30%，难以直接用于诊断；  </li>\n<li>微生物组-疾病关联模型多基于横断面数据，缺乏纵向验证，难以指导疾病预防；</li>\n</ul>\n</li>\n<li><strong>伦理与隐私问题</strong>：  <ul>\n<li>人类基因组数据涉及隐私，模型训练需合规（如GDPR），限制数据共享；  </li>\n<li>AI设计的生物序列（如抗菌肽）可能存在未知安全性风险，缺乏统一的伦理评估标准<sup>[6]</sup>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"6-未来展望\"><a href=\"#6-未来展望\" class=\"headerlink\" title=\"6 未来展望\"></a>6 未来展望</h2><p>基于2024-2025年综述的共识，AI在生物信息学的未来发展将聚焦<strong>多模态融合、小样本学习、可解释性提升、临床转化</strong>四大方向，旨在解决当前挑战，实现“从技术创新到生物学发现”的跨越<sup>[4,6]</sup>。</p>\n<h3 id=\"6-1-多模态融合：构建“生物系统全景模型”\"><a href=\"#6-1-多模态融合：构建“生物系统全景模型”\" class=\"headerlink\" title=\"6.1 多模态融合：构建“生物系统全景模型”\"></a>6.1 多模态融合：构建“生物系统全景模型”</h3><ul>\n<li><strong>目标</strong>：整合DNA、RNA、蛋白质、表观遗传、细胞影像等多类型数据，构建覆盖“分子-细胞-个体”的多层次模型；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>统一模态表示（如将蛋白质结构转化为序列嵌入，与DNA嵌入融合）；  </li>\n<li>跨模态注意力机制（突出关键模态对（如DNA+表观数据）的协同作用）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>多模态基础模型可同时预测基因表达、蛋白质结构、细胞功能，为合成生物学提供“全链条设计工具”；  </li>\n<li>跨尺度模型（如分子-细胞）解析疾病的分子机制（如癌症发生的基因-蛋白质-细胞异常 cascade）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-2-小样本学习：解决“数据稀缺”难题\"><a href=\"#6-2-小样本学习：解决“数据稀缺”难题\" class=\"headerlink\" title=\"6.2 小样本学习：解决“数据稀缺”难题\"></a>6.2 小样本学习：解决“数据稀缺”难题</h3><ul>\n<li><strong>目标</strong>：在少标注数据（如罕见疾病变异、新发现微生物）场景下，仍保持高预测精度；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>迁移学习（如从人类基因组模型迁移到稀有物种基因组）；  </li>\n<li>数据增强（如生成合成生物序列，扩充训练集）；  </li>\n<li>零样本学习（如利用进化关系，预测未标注物种的蛋白质功能）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>罕见病变异诊断：基于100-1000个标注样本，模型致病性预测准确率达0.90；  </li>\n<li>新发现微生物功能解析：零样本预测新微生物的代谢通路，与实验结果一致性达0.85。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-3-可解释性提升：从“黑箱”到“透明模型”\"><a href=\"#6-3-可解释性提升：从“黑箱”到“透明模型”\" class=\"headerlink\" title=\"6.3 可解释性提升：从“黑箱”到“透明模型”\"></a>6.3 可解释性提升：从“黑箱”到“透明模型”</h3><ul>\n<li><strong>目标</strong>：让AI模型的预测可追溯、可验证，提供明确的生物学机制解释；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>注意力可视化（如解析gLMs中哪些碱基对功能预测起关键作用）；  </li>\n<li>motif 提取（如从PLMs中提取酶的催化位点 motif，与实验验证的 motif 比对）；  </li>\n<li>因果推断（如区分模型预测中的“相关关系”与“因果关系”，避免假阳性）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>临床变异解读：模型不仅预测致病性，还输出“该变异影响XX基因的XX功能域，导致XX蛋白结构异常”；  </li>\n<li>实验设计指导：模型推荐验证实验（如突变某TFBS，验证其对基因表达的影响）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-4-临床转化：加速“AI-实验-临床”闭环\"><a href=\"#6-4-临床转化：加速“AI-实验-临床”闭环\" class=\"headerlink\" title=\"6.4 临床转化：加速“AI-实验-临床”闭环\"></a>6.4 临床转化：加速“AI-实验-临床”闭环</h3><ul>\n<li><strong>目标</strong>：将AI模型从实验室推向临床，实现疾病诊断、药物研发、精准医疗的落地应用；  </li>\n<li><strong>关键技术</strong>：  <ul>\n<li>临床数据微调（如用多中心临床样本微调模型，降低人群偏差）；  </li>\n<li>模型标准化（如制定gLMs的性能基准与评估标准，确保不同模型的可比性）；  </li>\n<li>安全性评估（如AI设计的生物序列需通过体外实验验证安全性）；</li>\n</ul>\n</li>\n<li><strong>预期应用</strong>：  <ul>\n<li>精准诊断：AI辅助解读肿瘤基因组变异，诊断准确率提升20%，假阳性率降低30%；  </li>\n<li>药物研发：AI设计抗菌肽药物，研发周期从2年缩短至6个月，临床试验成功率提升15%。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-结论\"><a href=\"#7-结论\" class=\"headerlink\" title=\"7 结论\"></a>7 结论</h2><p>本文通过整合2024-2025年AI在生物信息学的最新综述成果，系统梳理了技术演进（从传统深度学习到基础模型）、方法体系（语言模型、图模型、多模态模型）、应用领域（基因组、蛋白质组、微生物组、单细胞组学）与核心挑战（数据质量、可解释性、计算成本、临床转化），并展望了未来发展方向。  </p>\n<p>AI已成为生物信息学的核心驱动力，但其价值不仅在于“提升分析效率”，更在于“发现新的生物学规律”——如gLMs解析基因组的功能语法、PLMs揭示蛋白质的进化规律。后续系列文章将聚焦细分模型（DNA模型、蛋白质模型、统一模型）与场景（肽设计、酶工程、蛋白质互作），深入拆解AI技术的具体实现与应用细节，为读者提供从“全局认知”到“实践落地”的完整指引。  </p>\n<p>未来，随着多模态融合、小样本学习、可解释性技术的突破，AI将进一步推动生物信息学从“数据驱动”向“知识驱动”转型，为生命科学研究与临床应用提供更强大的工具支撑。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><p>[1] Asim MN, Ibrahim MA, Zaib A and Dengel A (2025) DNA sequence analysis landscape: a comprehensive review of DNA sequence analysis task types, databases, datasets, word embedding methods, and language models. Front. Med. 12:1503229. doi: <a href=\"https://doi.org/10.3389/fmed.2025.1503229\">10.3389&#x2F;fmed.2025.1503229</a></p>\n</li>\n<li><p>[2] Sarumi, Oluwafemi A. et al., Large language models and their applications in bioinformatics. Computational and Structural Biotechnology Journal, Volume 23, 3498-3505. doi: <a href=\"https://doi.org/10.1016/j.csbj.2024.09.031\">https://doi.org/10.1016/j.csbj.2024.09.031</a></p>\n</li>\n<li><p>[3]Zhenyu Wang, Zikang Wang, Jiyue Jiang, Pengan Chen, Xiangyu Shi, Yu Li. Large Language Models in Bioinformatics: A Survey.  arXiv:2503.04490v2. doi: <a href=\"\">https://doi.org/10.48550/arXiv.2503.04490</a><a href=\"https://doi.org/10.48550/arXiv.2503.04490\">https://doi.org/10.48550/arXiv.2503.04490</a></p>\n</li>\n<li><p>[4] Cui, H., Tejada-Lapuerta, A., Brbić, M. et al. Towards multimodal foundation models in molecular cell biology. Nature 640, 623–633 (2025). <a href=\"https://doi.org/10.1038/s41586-025-08710-y\">https://doi.org/10.1038/s41586-025-08710-y</a></p>\n</li>\n<li><p>[5] Chen Z, Wei L, Gao G. Foundation models for bioinformatics. Quantitative Biology. 2024; 12(4): 339–44. <a href=\"https://doi.org/10.1002/qub2.69\">https://doi.org/10.1002/qub2.69</a></p>\n</li>\n<li><p>[6] Wei Ruan, Yanjun Lyu, Jing Zhang et al., Large Language Models for Bioinformatics. arXiv:2501.06271v1. doi:<br><a href=\"https://doi.org/10.48550/arXiv.2501.06271\">https://doi.org/10.48550/arXiv.2501.06271</a></p>\n</li>\n<li><p>[7] Szałata, A., Hrovatin, K., Becker, S. et al. Transformers in single-cell omics: a review and new perspectives. Nat Methods 21, 1430–1443 (2024). <a href=\"https://doi.org/10.1038/s41592-024-02353-z\">https://doi.org/10.1038/s41592-024-02353-z</a></p>\n</li>\n</ul>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"BioAI 专辑：解读 AI 重塑生物信息学研究逻辑","slug":"BioAI 专辑：解读 AI 重塑生物信息学研究逻辑","date":"2025-11-11T10:33:35.000Z","updated":"2025-11-11T11:56:35.606Z","comments":true,"path":"api/articles/BioAI 专辑：解读 AI 重塑生物信息学研究逻辑.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","content":"<h1 id=\"当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？\"><a href=\"#当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？\" class=\"headerlink\" title=\"当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？\"></a>当AI撞开生命科学的大门：我为什么要做这个BioAI专辑？</h1><p>作为一名深耕生物信息学13年的研究者，我亲历过行业的“数据焦虑”与“效率瓶颈”。而如今，同样的工作场景早已天翻地覆——AlphaFold3能在几小时内精准预测蛋白质与核酸、小分子的复合物结构，AI工具仅凭免疫细胞序列就能区分10余种疾病亚型，甚至能让老药实现“跨界”抗癌。</p>\n<p>这种变革不是偶然，而是人工智能与生物信息学深度融合的必然结果。今天，我正式推出【BioAI前沿解读】专辑，带你穿透技术迷雾，看懂AI如何重塑我们熟悉的生物信息学研究逻辑。</p>\n<h2 id=\"1-AI不是“替代者”，而是传统方法的“破壁人”\"><a href=\"#1-AI不是“替代者”，而是传统方法的“破壁人”\" class=\"headerlink\" title=\"1. AI不是“替代者”，而是传统方法的“破壁人”\"></a>1. AI不是“替代者”，而是传统方法的“破壁人”</h2><p>传统生物信息学始终被两大痛点束缚：<strong>海量数据的“解读困境”</strong> 与<strong>实验验证的“高成本陷阱”</strong>。而AI的介入，正从根上破解这些僵局，每一个突破都有扎实的研究支撑：</p>\n<p>在<strong>蛋白质结构研究领域</strong>，2024年《Nature》发表的AlphaFold3，通过改进的Evoformer模块和扩散模型，不仅能预测蛋白质单体结构，还能精准建模蛋白质-DNA、蛋白质-小分子复合物，针对膜蛋白复合物的预测准确率比传统冷冻电镜方法高出52%。</p>\n<p>在<strong>基因编辑领域</strong>，CRISPR-Cas9的脱靶风险曾是临床转化的“死穴”。《Nature Biotechnology》发表的瑞士苏黎世联邦理工学院团队成果——AI工具Pythia，通过学习10万组基因编辑数据的修复模式，能预判细胞对编辑位点的修复倾向，设计的“精准修复模板”让HeLa细胞的编辑脱靶率从12.7%降至1.3%，这是传统试错法永远无法达到的精度。</p>\n<p>更贴近临床的突破来自<strong>疾病诊断</strong>：2025年《Science》刊登的斯坦福大学研究中，AI工具<a href=\"https://www.science.org/doi/10.1126/science.adp2407\">Mal-ID</a>通过分析血液中B细胞和T细胞的受体序列，对542名受试者的COVID-19、艾滋病、1型糖尿病等8种疾病进行诊断，AUC值（曲线下面积）均超过0.95，甚至能识别出传统检测遗漏的早期潜伏感染病例——这种“免疫序列解码”的思路，是我们10年前想都不敢想的。</p>\n<p>这些成果背后，是AI对传统方法的“降维打击”——当深度学习的模式识别能力遇上基因组、转录组、蛋白质组的海量数据，曾经隐藏在数据中的生命密码，正被逐一解码。</p>\n<h2 id=\"2-BioAI的黄金时代：不止于工具，更是研究范式的革命\"><a href=\"#2-BioAI的黄金时代：不止于工具，更是研究范式的革命\" class=\"headerlink\" title=\"2. BioAI的黄金时代：不止于工具，更是研究范式的革命\"></a>2. BioAI的黄金时代：不止于工具，更是研究范式的革命</h2><p>如果说5年前AI还只是生物研究的“辅助工具”，如今它早已成为<strong>研究范式的重构者</strong>。尤其值得关注的是DNA和蛋白质领域的大语言模型（LLM），正在开辟全新研究路径：</p>\n<p>在<strong>DNA LLM领域</strong>，2021年《Bioinformatics》发表的<a href=\"https://pubmed.ncbi.nlm.nih.gov/33538820/\">DNABERT</a>是里程碑式突破——它将DNA序列按3个碱基为单位（密码子）进行编码，通过BERT架构学习基因组的“语法规则”，识别启动子、增强子等调控元件的准确率比传统的HMM（隐马尔可夫模型）高出23%。</p>\n<p>在<strong>蛋白质LLM领域</strong>，2022年《Bioinformatics》发表的<a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC9386727/\">ProtBERT</a>首次将Transformer架构应用于蛋白质序列分析，通过学习UniProt数据库中1亿条蛋白质序列的特征，预测氨基酸突变对蛋白质功能的影响准确率达0.89。而2023年《Nature Biotechnology》发表的<a href=\"https://www.nature.com/articles/s41587-022-01618-2\">ProGen2</a>更实现了“创造性突破”——它能根据指定功能（如“结合钙离子”、“酶解纤维素”）从头设计蛋白质序列。</p>\n<h2 id=\"3-这个专辑，我想带你看懂什么？\"><a href=\"#3-这个专辑，我想带你看懂什么？\" class=\"headerlink\" title=\"3. 这个专辑，我想带你看懂什么？\"></a>3. 这个专辑，我想带你看懂什么？</h2><p>BioAI领域的论文和工具层出不穷，但很多前沿成果被包裹在复杂的算法公式里，非计算机背景的研究者很难快速转化应用。这正是我做这个专辑的初衷：<strong>把复杂技术讲透彻，把前沿成果落地上</strong>。</p>\n<p>在后续内容中，你会看到这些核心板块：</p>\n<ul>\n<li><p><strong>顶刊论文深度拆解</strong>：从AlphaFold3的扩散模型创新，到DNABERT的序列编码逻辑，我会抽丝剥茧解读核心算法，告诉你“AI为什么能做到”，并标注关键文献供大家溯源；</p>\n</li>\n<li><p><strong>实用工具实操指南</strong>：模型本地化部署教程、软件使用指南等干货，解决“想用时用不了”的难题；</p>\n</li>\n<li><p><strong>LLM解读</strong>：详解DNA LLM、蛋白质LLM的训练逻辑、应用场景，结合我自己的研究案例说明“如何用LLM解决实际问题”；</p>\n</li>\n</ul>\n<p>BioAI不是“技术炫技”，而是能真正落地解决研究痛点的“生产力工具”。它不会取代实验科学，而是让我们从重复的数据分析中解放出来，把更多精力投入到更富创造性的假设提出与实验设计中。</p>\n<p>如果你有想解读的论文、关注的方向，或是在研究中遇到的AI应用难题，欢迎在评论区留言——我会把大家关心的话题纳入后续内容。</p>\n<p>关注我，下一篇，不见不散！ 🌟</p>\n<p><font color=\"#FF0000\"><b>注：若读者对深度学习的基本概念和术语不了解，也可以阅读我的《PyTorch专辑》，从基础理论到案例实践都有，通过理论学习和代码练习快速入门深度学习。</b></font></p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>","raw":null,"categories":[{"name":"BioAI","path":"api/categories/BioAI.json"}],"tags":[{"name":"LLM","path":"api/tags/LLM.json"},{"name":"生物信息","path":"api/tags/生物信息.json"}]},{"title":"在Ubuntu中配置Python文字识别环境（基于Tesseract OCR）","slug":"在Ubuntu中配置Python文字识别环境（基于Tesseract-OCR）","date":"2025-10-19T13:41:46.000Z","updated":"2025-10-19T13:54:33.097Z","comments":true,"path":"api/articles/在Ubuntu中配置Python文字识别环境（基于Tesseract-OCR）.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","content":"<p>文字识别（OCR）是处理图像或PDF中文字内容的重要技术，Tesseract OCR是一款开源高效的OCR引擎，结合Python库可快速实现文字提取功能。本文将详细介绍在Ubuntu系统中配置支持中文的Python文字识别环境的步骤，适用于处理图片、PDF等文件中的文字内容。</p>\n<h2 id=\"一、安装Tesseract-OCR引擎\"><a href=\"#一、安装Tesseract-OCR引擎\" class=\"headerlink\" title=\"一、安装Tesseract OCR引擎\"></a>一、安装Tesseract OCR引擎</h2><p>Tesseract是核心OCR引擎，需先安装其基础程序。</p>\n<ol>\n<li><p>打开终端，更新系统包列表：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Tesseract OCR引擎：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install tesseract-ocr</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这一步将安装Tesseract的核心程序，支持基础的文字识别功能（默认包含英文语言包）。</p>\n<h2 id=\"二、安装并配置中文语言包\"><a href=\"#二、安装并配置中文语言包\" class=\"headerlink\" title=\"二、安装并配置中文语言包\"></a>二、安装并配置中文语言包</h2><p>默认安装的Tesseract不包含中文语言包，需单独安装并修正文件名（避免因命名格式导致识别失败）。</p>\n<ol>\n<li><p>安装中文简体语言包：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install tesseract-ocr-chi-sim</span><br></pre></td></tr></table></figure>\n\n<p> （可选）若需识别繁体中文，可额外安装：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install tesseract-ocr-chi-tra</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修正语言包文件名（关键步骤）：</p>\n</li>\n</ol>\n<p>Tesseract对语言包的文件名格式有严格规范，但实际使用中，其对文件名的识别存在一定兼容性差异：安装后中文语言包默认文件名为下划线格式（<code>chi_sim.traineddata</code> 对应简体，<code>chi_tra.traineddata</code> 对应繁体），但部分场景下程序可能要求使用连字符格式（<code>chi-sim.traineddata</code>、<code>chi-tra.traineddata</code>）。为避免因文件名格式导致识别失败，建议复制一份以连字符命名的文件，从而兼容不同场景下的调用需求。：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修正简体中文包文件名</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> /usr/share/tesseract-ocr/4.00/tessdata/chi_sim.traineddata /usr/share/tesseract-ocr/4.00/tessdata/chi-sim.traineddata</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># （可选）修正繁体中文包文件名</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> /usr/share/tesseract-ocr/4.00/tessdata/chi_tra.traineddata /usr/share/tesseract-ocr/4.00/tessdata/chi-tra.traineddata</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、验证Tesseract安装与语言包配置\"><a href=\"#三、验证Tesseract安装与语言包配置\" class=\"headerlink\" title=\"三、验证Tesseract安装与语言包配置\"></a>三、验证Tesseract安装与语言包配置</h2><p>安装完成后，需确认引擎和语言包是否正常生效。</p>\n<ol>\n<li><p>检查Tesseract版本（验证引擎安装）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract --version</span><br></pre></td></tr></table></figure>\n\n<p> 若输出类似<code>tesseract 4.0.0</code>的版本信息，说明引擎安装成功。</p>\n</li>\n<li><p>检查已安装的语言包（验证中文支持）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract --list-langs</span><br></pre></td></tr></table></figure>\n\n<p> 若输出包含<code>chi-sim</code>（简体中文）和<code>chi-tra</code>（繁体中文），说明中文语言包配置成功。</p>\n</li>\n</ol>\n<h2 id=\"四、配置TESSDATA-PREFIX环境变量\"><a href=\"#四、配置TESSDATA-PREFIX环境变量\" class=\"headerlink\" title=\"四、配置TESSDATA_PREFIX环境变量\"></a>四、配置TESSDATA_PREFIX环境变量</h2><p>Tesseract需要通过<code>TESSDATA_PREFIX</code>环境变量定位语言包目录，需手动配置以确保引擎能正确找到语言包。</p>\n<ol>\n<li><p>编辑环境变量配置文件（以bash为例）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export TESSDATA_PREFIX=/usr/share/tesseract-ocr/4.00/&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p> 说明：<code>TESSDATA_PREFIX</code>需指向<code>tessdata</code>目录。</p>\n</li>\n<li><p>使环境变量生效：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>（若使用zsh，需将命令中的<code>~/.bashrc</code>替换为<code>~/.zshrc</code>）</p>\n<h2 id=\"五、安装Python相关依赖库\"><a href=\"#五、安装Python相关依赖库\" class=\"headerlink\" title=\"五、安装Python相关依赖库\"></a>五、安装Python相关依赖库</h2><p>通过Python调用Tesseract需安装对应的接口库，同时为处理PDF文件需补充相关工具库。</p>\n<ol>\n<li><p>安装核心Python库：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pytesseract PyPDF2 pdf2image pdfplumber opencv-python pillow</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 各库作用说明：</p>\n<ul>\n<li><p><code>pytesseract</code>：Python调用Tesseract OCR的接口库；</p>\n</li>\n<li><p><code>PyPDF2</code>&#x2F;<code>pdfplumber</code>：用于读取PDF文件（支持文本型PDF直接提取）；</p>\n</li>\n<li><p><code>pdf2image</code>：将图片型PDF转换为图片格式（以便Tesseract识别）;</p>\n</li>\n<li><p><code>opencv-python</code>：主要用于计算机视觉任务，可实现图像处理、视频分析、目标检测、边缘识别等复杂功能，是机器视觉领域的常用库；</p>\n</li>\n<li><p><code>pillow</code>：是轻量易用的 Python 图像库，核心用于基础图像操作，包括图像的读写、裁剪、尺寸调整、色彩调整及简单滤镜效果实现。</p>\n</li>\n</ul>\n</li>\n<li><p>（可选）若<code>pdf2image</code>运行时提示缺少依赖，需安装图片处理工具：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install poppler-utils</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"六、注意事项\"><a href=\"#六、注意事项\" class=\"headerlink\" title=\"六、注意事项\"></a>六、注意事项</h2><ol>\n<li><p>环境变量生效范围：上述配置仅对当前用户生效，若需全局生效，可将环境变量写入<code>/etc/profile</code>（需管理员权限）。</p>\n</li>\n<li><p>虚拟环境问题：若在Python虚拟环境中使用，需在虚拟环境激活后重新执行<code>source ~/.bashrc</code>（或手动设置<code>TESSDATA_PREFIX</code>）。</p>\n</li>\n<li><p>权限问题：确保运行程序的用户对<code>/usr/share/tesseract-ocr/4.00/tessdata/</code>目录及语言包文件有读取权限（默认权限已满足，无需额外配置）。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上步骤，即可在Ubuntu系统中完成支持中文的Python文字识别环境配置。基于Tesseract OCR和Python库，可实现图片、PDF等文件的文字提取功能，为后续的文本分析、内容处理等场景奠定基础。</p>\n<h2 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h2><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"图像识别","path":"api/tags/图像识别.json"}]},{"title":"CentOS 7 升级 GCC 教程（以 GCC 9 为例）","slug":"CentOS-7-升级-GCC-教程（以-GCC-9-为例）","date":"2025-10-19T13:33:35.000Z","updated":"2025-10-19T13:40:18.210Z","comments":true,"path":"api/articles/CentOS-7-升级-GCC-教程（以-GCC-9-为例）.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","content":"<h2 id=\"一、教程背景\"><a href=\"#一、教程背景\" class=\"headerlink\" title=\"一、教程背景\"></a>一、教程背景</h2><p>CentOS 7 系统默认预装的 GCC 版本为 <strong>4.8.5</strong>（发布于 2015 年），而现代开发场景中，许多软件（如高版本 Python、TensorFlow、C++ 11+ 项目等）对 GCC 版本要求较高（需 5.4+ 及以上）。因此需升级 GCC，但直接覆盖系统默认 GCC 可能导致依赖冲突（如 <code>yum</code> 工具依赖旧版本）。</p>\n<p>本教程采用 <strong>SCL（Software Collections）仓库</strong> 方式升级，可在不覆盖系统默认 GCC 的前提下，安装并使用高版本 GCC（以 GCC 9 为例，稳定且兼容性强），安全且灵活。</p>\n<h2 id=\"二、升级前准备\"><a href=\"#二、升级前准备\" class=\"headerlink\" title=\"二、升级前准备\"></a>二、升级前准备</h2><p>确保系统已联网，且拥有 <code>root</code> 权限（或使用 <code>sudo</code> 权限执行命令）。</p>\n<h2 id=\"三、详细升级步骤\"><a href=\"#三、详细升级步骤\" class=\"headerlink\" title=\"三、详细升级步骤\"></a>三、详细升级步骤</h2><h3 id=\"1-备份原有-YUM-源（关键：防止配置出错）\"><a href=\"#1-备份原有-YUM-源（关键：防止配置出错）\" class=\"headerlink\" title=\"1. 备份原有 YUM 源（关键：防止配置出错）\"></a>1. 备份原有 YUM 源（关键：防止配置出错）</h3><p>CentOS 7 停止官方维护后，默认 YUM 源可能失效，且后续需添加新仓库配置。先备份原有源文件，避免误操作后无法恢复：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建备份目录</span></span><br><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /etc/yum.repos.d/backup</span><br><span class=\"line\"><span class=\"comment\"># 将所有 .repo 源文件移动到备份目录</span></span><br><span class=\"line\">sudo <span class=\"built_in\">mv</span> /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup/</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-添加-SCL-仓库配置文件（使用阿里云源）\"><a href=\"#2-添加-SCL-仓库配置文件（使用阿里云源）\" class=\"headerlink\" title=\"2. 添加 SCL 仓库配置文件（使用阿里云源）\"></a>2. 添加 SCL 仓库配置文件（使用阿里云源）</h3><p>SCL 仓库是升级 GCC 的核心，这里选择 <strong>阿里云 SCL 源</strong>（国内访问速度快，稳定性高），手动创建仓库配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用 vi 编辑器创建并编辑 centos-sclo-rh.repo 文件</span></span><br><span class=\"line\">sudo vi /etc/yum.repos.d/centos-sclo-rh.repo</span><br></pre></td></tr></table></figure>\n\n<p>打开编辑器后，按 <code>i</code> 进入编辑模式，<strong>完整复制以下内容</strong>（不要遗漏或修改格式）：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[centos-sclo-rh]</span><br><span class=\"line\">name=CentOS-7 - SCLo rh</span><br><span class=\"line\">baseurl=https://mirrors.aliyun.com/centos/7/sclo/x86_64/rh/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-SIG-SCLo</span><br><span class=\"line\">enabled=1</span><br></pre></td></tr></table></figure>\n\n<p>复制完成后，按 <code>Esc</code> 退出编辑模式，输入 <code>:wq</code> 并回车（保存并退出 vi 编辑器）。</p>\n<h3 id=\"3-清理-YUM-缓存并生成新缓存\"><a href=\"#3-清理-YUM-缓存并生成新缓存\" class=\"headerlink\" title=\"3. 清理 YUM 缓存并生成新缓存\"></a>3. 清理 YUM 缓存并生成新缓存</h3><p>新添加仓库后，需清理旧缓存、加载新仓库的包列表，确保后续安装能找到正确的软件包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理所有 YUM 缓存</span></span><br><span class=\"line\">sudo yum clean all &amp;&amp; </span><br><span class=\"line\"><span class=\"comment\"># 生成新的缓存（下载阿里云源的包列表）</span></span><br><span class=\"line\">sudo yum makecache</span><br></pre></td></tr></table></figure>\n\n<p>执行后耐心等待（时间取决于网络速度），若无报错则缓存生成成功。</p>\n<h3 id=\"4-（可选）安装-SCL-仓库基础包\"><a href=\"#4-（可选）安装-SCL-仓库基础包\" class=\"headerlink\" title=\"4. （可选）安装 SCL 仓库基础包\"></a>4. （可选）安装 SCL 仓库基础包</h3><p>多数情况下，步骤 2 添加的配置文件已足够，但若后续安装 GCC 时提示“仓库不存在”，可执行此步骤安装 SCL 仓库基础包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y centos-release-scl</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-安装高版本-GCC（GCC-9）\"><a href=\"#5-安装高版本-GCC（GCC-9）\" class=\"headerlink\" title=\"5. 安装高版本 GCC（GCC 9）\"></a>5. 安装高版本 GCC（GCC 9）</h3><p>通过 YUM 安装 <code>devtoolset-9</code>（对应 GCC 9 版本），并添加 <code>--nogpgcheck</code> 参数（跳过 GPG 密钥验证，因 CentOS 7 官方密钥源已失效，不影响包安全性）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils --nogpgcheck</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>devtoolset-9-gcc</code>：GCC 9 核心包</li>\n<li><code>devtoolset-9-gcc-c++</code>：C++ 编译组件（如需编译 C++ 项目必装）</li>\n<li><code>devtoolset-9-binutils</code>：二进制工具集（辅助编译）</li>\n</ul>\n<p>执行后等待安装完成（约 50MB 下载量），无报错则安装成功。</p>\n<h3 id=\"6-启用高版本-GCC\"><a href=\"#6-启用高版本-GCC\" class=\"headerlink\" title=\"6. 启用高版本 GCC\"></a>6. 启用高版本 GCC</h3><p>SCL 安装的 GCC 不会自动生效，需手动启用，支持 <strong>临时启用</strong> 和 <strong>永久启用</strong>，根据需求选择：</p>\n<h4 id=\"方式-1：临时启用（仅当前终端有效）\"><a href=\"#方式-1：临时启用（仅当前终端有效）\" class=\"headerlink\" title=\"方式 1：临时启用（仅当前终端有效）\"></a>方式 1：临时启用（仅当前终端有效）</h4><p>适用于“临时使用高版本 GCC”的场景，关闭终端后恢复默认 GCC 4.8.5：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scl <span class=\"built_in\">enable</span> devtoolset-9 bash</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方式-2：永久启用（推荐）\"><a href=\"#方式-2：永久启用（推荐）\" class=\"headerlink\" title=\"方式 2：永久启用（推荐）\"></a>方式 2：永久启用（推荐）</h4><p>若需每次登录终端都自动使用 GCC 9，可将启用命令写入环境变量文件，分“当前用户”和“全局所有用户”两种场景：</p>\n<h5 id=\"场景-A：仅当前用户生效（推荐普通用户）\"><a href=\"#场景-A：仅当前用户生效（推荐普通用户）\" class=\"headerlink\" title=\"场景 A：仅当前用户生效（推荐普通用户）\"></a>场景 A：仅当前用户生效（推荐普通用户）</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将启用命令写入当前用户的 .bashrc 文件</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 立即生效（无需重启终端）</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"场景-B：全局所有用户生效（需-root-权限）\"><a href=\"#场景-B：全局所有用户生效（需-root-权限）\" class=\"headerlink\" title=\"场景 B：全局所有用户生效（需 root 权限）\"></a>场景 B：全局所有用户生效（需 root 权限）</h5><p>适用于多用户服务器，所有用户登录后均使用 GCC 9：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到 root 用户（若当前非 root）</span></span><br><span class=\"line\">su root</span><br><span class=\"line\"><span class=\"comment\"># 将启用命令写入全局环境变量文件 /etc/profile</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt; /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 立即生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-验证-GCC-升级结果\"><a href=\"#7-验证-GCC-升级结果\" class=\"headerlink\" title=\"7. 验证 GCC 升级结果\"></a>7. 验证 GCC 升级结果</h3><p>执行以下命令查看当前 GCC 版本，确认是否升级成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -v</span><br></pre></td></tr></table></figure>\n\n<p>若输出类似以下内容（版本号为 9.3.1 及以上），则说明升级成功：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using built-in specs.</span><br><span class=\"line\">COLLECT_GCC=gcc</span><br><span class=\"line\">COLLECT_LTO_WRAPPER=/opt/rh/devtoolset-9/root/usr/libexec/gcc/x86_64-redhat-linux/9/lto-wrapper</span><br><span class=\"line\">Target: x86_64-redhat-linux</span><br><span class=\"line\">Configured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,lto --prefix=/opt/rh/devtoolset-9/root/usr --mandir=/opt/rh/devtoolset-9/root/usr/share/man --infodir=/opt/rh/devtoolset-9/root/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style=gnu --with-default-libstdcxx-abi=gcc4-compatible --enable-plugin --enable-initfini-array --with-isl=/builddir/build/BUILD/gcc-9.3.1-20200408/obj-x86_64-redhat-linux/isl-install --disable-libmpx --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\">gcc version 9.3.1 20200408 (Red Hat 9.3.1-2.2.el7) (GCC)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"四、常见问题与注意事项\"><a href=\"#四、常见问题与注意事项\" class=\"headerlink\" title=\"四、常见问题与注意事项\"></a>四、常见问题与注意事项</h2><ol>\n<li><p><strong>若需安装其他 GCC 版本</strong>：<br>本教程以 GCC 9 为例，若需安装 GCC 10，只需将命令中的 <code>devtoolset-9</code> 替换为 <code>devtoolset-10</code>（如 <code>devtoolset-10-gcc</code>），其他步骤一致。</p>\n</li>\n<li><p><strong>系统默认 GCC 未被覆盖</strong>：<br>SCL 安装的 GCC 位于 <code>/opt/rh/devtoolset-9/root/usr/bin/</code>，系统默认 GCC（4.8.5）仍在 <code>/usr/bin/gcc</code>，若需临时使用旧版本，可直接执行 <code>/usr/bin/gcc -v</code>。</p>\n</li>\n<li><p><strong>安装时提示“无可用软件包”</strong>：<br>重新执行步骤 3（清理并生成缓存），或检查步骤 2 的仓库配置文件是否正确（确保 <code>baseurl</code> 未写错）。</p>\n</li>\n</ol>\n<h2 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h2><p>通过本教程，可在 CentOS 7 上安全升级 GCC 至 9 版本（或更高），满足现代软件开发需求，且不影响系统原有依赖。若后续需编译软件（如 Python、C++ 项目），直接使用 <code>gcc</code> 或 <code>g++</code> 命令即可调用高版本工具。</p>\n<h2 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h2><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"Linux","path":"api/tags/Linux.json"},{"name":"系统","path":"api/tags/系统.json"}]},{"title":"What is RAG","slug":"What-is-RAG","date":"2025-08-03T08:49:01.000Z","updated":"2025-08-03T08:53:50.219Z","comments":true,"path":"api/articles/What-is-RAG.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/RAG.png","content":"<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/RAG.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/RAG.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"一图看懂RAG\"></p>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n\n","raw":null,"categories":[],"tags":[]},{"title":"一种用于多重图像处理与分析的端到端工作流程","slug":"一种用于多重图像处理与分析的端到端工作流程","date":"2025-06-30T12:42:04.000Z","updated":"2025-07-11T14:10:37.243Z","comments":true,"path":"api/articles/一种用于多重图像处理与分析的端到端工作流程.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig1.jpg","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>多重成像技术能够在单细胞分辨率下同时对组织中的数十种生物分子进行空间分析。从多重组织成像数据中提取生物学相关信息（如细胞表型的空间分布）涉及多项计算任务，包括图像分割、特征提取和空间分辨的单细胞分析。在此，我们提出了一种用于多重组织图像处理和分析的端到端工作流程，该流程整合了之前开发的计算工具，以用户友好和可定制的方式实现这些任务。在数据质量评估方面，我们强调了napari-imc在交互式检查原始成像数据方面的实用性，以及cytomapper R&#x2F;Bioconductor包在R中进行图像可视化的功能。使用steinbock工具包执行原始数据预处理、图像分割和特征提取。我们展示了两种基于监督像素分类和预训练深度学习模型的细胞分割替代方法。提取的单细胞数据随后在R中进行读取、处理和分析。该方案描述了使用社区建立的数据容器的方法，从而便于应用R&#x2F;Bioconductor包进行降维、单细胞可视化和表型分析。我们提供了使用imcRtools R&#x2F;Bioconductor包进行空间分辨单细胞分析的说明，包括群落分析、细胞邻域检测和细胞-细胞相互作用测试。该工作流程之前已应用于成像质谱细胞计数数据，但可以轻松适应其他高度多重成像技术。本方案可由具有基本生物信息学培训的研究人员实施，并且所提供的数据集的分析可在5–6小时内完成。扩展版本可在<a href=\"https://bodenmillergroup.github.io/IMCDataAnalysis/%E4%B8%8A%E8%8E%B7%E5%BE%97%E3%80%82\">https://bodenmillergroup.github.io/IMCDataAnalysis/上获得。</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>高度多重成像技术能够在组织中同时检测到数十种生物分子（如蛋白质和转录本，也称为“标志物”）。最近建立的多重组织成像技术依赖于荧光标记抗体的循环染色技术[1–3]，或使用寡核苷酸标记的[4,5]或金属标记的[6,7]抗体等技术。这些技术的关键优势在于，它们允许对组织空间环境中的单个细胞进行深入分析。因此，这些方法已经能够对肿瘤微环境的空间结构[1,8–10]、用于评估细胞类型和趋化因子空间共定位的核酸和蛋白质丰度[11]、病毒感染细胞的空间生态位[12]，以及2019年冠状病毒病（COVID-19）感染[13,14]、1型糖尿病进展[15]和自身免疫性疾病[16]期间的病理特征进行分析。</p>\n<p>为了充分利用多重成像数据中包含的信息进行生物学和临床分析，无论生物学问题是什么，都必须执行一系列计算步骤。这些步骤包括：（1）对图像进行目视检查，以初步评估数据质量；（2）生物图像处理与分割，以提取用于下游分析的单细胞特征；（3）单细胞分析，如将单细胞数据投影到低维空间、进行聚类和细胞表型分析，以支持探索性数据分析和量化样本之间的生物学差异[8,15,17]；（4）利用从多重成像数据中提取的空间信息来检测细胞表型之间的相互作用或避免作用[18]、表征细胞邻域（CNs）[5,10,19]和空间群落[8]，以及识别相似细胞的斑块[11]。存在许多计算工具和方法来执行上述步骤；然而，许多工具缺乏互操作性、可扩展性，并且依赖于复杂的自定义脚本。</p>\n<p>在此，我们提出了一种简化且易于扩展的多重图像分析端到端工作流程，该流程支持所有关键步骤，并与现有软件实现互操作性。该工作流程最初是为分析成像质谱细胞计数（IMC）数据而开发的，也适用于其他高度多重成像技术生成的数据。我们专门为可视化原始IMC数据开发的napari图像查看器插件napari-imc可实现交互式图像可视化。steinbock工具包可实现多重图像处理，包括数据提取、图像分割和数据导出。具体而言，我们展示了使用监督像素分类[21,22]和预训练深度学习模型[23]的分割方法，以从多重图像中提取空间分辨的单细胞信息。随后，imcRtools R&#x2F;Bioconductor包将生成的单细胞数据读入R编程语言。通过使用社区建立的数据容器，该工作流程集成了许多先前开发的R&#x2F;Bioconductor包，以执行信号溢出校正[24]，并允许进行低维可视化、质量控制、细胞表型分析、单细胞聚类和图像可视化[17,25]。最后，我们描述了如何以用户友好的方式使用imcRtools包执行空间群落分析、细胞邻域（CN）和空间上下文（SC）检测、细胞斑块表征和细胞表型相互作用分析。工作流程中使用的所有工具都记录详尽，并且旨在通过互操作性、可重复性和用户友好性分析，为接受过基本生物信息学培训的研究人员提供服务。我们描述了该工作流程，强调了常见陷阱，并讨论了针对各个步骤进行故障排除的方法。</p>\n<h1 id=\"程序概述\"><a href=\"#程序概述\" class=\"headerlink\" title=\"程序概述\"></a>程序概述</h1><p>本方案描述了分析由高度多重组织成像技术生成的数据的基本步骤。整个流程分为九个阶段：交互式成像数据可视化（步骤1-5）、数据预处理（步骤6）、图像分割（步骤7）、单细胞特征提取（步骤8）、将数据读入R（步骤9-13）、溢出校正（步骤14-21）、质量控制（步骤22-27）、细胞表型分析（步骤28-30）和空间分辨单细胞分析（步骤31-35）。图1给出了该程序的概览，而工作流程的详细描述可在<a href=\"https://bodenmillergroup.github.io/IMCDataAnalysis/%E4%B8%8A%E6%9F%A5%E9%98%85%E3%80%82\">https://bodenmillergroup.github.io/IMCDataAnalysis/上查阅。</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig1.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig1.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图1 | 多重组织图像分析工作流程概述。原始成像数据可通过使用如napari-imc等napari插件进行交互式检查，以评估数据质量和进行探索性可视化（步骤1–5），适用于IMC（离子束成像）。数据预处理是从原始数据中提取TIFF格式的多通道图像（步骤6）。图像分割可通过应用预训练的深度学习模型（左侧）或通过监督像素分类（右侧）来执行。我们重点介绍了使用steinbook工具包进行深度学习分割，以及使用Ilastik和CellProfiler进行基于像素分类的分割（步骤7–8）。空间分辨单细胞数据可通过imcRtools（https://bioconductor.org/packages/release/bioc/html/imcRtools.html）和cytomapper R/Bioconductor软件包（https://bioconductor.org/packages/release/bioc/html/cytomapper.html）读入R（步骤9–13），这些软件包支持溢出校正、质量控制、细胞表型分析和空间分析（步骤14–35）。BiocStickers根据知识共享许可协议CC0 1.0从https://github.com/Bioconductor/BiocStickers重新印制。\"></p>\n<p>在计算分析之前，通过灵活可视化标记丰度对原始成像数据进行定性检查是手动评估数据质量的关键步骤26。最近开发的多维图像查看器<code>napari</code>能够实现多通道图像的快速交互式可视化20。为了方便检查原始离子束成像（IMC）数据，我们开发了<code>napari-imc</code>插件，该插件使napari能够加载<code>Hyperion</code>成像系统生成的<code>MCD/TXT</code>文件。使用napari-imc，研究人员可以将多重IMC采集数据与仪器获取的光学图像（用于区域选择，即“全景图”）进行叠加，从而便于对原始数据进行定性检查。对于其他多重成像技术，如多重离子束成像（MIBI）7、通过索引共检测（CODEX）5和循环免疫荧光（CyCIF）1，这些技术无法提供生物样本的固有多模态视图（这些数据相当于IMC采集数据，而非IMC全景图），成像数据通常可以转换为napari原生支持的文件格式。</p>\n<p>多通道图像处理能够实现多重成像捕获的生物实体的定量分析。单个处理步骤包括图像提取和预处理、图像分割以及生物对象（如细胞）的量化。本文介绍了如何使用<code>Ilastik</code><sup>21</sup>和<code>CellProfiler</code><sup>22</sup>执行基于随机森林的监督像素分类图像分割（以下简称“基于像素分类的分割”）。这种方法之前曾被用于从多重图像中提取单细胞信息，以进行组织空间表征<sup>8,13,15,27</sup>。作为一种替代策略，我们还提供了使用深度学习支持的Mesmer分割算法23（以下简称“基于深度学习的分割”）执行基于预训练神经网络的全自动细胞分割的指南。我们的<code>steinbock</code>多通道图像处理工具包提供了基于深度学习的分割方法。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig2.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig2.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图2 | 图像处理后的数据输出及在R中的表示。在图像处理过程中，首先对所有提供的多通道图像进行分割，以检测并存储为分割掩膜的单个细胞。基于这些分割掩膜，提取单细胞特征，包括每个细胞和通道的平均像素强度、形态学特征、细胞的xy位置（区域属性）和空间细胞图。为了在R中处理生成的数据，将所有多通道图像读入一个单一的`CytoImageList`对象，将所有分割掩膜读入另一个单一的CytoImageList对象，并将所有图像的单细胞特征读入一个单一的`SpatialExperiment`对象。患者和图像级别的特征分别存储在每个CytoImageList对象的`elementMetadata`插槽和SpatialExperiment对象的`colData`插槽中。BiocStickers根据知识共享许可协议CC0 1.0从https://github.com/Bioconductor/BiocStickers重新印制。\"></p>\n<p>图像分割和空间分辨单细胞数据提取后，将执行下游分析步骤以表征组织环境中的细胞。为此，分别使用imcRtools和cytomapper R&#x2F;Bioconductor软件包将单细胞数据和图像读入R（图2）。初步数据处理步骤包括溢出校正，以纠正相邻通道间的伪信号24，以及分割和样本质量控制。通过将单细胞数据存储在R&#x2F;Bioconductor的SpatialExperiment28对象中，该工作流程促进了单细胞数据分析步骤，包括使用现有工具进行聚类、降维、可视化和批次校正17,29,30。为了检测具有相似标记表达（以下简称“细胞表型”）的细胞群，我们描述了两种基于标记真实数据的单细胞聚类和分类的替代方法。最后，我们描述了<code>imcRtools</code>软件包支持的一系列空间数据分析任务，以表征空间组织结构。我们展示了如何检测空间肿瘤和间质群落，这些群落可用于表征不同细胞表型之间的高阶相互作用8。为了结合细胞表型信息检测空间组织结构，我们使用imcRtools软件包将细胞聚合成<code>细胞邻域（CNs）</code>5,10和<code>超级细胞（SCs）</code>19。作为检测空间组织结构的另一种有监督方式，我们重点介绍了一种补丁检测方法，该方法可用于分析预定细胞表型的空间聚集11。最后，为了评估某些类型的细胞表型在图像中的空间相互作用是否增加或减少，我们描述了使用基于置换的测试策略18。</p>\n<p>要使用此工作流程，需要掌握R编程语言的基础知识。这包括安装软件包、执行函数、理解函数参数以及如何访问函数文档的能力。此外，研究人员应能够在命令行上执行简单操作，如更改目录。</p>\n<p>综上所述，本方案强调了使用最近开发的工具以用户友好和可重复的方式执行端到端的多重图像分析，包括图像可视化和分割、数据质量控制以及单细胞和空间分析。</p>\n<h1 id=\"工作流的应用\"><a href=\"#工作流的应用\" class=\"headerlink\" title=\"工作流的应用\"></a>工作流的应用</h1><h2 id=\"工作流的先前应用\"><a href=\"#工作流的先前应用\" class=\"headerlink\" title=\"工作流的先前应用\"></a>工作流的先前应用</h2><p>之前，所提出的方法已被用于从多重成像数据中提取空间分辨的单细胞特征，以表征组织结构和其与疾病进展的关系8,9,11,15。该方法中描述的图像可视化策略已被用于显示子宫内膜异位症样本的复合图像31，以及在胰岛32和淋巴组织33的分割掩膜上绘制细胞表型和细胞表达的空间图。基于监督像素分类的图像分割方法已被应用于从多重成像数据中提取和分析空间分辨的单细胞数据，以绘制乳腺癌8,9,18,27、1型糖尿病15、COVID-19感染期间的肺和皮肤损伤13,14以及人肾组织空间结构34的特征图。steinbock工具包支持的通过应用预训练的深度学习模型进行图像分割的方法，之前已被用于研究药物筛选期间非小细胞肺癌球体中的标记表达35，以及表征转移性黑色素瘤中的趋化因子环境11。在本文方法中，我们还描述了一种细胞表型分析策略，即根据图像中细胞的标记表达进行手动标记，然后用于分类。该策略之前已被用于识别转移性黑色素瘤11和COVID-19患者皮肤样本14中的细胞表型。在方法的最后部分，我们提供了空间单细胞分析策略的指导。空间群落检测方法之前已被用于表征乳腺癌的空间结构及其与单细胞病理学组的关系8。细胞邻域（CN）和超级细胞（SC）检测已被用于了解结直肠癌样本内空间域的作用和组装10,19。本文描述的补丁检测方法已被用于识别趋化因子环境的细胞成分11。最后，用于识别细胞表型之间相互作用或避免作用的测试策略，之前已被用于表征乳腺癌8,18,27、转移性黑色素瘤11和胰腺组织15中的局部细胞表型相互作用。</p>\n<p>对于图像分割，我们描述了两种基于监督像素分类和预训练深度学习模型的替代方法。基于监督像素分类的分割方法通过调整CellProfiler管道提供了灵活性，并可以通过训练特定的Ilastik分类器15扩展到分割更大的组织结构，如胰岛。该管道之前已在多项研究中用于从多重图像中提取单细胞信息8,9,13–15,18,27。然而，最初开发的基于像素分类的分割管道需要自定义脚本、手动软件安装，并且仅通过使用随机森林的监督像素分类提供图像分割策略。为了促进多通道图像处理，我们因此开发了<code>steinbock</code>工具包，该工具包可实现数据提取、图像分割并且以用户友好的方式实现数据导出。它还通过使用启用深度学习的Mesmer分割算法，基于预训练的神经网络提供全自动细胞分割。steinbock工具包易于使用，旨在通过提供版本化和容器化的环境，确保在不同运行和平台之间的可重复性。</p>\n<h2 id=\"工作流的技术中立应用\"><a href=\"#工作流的技术中立应用\" class=\"headerlink\" title=\"工作流的技术中立应用\"></a>工作流的技术中立应用</h2><p>所提出的方法之前已被用于IMC（多标记质谱流式细胞术）生成的数据的端到端分析。然而，除了个别明确指示且专门为IMC定制的步骤外，所提供的工具还可应用于其他多重成像技术生成的数据。但是，一些迭代式多重成像技术需要额外的预处理步骤，如图像拼接和配准1,5，而这些步骤并未包含在所提出的工作流中。为了使本文描述的工具适用于给定的多重组织成像数据集，图像必须作为（拼接和共配准的）多通道TIFF文件提供。</p>\n<p>此外，如果使用了免疫荧光通道来检测细胞核和细胞膜36，则所描述的工具还可用于分析空间转录组数据，如seqFISH。对于此类数据，steinbock工具包可用于图像分割和单细胞数据提取，imcRtools包可执行空间数据分析，而cytomapper包则允许在分割掩膜上可视化细胞表型。</p>\n<h2 id=\"工作流的扩展\"><a href=\"#工作流的扩展\" class=\"headerlink\" title=\"工作流的扩展\"></a>工作流的扩展</h2><p>所提出的方法提供了执行多重成像数据基本分析所需的所有工具。然而，根据研究问题，可以使用额外的工具和软件包来扩展所提出的方法。对于查看多通道图像，<code>QuPath</code>26提供了灵活且用户友好的可视化选项，这些选项可在TIFF图像上操作。<code>steinbock</code>工具包允许以流式细胞术标准（FCS）文件的形式导出单细胞数据，以便与FCS Express或Cytobank一起使用。此外，由于可以将单细胞数据以anndata对象37的形式导出，因此可以通过Python中的单细胞和空间数据分析来扩展该方法。可以使用<code>slingshot</code>38进行轨迹分析，<code>spicyR</code>支持检测细胞类型共定位变化32，而<code>edgeR</code>17,39可用于执行差异丰度测试。有关单细胞分析方法的全面概述，请参阅《使用Bioconductor编排单细胞分析》一书，该书可在<a href=\"https://bioconductor.org/books/release/OSCA/%E4%B8%8A%E8%8E%B7%E5%8F%96%E3%80%82\">https://bioconductor.org/books/release/OSCA/上获取。</a></p>\n<h1 id=\"与其他方法的比较\"><a href=\"#与其他方法的比较\" class=\"headerlink\" title=\"与其他方法的比较\"></a>与其他方法的比较</h1><h2 id=\"图像查看器\"><a href=\"#图像查看器\" class=\"headerlink\" title=\"图像查看器\"></a>图像查看器</h2><p>为了交互式多通道图像可视化，之前已开发了包括<code>histoCAT</code>18、<code>CytoMap</code>40、<code>cytokit</code>41和<code>vitessce</code>42在内的多个图像查看器。然而，现有的图像查看器不支持读取存储在专有数据格式中的原始IMC数据所包含的全部信息。本文描述了使用<code>napari-imc</code>专门读取原始IMC数据，并将多重IMC采集叠加到全景图上，从而能够在组织上下文中检查图像。</p>\n<h2 id=\"图像分割方法\"><a href=\"#图像分割方法\" class=\"headerlink\" title=\"图像分割方法\"></a>图像分割方法</h2><p>对于图像分割，之前应用的两种基于像素分类和深度学习模型的方法已被纳入工作流。基于像素分类的分割方法依赖于使用<code>Ilastik</code>进行像素分类和使用<code>CellProfiler</code>进行细胞分割。该分割方法的简化版本已在<code>imcyto</code>管道43中实现。近年来，已开发了诸如<code>StarDist</code>44、<code>Cellpose</code>45和<code>Mesmer</code>23等启用深度学习的图像分割方法，以在多种组织类型和成像平台上实现人类水平的分割性能23。这些方法通常需要自定义脚本和特定的数据预处理步骤。我们已将启用深度学习的<code>Mesmer</code>分割算法纳入<code>steinbock</code>，因为它已针对通过多种多重成像技术获取的数据进行了专门训练。</p>\n<h2 id=\"单细胞与空间分析工具\"><a href=\"#单细胞与空间分析工具\" class=\"headerlink\" title=\"单细胞与空间分析工具\"></a>单细胞与空间分析工具</h2><p>单细胞与空间数据分析依赖于一系列交互式和程序化工具的支持。专为某些多重成像平台设计的图形用户界面（GUI）软件操作简便，可实现多通道图像和单细胞数据的联合可视化<sup>18,40,41,46</sup>。然而，这些工具往往与其他框架的互操作性较差，且难以扩展到其开发数据类型之外的其他用例。本文介绍了一些用户友好的计算工具，能够以简化的方式执行所有关键分析步骤，并确保与现有软件包（如Bioconductor项目中的软件包47）的互操作性。对于程序化的单细胞与空间数据分析，最近开发了<code>squidpy</code>软件包48用于在Python中分析数据，而<code>giotto</code>49则在R中进行类似的分析。这两个软件包都提供了大量用于空间分辨单细胞分析的功能，<code>steinbock</code>工具包则允许导出数据以便与<code>squidpy</code>结合使用。相比之下，Bioconductor项目47中的<code>imcRtools</code>和<code>cytomapper</code>软件包用于空间数据分析和图像可视化，因此能够与使用标准化数据类的众多单细胞数据分析方法相结合17,28。</p>\n<h2 id=\"分析流程\"><a href=\"#分析流程\" class=\"headerlink\" title=\"分析流程\"></a>分析流程</h2><p><code>CellProfiler</code>22、<code>Ilastik</code>21、<code>QuPATH</code>26和<code>cytokit</code>41等单个工具，以及包含<code>imcyto</code>43、<code>MIRIAM</code>50和<code>mplexable</code>51的工作流，可执行图像处理和分割。这些工具和工作流侧重于多重图像分析的特定处理步骤，通常与空间分辨单细胞分析等下游分析任务缺乏互操作性。最近，开发了一个名为<code>MCMICRO</code>的全面流程，用于从使用各种成像技术获取的多通道图像中提取和分析单细胞数据52。MCMICRO流程允许执行迭代染色方法通常所需的图像处理步骤，包括图像拼接和配准、图像分割和特征提取。对于单细胞和空间数据分析，该流程提供了使用<code>phenograph</code>53进行单细胞聚类和使用CN检测54的模块，并且可以通过开发新模块来扩展该流程。本文所述的方案提供了超越MCMICRO流程中模块的空间分辨单细胞分析策略。具体而言，在简化图像分割、特征提取并将数据读入R之后，本文重点介绍了常用的单细胞分析工具，以执行降维、单细胞可视化、批次校正和聚类以及基于分类的表型分析。此外，通过使用<code>SpatialExperiment</code>容器来存储空间分辨单细胞数据，该工作流可与许多当前和未来开发的用于空间和单细胞数据分析的Bioconductor软件包相结合。</p>\n<h1 id=\"数据生成的实验设计\"><a href=\"#数据生成的实验设计\" class=\"headerlink\" title=\"数据生成的实验设计\"></a>数据生成的实验设计</h1><p>在应用本文所述的方案分析多重成像技术生成的数据之前，研究人员必须仔细考虑要成像的样本数量、测量的感兴趣区域的数量和位置、样本质量以及抗体鸡尾酒的特异性和敏感性55。样本大小和感兴趣区域（ROI）大小主要受研究性质和材料可用性的影响。建议进行预实验，以估算最佳采集数量和大小，从而描绘出感兴趣的组织特征56,57。</p>\n<p>在最终数据采集之前，需要针对感兴趣的组织类型和包埋策略（即福尔马林固定石蜡包埋（FFPE）或最佳切割温度复合物（OCT））专门评估每种抗体的染色质量。为了评估技术差异，如染色效率随时间的变化或实验变化，建议与实验样本平行地对控制样本（如细胞系团块）进行染色和采集。这些控制细胞团块也应使用与主要样本相同的流程进行分析，以评估技术差异。</p>\n<p><font color=\"#FF0000\">本文所述的数据分析方案假设所有样本都是使用相同的抗体面板采集的。如果使用不同的面板，则应对每个子批次样本分别应用该方案。下文讨论了评估数据质量的几种方法，并提出了在分析步骤中纠正和&#x2F;或避免技术偏差的方法。</font></p>\n<h1 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h1><h2 id=\"多通道图像处理的内存和存储限制\"><a href=\"#多通道图像处理的内存和存储限制\" class=\"headerlink\" title=\"多通道图像处理的内存和存储限制\"></a>多通道图像处理的内存和存储限制</h2><p>基于像素分类的分割方法在处理大量图像时会遇到内存和运行时问题。首先，在Ilastik中加载和标记许多大文件会消耗大量内存并减慢像素标注的速度。我们通过裁剪图像来解决这个问题，并需要决定是加载较小的裁剪图像还是较少的图像到Ilastik中。此外，通过启用Ilastik中的“实时模式”来即时重新训练分类器也会消耗大量内存。这个问题可以通过关闭“实时模式”进行标注来解决。最后，所提供的CellProfiler流程会从图像中提取所有可用特征。对于大型数据集，这可能会导致生成存储单细胞特征的大型（多个千兆字节）CSV文件。因此，我们建&#96;议手动选择对下游分析感兴趣的特征。</p>\n<h2 id=\"与其他工具的兼容性\"><a href=\"#与其他工具的兼容性\" class=\"headerlink\" title=\"与其他工具的兼容性\"></a>与其他工具的兼容性</h2><p>steinbock工具包主要处理存储在未压缩TIFF文件中的图像，这需要足够的计算资源。在使用steinbock时，可以通过压缩原始数据进行长期存储并启用图形处理单元（GPU）支持图像分割来减轻与数据集和&#x2F;或图像大小相关的问题。通过批量处理图像瓦片而不是完整图像来支持大型全玻片图像（大小为数十GB）的处理。此外，steinbock尽可能访问磁盘上的TIFF文件，而不是将完整图像加载到内存中。在使用深度学习支持的Mesmer算法进行全自动图像分割时，底层预训练神经网络可能并非对所有数据集都能立即表现出色。steinbock工具包可使用–preprocess&#x2F;–postprocess命令行选项来微调算法参数（参见“故障排除”部分）。或者，也可以采用基于像素分类的监督图像分割方法，其中用于分割的像素分类器可以根据当前数据集进行定制（重新训练）。</p>\n<h2 id=\"R中的图像可视化\"><a href=\"#R中的图像可视化\" class=\"headerlink\" title=\"R中的图像可视化\"></a>R中的图像可视化</h2><p>cytomapper包目前支持以HDF5格式在磁盘上存储图像，这有助于处理大型图像。然而，在R的原生图形设备中一次性显示大型全玻片图像计算成本高昂，我们建议先对图像进行分块，然后并排可视化单个图像块。</p>\n<h2 id=\"选择正确的聚类数量\"><a href=\"#选择正确的聚类数量\" class=\"headerlink\" title=\"选择正确的聚类数量\"></a>选择正确的聚类数量</h2><p>我们在两种情况下描述了聚类方法：首先，是识别细胞表型（第28步），其次，是检测拷贝数（CN）（第32步）。在这两种情况下，选择聚类方法和聚类数量都不简单，需要测试不同的参数，直到忠实地概括所研究系统的先前生物学知识或估计聚类稳定性（例如，一些聚类在不同的参数设置下不会发生变化）。我们在第28步中讨论了合适的参数扫描。然而，为了检测CN，如果可能的话，最好对要检测的组织结构有预先的预期，并相应地调整聚类参数。对于无监督的CN检测，可以测试多种聚类参数设置和方法来估计结果的稳健性。</p>\n<h2 id=\"随着细胞数量增加的可扩展性\"><a href=\"#随着细胞数量增加的可扩展性\" class=\"headerlink\" title=\"随着细胞数量增加的可扩展性\"></a>随着细胞数量增加的可扩展性</h2><p>本协议中介绍的大多数函数在分析空间解析的单细胞数据时都可以处理数百万个细胞。然而，在进行非线性降维、聚类（除k均值聚类外）、图像块检测（当扩展许多图像块时）和细胞表型相互作用测试时，可能会出现内存和运行时问题。这些问题可以通过imcRtools中实现的函数来缓解，这些函数易于并行化或使用近似方法来检测最近邻。对于相互作用测试函数，当同时分析数百万个细胞时，可能会出现内存问题。作为一种解决方法，可以按图像子集处理数据集，因为统计信息是按图像计算的。</p>\n<h1 id=\"材料\"><a href=\"#材料\" class=\"headerlink\" title=\"材料\"></a>材料</h1><h2 id=\"设备\"><a href=\"#设备\" class=\"headerlink\" title=\"设备\"></a>设备</h2><h3 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h3><p>• 要运行该工作流程，需要一台装有最新版本的Windows、Mac或Linux操作系统（OS）的电脑。随着数据集大小的增加，所需的内存也会增加，我们建议使用至少8GB的随机存取存储器（RAM）来分析所提供的数据集（14600×600像素的图像，40个通道，47859个细胞）。对于更大的数据集（数百万个细胞），我们建议使用至少64GB的RAM。或者，如果可以安装Docker（见“设备安装”部分），则可以使用高性能电脑。对于本手稿，工作流程是在MacOS Big Sur（11.7.4）、2.7 GHz四核Intel Core i7、16 GB 2133 MHz LPDDR3上运行的。</p>\n<h3 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件\"></a>软件</h3><p>• napari &amp; napari-imc（针对IMC）：使用多维图像查看器napari（<a href=\"https://napari.org)以及用于加载imc文件的napari-imc插件(https//github.com/BodenmillerGroup/napari-imc%EF%BC%89%E6%9D%A5%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E6%A3%80%E6%9F%A5%E5%8E%9F%E5%A7%8B%E7%9A%84%E5%A4%9A%E9%87%8D%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E3%80%82%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84conda%EF%BC%88https://conda.io%EF%BC%89%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AE%89%E8%A3%85%E4%BA%86Python\">https://napari.org）以及用于加载IMC文件的napari-imc插件（https://github.com/BodenmillerGroup/napari-imc）来可视化和检查原始的多重成像数据。我们在一个新的conda（https://conda.io）环境中安装了Python</a> 3.9.12（<a href=\"https://www.python.org)、napari/\">https://www.python.org）、napari</a> 0.4.16和napari-imc 0.6.5；安装说明见下文。</p>\n<p>• 基于深度学习的分割：使用多通道图像处理工具包steinbock（<a href=\"https://bodenmillergroup.github.io/steinbock%EF%BC%89%E5%AF%B9%E5%A4%9A%E9%87%8D%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E5%B9%B6%E6%8F%90%E5%8F%96%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE%E3%80%82%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8Docker\">https://bodenmillergroup.github.io/steinbock）对多重成像数据进行预处理，执行图像分割并提取单细胞数据。我们使用Docker</a> Desktop 4.9.0 for Mac从GitHub容器注册表中拉取了steinbock Docker容器v0.16.0；安装说明见“设备安装”部分。</p>\n<p>• 基于像素分类的分割：使用基于随机森林的像素分类和基于分水岭的细胞分割方法进行多通道图像处理，使用的是基于Ilastik&#x2F;CellProfiler的分割管道v3.6（<a href=\"https://bodenmillergroup.github.io/ImcSegmentationPipeline/%EF%BC%89%EF%BC%9B%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E8%A7%81%E2%80%9C%E8%AE%BE%E5%A4%87%E5%AE%89%E8%A3%85%E2%80%9D%E9%83%A8%E5%88%86%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AF%A5%E7%AE%A1%E9%81%93%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%E4%BB%A5%E4%B8%8B%E8%BD%AF%E4%BB%B6%EF%BC%9A\">https://bodenmillergroup.github.io/ImcSegmentationPipeline/）；安装说明见“设备安装”部分。此外，要使用该管道，还需要安装以下软件：</a></p>\n<p>  – Ilastik：在细胞分割之前用于像素分类的Ilastik软件21，可从<a href=\"https://www.ilastik.org/download.html%E5%AE%89%E8%A3%85%E3%80%82%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AFv1.4.0%E3%80%82\">https://www.ilastik.org/download.html安装。本工作流程使用的版本是v1.4.0。</a></p>\n<p>  – CellProfiler：用于分割单个细胞的CellProfiler软件22，可在Windows（64位）和MacOS（10.14+）上从<a href=\"https://cellprofiler.org/previous-releases%E5%AE%89%E8%A3%85%E3%80%82%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AFv4.2.1%E3%80%82\">https://cellprofiler.org/previous-releases安装。本工作流程使用的版本是v4.2.1。</a></p>\n<p>• R设置：图像处理后的下游分析使用的是统计编程语言R，可从<a href=\"https://cran.r-project.org/%E6%8C%89%E7%85%A7%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%B4%E6%98%8E%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AFv4.3.0%E3%80%82\">https://cran.r-project.org/按照特定操作系统的说明进行安装。本工作流程使用的版本是v4.3.0。</a></p>\n<p>RStudio软件为R中的数据分析提供了一个易于使用的图形用户界面（GUI）。它可以从<a href=\"https://www.rstudio.com/products/rstudio/download/%E5%AE%89%E8%A3%85%E3%80%82%E4%B8%BA%E4%BA%86%E6%89%A7%E8%A1%8C%E6%89%80%E5%B1%95%E7%A4%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BA%86RStudio\">https://www.rstudio.com/products/rstudio/download/安装。为了执行所展示的工作流程，我们使用了RStudio</a> Server版本2023.03.0。</p>\n<p>以下是本工作流程中使用的主要R库的版本。此外，补充说明1列出了工作流程中使用的所有R库的软件版本。</p>\n<p>SpatialExperiment版本1.10.0（参考文献28）<br>SingleCellExperiment 1.22.0（参考文献17）<br>CATALYST版本1.24.0（参考文献24）<br>imcRtools版本1.6.0<br>scuttle版本1.10.0（参考文献58）<br>scater版本1.28.0（参考文献58）<br>batchelor版本1.16.0（参考文献30）<br>bluster版本1.10.0<br>scran版本1.28.0（参考文献59）<br>caret版本6.0-94<br>Cytomapper 版本 1.12.0<br>DittoSeq 版本 1.12.0（参考文献29）<br>Tidyverse 版本 2.0</p>\n<h2 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h2><p>IMC 示例数据：我们提供了一个小型IMC数据集作为示例，以展示多通道图像处理和空间分辨单细胞数据分析。这些数据是使用Hyperion成像系统（Standard BioTools）在大型适应性癌症患者队列的综合免疫分析（IMMUcan）项目中生成的。数据可访问于<a href=\"https://zenodo.org/record/7575859%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E6%96%87%E4%BB%B6%EF%BC%9A\">https://zenodo.org/record/7575859，包含以下文件：</a></p>\n<ul>\n<li><p>Patient1.zip, Patient2.zip, Patient3.zip, Patient4.zip：四个患者样本的原始IMC数据。每个ZIP归档包含一个文件夹，其中包含一个MCD文件（所有采集的数据和元数据）和多个TXT文件（每个采集一个文件，无元数据）。</p>\n</li>\n<li><p>compensation.zip：此ZIP归档包含一个文件夹，其中包含一个MCD文件和多个TXT文件。采集了“溢出载玻片”的多个点，每个TXT文件根据点样金属命名。这些数据用于通道溢出校正（步骤14–21）。</p>\n</li>\n<li><p>sample_metadata.csv：此文件将每个患者与其癌症类型相关联（SCCHN，头颈癌；BCC，乳腺癌；NSCLC，肺癌；CRC，结直肠癌）。</p>\n</li>\n<li><p>我们还提供了steinbock格式的panel.csv文件，其中包含实验中使用的每个抗体或通道的元数据。在此文件中，“channel”列指示用于标记每个抗体的金属同位素。“name”列包含每个抗体的蛋白质靶点。“keep”列指示哪些通道是从原始数据中提取的，因此在下游分析中保留。重要的是，“keep”列设置为1的行的顺序与提取的多通道图像中通道的顺序相匹配。最后，“deepcell”列指示在使用DeepCell&#x2F;Mesmer进行自动图像分割时使用了哪些通道（即聚合）：核通道设置为1，细胞质通道设置为2，其他&#x2F;未使用的通道留空。该文件可访问于<a href=\"https://zenodo.org/record/7624451%E3%80%82\">https://zenodo.org/record/7624451。</a></p>\n</li>\n<li><p>此外，我们还提供了包含先前筛选细胞的SpatialExperiment对象。这些细胞构成了基于分类的表型分析中的真实细胞表型标签（步骤28）。数据可访问于<a href=\"https://zenodo.org/record/7647079%E3%80%82\">https://zenodo.org/record/7647079。</a></p>\n</li>\n</ul>\n<h2 id=\"设备设置\"><a href=\"#设备设置\" class=\"headerlink\" title=\"设备设置\"></a>设备设置</h2><h3 id=\"安装说明\"><a href=\"#安装说明\" class=\"headerlink\" title=\"安装说明\"></a>安装说明</h3><p>除非另有说明，否则本节中的命令必须在命令行上执行（Windows上的“命令提示符”或“Anaconda提示符”，Linux&#x2F;Mac OS上的“终端”）。</p>\n<ul>\n<li>napari 和 napari-imc：</li>\n</ul>\n<ol>\n<li><p>根据<a href=\"https://docs.conda.io/projects/conda/en/latest/user-guide/install/%E4%B8%8A%E7%9A%84%E8%AF%B4%E6%98%8E%E5%AE%89%E8%A3%85conda%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E3%80%82\">https://docs.conda.io/projects/conda/en/latest/user-guide/install/上的说明安装conda包管理器。</a></p>\n</li>\n<li><p>创建一个新的conda环境，包含Python 3.9：</p>\n</li>\n</ol>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n napari-imc -y python=<span class=\"number\">3.9</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>激活conda环境并安装napari和napari-imc：</li>\n</ol>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate napari-imc</span><br><span class=\"line\"></span><br><span class=\"line\">pip install <span class=\"string\">&quot;napari[all]==0.4.16&quot;</span> napari-imc==<span class=\"number\">0.6</span><span class=\"number\">.5</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>基于深度学习的分割：有关安装容器化steinbock工具包的说明，可在steinbock在线文档中找到（<a href=\"https://bodenmillergroup.github.io/steinbock/%EF%BC%89%E3%80%82%E7%89%B9%E5%88%AB%E6%98%AF%EF%BC%8C%E8%A6%81%E8%BF%90%E8%A1%8Csteinbock%E5%AE%B9%E5%99%A8%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%89%E8%A3%85Docker%EF%BC%88%E8%AF%B7%E5%8F%82%E9%98%85%E5%9C%A8%E7%BA%BF%E8%AF%B4%E6%98%8E%EF%BC%89%E3%80%82%E5%AF%B9%E4%BA%8E%E6%9C%AC%E6%89%8B%E7%A8%BF%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E5%88%AB%E5%90%8D%E8%BF%90%E8%A1%8Csteinbock%EF%BC%9A\">https://bodenmillergroup.github.io/steinbock/）。特别是，要运行steinbock容器，需要先安装Docker（请参阅在线说明）。对于本手稿，我们使用以下别名运行steinbock：</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> steinbock=<span class=\"string\">&quot;docker run -v /path/to/data/steinbock:/data -u (id−u):(id -g) ghcr.io/bodenmillergroup/steinbock:0.16.0&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>▲ 关键说明：在上述命令中，需要将&#x2F;path&#x2F;to&#x2F;data&#x2F;steinbock替换为预期的steinbock数据&#x2F;工作目录。</p>\n<ul>\n<li>基于像素分类的分割：基于像素分类的分割流程的预处理步骤是使用自定义脚本在Python中执行的。要设置预处理脚本，需要执行以下步骤：</li>\n</ul>\n<ol>\n<li>根据<a href=\"https://docs.conda.io/projects/conda/en/latest/user-guide/install/%E4%B8%8A%E7%9A%84%E8%AF%B4%E6%98%8E%E5%AE%89%E8%A3%85conda%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E3%80%82\">https://docs.conda.io/projects/conda/en/latest/user-guide/install/上的说明安装conda包管理器。</a></li>\n<li>克隆代码仓库</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/BodenmillerGroup/ImcSegmentationPipeline.git</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建imcsegpipe的conda环境：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ImcSegmentationPipeline</span><br><span class=\"line\">conda <span class=\"built_in\">env</span> create -f environment.yml</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>通过打开CellProfler的图形用户界面（GUI），选择Preferences并将CellProfler插件目录设置为path&#x2F;to&#x2F;ImcSegmentationPipeline&#x2F;resources&#x2F;ImcPluginsCP&#x2F;plugins，来配置CellProfler以使用所需的插件，然后重启CellProfler。</li>\n</ol>\n<p>▲ 关键说明：将此路径调整为下载的CellProfler插件所在的位置。按照上述方式克隆仓库时，插件位于resources&#x2F;ImcPluginsCP&#x2F;plugins中。</p>\n<ul>\n<li><p>R库：该工作流程强调了使用cytomapper、imcRtools和其他R包。以下R命令会安装所有相关的R包：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"punctuation\">(</span><span class=\"operator\">!</span>requireNamespace<span class=\"punctuation\">(</span><span class=\"string\">&quot;BiocManager&quot;</span><span class=\"punctuation\">,</span> quietly <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"> install.packages<span class=\"punctuation\">(</span><span class=\"string\">&quot;BiocManager&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">BiocManager<span class=\"operator\">::</span>install<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;pheatmap&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;viridis&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tiff&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;distill&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ggrepel&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;patchwork&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;mclust&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;RColorBrewer&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;uwot&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Rtsne&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;caret&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;randomForest&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ggridges&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;gridGraphics&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scales&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;CATALYST&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scuttle&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scater&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;dittoSeq&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tidyverse&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;batchelor&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;bluster&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;scran&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"string\">&quot;cytomapper&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;imcRtools&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>可以从GitHub或Bioconductor直接安装R包的开发版本，同时指定开发版本。开发版本通常包含发行版中尚未提供的功能；然而，对于使用描述的工作流程，无需从开发源安装R包。<br>为确保工作流程的可重复性，我们还提供了一个Docker容器，该容器打包了所有相关的R库。以下命令行调用可获取Docker镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull ghcr.io/bodenmillergroup/imcdataanalysis:2023-05-01</span><br></pre></td></tr></table></figure>\n\n<p>使用Docker容器重现分析的说明可在<a href=\"https://github.com/BodenmillerGroup/IMCDataAnalysis/tree/main/publication%E4%B8%8A%E6%9F%A5%E7%9C%8B%E3%80%82%E6%AD%A4%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E5%88%86%E6%9E%90%E6%98%AF%E5%9C%A8Docker%E5%AE%B9%E5%99%A8%E5%86%85%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9B%E4%BD%86%E6%98%AF%EF%BC%8CR%E5%8C%85%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E4%B8%8A%E8%BF%B0%E8%AF%B4%E6%98%8E%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E3%80%82\">https://github.com/BodenmillerGroup/IMCDataAnalysis/tree/main/publication上查看。此工作流程中显示的分析是在Docker容器内执行的；但是，R包也可以按照上述说明手动安装。</a></p>\n<h2 id=\"数据下载\"><a href=\"#数据下载\" class=\"headerlink\" title=\"数据下载\"></a>数据下载</h2><p>在R语言中，可以按照以下步骤下载IMC示例数据和门控细胞：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">options<span class=\"punctuation\">(</span>timeout <span class=\"operator\">=</span> <span class=\"number\">10000</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 设置超时时间为10000秒</span></span><br><span class=\"line\">dir.create<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/raw&quot;</span><span class=\"punctuation\">,</span> recursive <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 创建数据存放目录，若上级目录不存在则一并创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载面板文件</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7624451/files/panel.csv&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/panel.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载患者数据</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient1.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient1.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient2.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient2.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient3.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient3.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/Patient4.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/steinbock/raw/Patient4.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载补偿文件并解压</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/compensation.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/compensation.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">unzip<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/compensation.zip&quot;</span><span class=\"punctuation\">,</span> exdir<span class=\"operator\">=</span><span class=\"string\">&quot;data&quot;</span><span class=\"punctuation\">,</span> overwrite<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 解压到data目录，若文件已存在则覆盖</span></span><br><span class=\"line\">unlink<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/compensation.zip&quot;</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 删除压缩包文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载样本元数据文件</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7575859/files/sample_metadata.csv&quot;</span><span class=\"punctuation\">,</span> destfile <span class=\"operator\">=</span> <span class=\"string\">&quot;data/sample_metadata.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载门控细胞数据并解压</span></span><br><span class=\"line\">download.file<span class=\"punctuation\">(</span><span class=\"string\">&quot;https://zenodo.org/record/7647079/files/gated_cells.zip&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;data/gated_cells.zip&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">unzip<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/gated_cells.zip&quot;</span><span class=\"punctuation\">,</span> exdir<span class=\"operator\">=</span><span class=\"string\">&quot;data&quot;</span><span class=\"punctuation\">,</span> overwrite<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 解压到data目录，若文件已存在则覆盖</span></span><br><span class=\"line\">unlink<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/gated_cells.zip&quot;</span><span class=\"punctuation\">)</span> <span class=\"comment\"># 删除压缩包文件</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键说明：下载的数据和相关的面板文件用于steinbock。若要下载用于基于像素分类的分割流程的示例数据，请遵循步骤6B(iii)。</p>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><h2 id=\"原始成像数据检查（IMC专用）\"><a href=\"#原始成像数据检查（IMC专用）\" class=\"headerlink\" title=\"原始成像数据检查（IMC专用）\"></a>原始成像数据检查（IMC专用）</h2><p>● 耗时：20–40分钟</p>\n<p>除非另有说明，否则本节中的命令必须在命令行中执行（在Windows上为“命令提示符”或“Anaconda提示符”，在Linux&#x2F;Mac OS上为“终端”）。</p>\n<ol>\n<li>激活之前创建的napari-imc conda环境并启动napari：</li>\n</ol>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate napari-imc</span><br><span class=\"line\">napari</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在napari中，使用“文件”→“打开文件(s)”打开包含原始IMC数据的MCD文件。打开文件后，将出现napari-imc小部件（图3，右侧）。</p>\n</li>\n<li><p>在MCD文件树（napari-imc小部件，顶部）中，选择要在napari主面板中以叠加方式可视化的全景图和&#x2F;或采集数据。</p>\n</li>\n<li><p>对于上一步中选择的采集数据，选择要可视化的通道（napari-imc小部件，中部），并调整通道属性，如颜色和对比度（napari-imc小部件，底部）。</p>\n</li>\n<li><p>使用napari中的平移&#x2F;缩放功能对合成图像进行定性检查。</p>\n</li>\n</ol>\n<h2 id=\"多重组织图像处理\"><a href=\"#多重组织图像处理\" class=\"headerlink\" title=\"多重组织图像处理\"></a>多重组织图像处理</h2><p>除非另有说明，否则本节中的命令必须在命令行中执行（在Windows上为“命令提示符”或“Anaconda提示符”，在Linux&#x2F;Mac OS上为“终端”）。</p>\n<p>多重组织图像处理通常包括图像提取和预处理、图像分割以及单细胞数据提取等步骤。在此，我们提出了两种用于分割多重组织成像数据的替代工作流程：</p>\n<p>（A）基于steinbock的深度学习工作流程，steinbock是我们用于多重组织图像处理的容器化工具包（图4，DeepCell变体）。该工作流程可通过命令行界面进行，并利用DeepCell包中实现的深度学习Mesmer算法，基于预训练神经网络以全自动方式分割细胞。所有steinbock命令的输入和输出文件及目录均可通过命令行选项进行控制。若未明确指定这些选项，steinbock命令行界面将预期以下数据&#x2F;工作目录结构：<br>steinbock数据&#x2F;工作目录<br>├── raw（用户提供，从原始数据开始）<br>├── panel.csv（用户提供或从原始数据生成，步骤6(A)）<br>├── img（用户提供，从TIFF文件开始，或从原始数据提取，步骤6(A)）<br>├── masks（步骤7(A)生成，细胞分割掩码）<br>├── intensities（步骤8(A)生成，平均细胞像素强度）<br>├── regionprops（步骤8(A)生成，形态细胞特征）<br>├── neighbors（步骤8(A)生成，空间细胞邻域列表）</p>\n<p>（B）使用Jupyter笔记本和CellProfiler管道简化的基于像素分类的工作流程（图5）。在此工作流程中，首先使用Ilastik软件手动训练一个针对当前数据集定制的随机森林像素分类器。然后，使用CellProfiler管道基于像素分类来分割单个细胞。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig3.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig3.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图3 | napari和napari-imc的截图。可视化存储在Patient4.mcd文件中的原始IMC数据（采集6、8叠加在全景图9、10、11上）。展示的是CD163（黄色）、CD20（红色）、CD3（绿色）、E-钙黏蛋白（青色）和DNA（蓝色）。对比度限制已手动调整以便目视检查。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig4.png\" alt=\"图4 | 使用steinbock的典型多重图像处理工作流程。\n各个步骤用箭头表示，下方列出了相应的steinbock命令（命令行界面）和Python模块（编程使用）。进一步的参数和第三方软件（包含在steinbock Docker容器中）已叠加在箭头上。输入和输出数据以概念方式表示。图示步骤包括从平台特定的原始数据中提取图像的预处理步骤、（基于分类的）分割步骤以获得细胞掩膜（展示了两种替代工作流程）、测量步骤以提取细胞水平特征，并导出为与各种下游分析环境（例如Python、R、CytoScape76、histoCAT18）兼容的文件格式，以表示空间单细胞数据。\"></p>\n<p>基于像素分类的分割管道的文件夹结构如下所示。该管道期望将原始IMC数据放置在“raw”文件夹中，或将OME–TIFF数据放置在“ometiff”文件夹中。</p>\n<p>基于Ilastik&#x2F;CellProfiler的分割管道数据&#x2F;工作目录<br>├── raw（用户提供，当从原始数据开始时）<br>├── analysis<br> ├── cpin<br> ├── ometiff（用户提供，当从OME-TIFF开始时，或在步骤6(B)中从原始数据生成）<br> ├── cpout（在步骤6-8(B)中生成；最终输出文件）<br> ├── histocat（在步骤6(B)中生成；用于histoCAT导入的文件）<br> ├── crops（在步骤7(B)中生成；Ilastik裁剪图像）<br> ├── ilastik（在步骤6-7(B)中生成；与Ilastik相关的文件）<br>├── scripts（原始数据处理脚本）<br>├── resources（CellProfiler管道和插件）</p>\n<p>▲ 重要提示：steinbock工具包（图4）也支持此处所示的基于像素分类的分割方法（图5）。为简洁起见，在本方案中，仅展示了steinbock的深度学习工作流程；如需更多信息，请参阅steinbock的在线文档。</p>\n<p>这两个工作流程都接受用户提供的多通道图像作为输入，这些图像可以是TIFF文件（steinbock；需放置在“img”文件夹中），也可以是OME–TIFF格式（基于像素分类的分割管道；需放置在“analysis&#x2F;ometiff”文件夹中）。另外，也可以直接将原始IMC数据提供给这两个工作流程（需放置在“raw”文件夹中，适用于两个工作流程），并使用我们自主研发的readimc Python包（框1）将其自动转换为相应的文件格式。此外，这两种工作流程都需要一个CSV格式的面板文件，用于指定实验中使用的抗体以及在后续处理中应保留的任何额外通道（例如，用于复染的金属61）。这些面板文件可以自动从原始数据中生成（steinbock），也可以由用户手动指定（steinbock和基于像素分类的工作流程）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig5.png\" alt=\"图5 | 基于像素分类的分割管道概述。\n数据预处理步骤包括将原始MCD文件转换为OME–TIFF和TIFF文件。图像分割通过以下步骤完成：（i）裁剪图像，（ii）训练Ilastik分类器并提取像素概率，以及（iii）对像素概率进行细胞分割，从而生成分割掩膜。通过结合多通道图像（完整堆栈）和分割掩膜来执行单细胞数据提取。所得单细胞数据可以使用imcRtools包进行读取和分析，而多通道图像和分割掩膜可以使用cytomapper包进行可视化。BiocStickers图案根据Creative Commons CC0 1.0许可证从https://github.com/Bioconductor/BiocStickers重新印制。\"></p>\n<hr>\n<p>框1<br>原始IMC数据</p>\n<p>Hyperion成像系统生成专有MCD&#x2F;TXT格式的文件，这些文件存储在以下文件夹结构中：<br>├── {XYZ}_ROI_001_1.txt<br>├── {XYZ}_ROI_002_2.txt<br>├── {XYZ}_ROI_003_3.txt<br>├── {XYZ}.mcd</p>\n<p>在这里，{XYZ}定义了文件名，ROI_001、ROI_002、ROI_003是用户为所选ROI定义的名称（描述），而1、2、3表示唯一的采集标识符。在选择ROI时，可以在Standard BioTools软件中指定ROI描述条目。MCD文件包含所有采集到的ROI的原始成像数据和完整元数据，而每个TXT文件则包含单个ROI的数据（不包含元数据）。为了遵循一致的命名方案并捆绑所有元数据，我们建议将文件夹压缩为ZIP文件。每个ZIP文件应仅包含一个MCD文件及其对应的TXT文件，并且ZIP文件的名称应与MCD文件的名称相匹配。</p>\n<hr>\n<h2 id=\"数据预处理（特定于技术）\"><a href=\"#数据预处理（特定于技术）\" class=\"headerlink\" title=\"数据预处理（特定于技术）\"></a>数据预处理（特定于技术）</h2><p>● 选项A耗时5分钟，选项B耗时10–20分钟</p>\n<p>在本方案中，数据预处理是指从原始成像数据中提取多通道图像，并为后续处理做准备。所需步骤取决于成像技术；在此，我们展示了原始IMC数据的预处理，其中包括热点像素过滤步骤（框2）。在图像分割之前，可以进行额外的模态特异性预处理步骤，如IMC去噪62或通道间溢出校正（步骤14–21），以促进后续的图像分析步骤。以前，对于IMC数据，热点像素过滤就足以进行有效的分割。</p>\n<p>对于除IMC之外的多重组织成像模态，可以使用steinbock的预处理外部命令将外部预处理过的二维多通道图像转换为steinbock兼容的TIFF文件。例如，迭代多重组织成像方法的外部预处理通常包括诸如拼接和注册对应于单个成像周期的图像等任务63。有关更多详细信息，请参阅steinbock的在线文档。</p>\n<ol start=\"6\">\n<li><p>预处理多通道图像。<br>  （A）基于深度学习的工作流程<br> （i）在steinbock面板文件格式（表1；请参阅steinbock的在线文档）中手动创建一个panel.csv文件，并将其放置在steinbock的数据&#x2F;工作目录中。本方案中使用的完整steinbock面板文件可从<a href=\"https://zenodo.org/record/7624451%E4%B8%8B%E8%BD%BD%E3%80%82\">https://zenodo.org/record/7624451下载。</a></p>\n<p> ▲ 关键信息：在使用steinbock处理自定义IMC数据集时，可以使用steinbock的预处理imc面板命令（请参阅steinbock的在线文档），从放置在原始数据目录中的MCD&#x2F;TXT文件中自动生成模板面板文件。此命令将自动填充“通道”和“名称”列，并可作为创建有效面板文件的起点。<br> （ii）从MCD&#x2F;TXT文件中提取单个IMC采集，仅保留面板文件中“保留”列设置为1的通道。使用50的阈值过滤热点像素，并将生成的图像存储为TIFF文件。提取图像中通道的顺序由面板文件中通道的顺序（“通道”列）决定。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock preprocess imc images --hpf 50</span><br></pre></td></tr></table></figure>\n<p> ◆ 故障排除</p>\n</li>\n</ol>\n<p>  （B）基于像素分类的工作流程</p>\n<pre><code>（i）创建一个包含列条目“金属标签”、“full”和“ilastik”的面板文件（表2）。一个可用于所提供数据的示例面板文件可在https://zenodo.org/record/7575859上访问。\n\n（ii）在ImcSegmentationPipeline文件夹内，激活之前创建的imc-segpipe conda环境（参见“安装说明”），并启动jupyter-lab：\n\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate imcsegpipe</span><br><span class=\"line\">jupyter lab</span><br></pre></td></tr></table></figure>\n\n（iii）按照位于“scripts/imc_preprocessing.ipynb”的脚本执行以下预处理任务：\n\n    • 根据“scripts/download_examples.ipynb”脚本下载示例数据\n    • 将文件类型从MCD转换为OME–TIFF\n    • （可选）将OME–TIFF文件转换为单通道TIFF文件，以便在histoCAT18中使用\n    • 将OME–TIFF文件转换为热点像素过滤后的多通道TIFF堆栈，用于（1）图像分析（包含在“full”列中的通道）和（2）ilastik像素分类（指定在“ilastik”列中的通道）\n    \n</code></pre>\n<hr>\n<p>框2<br>热点像素过滤<br>热点像素过滤的工作原理是将每个像素与其八邻域（即切比雪夫距离为1的相邻像素）进行比较。如果某个像素与其八个相邻像素中的最大值之间的差异超过热点像素过滤阈值，则将该像素设置为最大相邻像素值（“热点像素过滤后”）。在这里，使用的热点像素过滤阈值为50；但是，该阈值可以根据具体的数据集进行调整。</p>\n<hr>\n<p><strong>表1 | steinbock面板文件格式中的示例面板文件（摘录）</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table1.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table1.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\"></p>\n<p>每一行对应于多重成像数据中的一个通道。在IMC（多重同位素标记质量细胞成像）数据中，“通道”列指示用于标记每种抗体的独特金属同位素，该列用于将面板文件和原始数据相关联。“名称”列包含唯一、用户定义的通道名称（例如，每种抗体的蛋白质靶点），这些名称将在派生的单细胞数据和下游分析中使用。“保留”列指示应从原始数据中提取并因此保留以供下游分析哪些通道。重要的是，保留列设置为1的行的顺序将与提取的多通道图像中通道的顺序相匹配。最后，“deepcell”列指示应使用（即聚合）哪些通道，以便使用DeepCell&#x2F;Mesmer进行全自动图像分割（核通道标记为1，细胞质通道标记为2，其他&#x2F;未使用的通道该列留空）。本方案中使用的完整steinbock面板文件已从“数据下载”部分的<a href=\"https://zenodo.org/record/7624451%E4%B8%8B%E8%BD%BD%E3%80%82\">https://zenodo.org/record/7624451下载。</a></p>\n<p><strong>表2 | 基于像素分类的工作流的面板规范</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table2.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/table2.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\"></p>\n<p>“金属标签”列存储每个采集通道的金属同位素。“全部”和“ilastik”列设置为0或1。“全部”列中的1指定应写入图像堆栈的通道，该图像堆栈稍后将用于提取特征（也称为“全部堆栈”）。“ilastik”列中的1表示将用于Ilastik像素分类的通道，因此将用于图像分割（也称为“ilastik堆栈”）。</p>\n<h2 id=\"图像分割\"><a href=\"#图像分割\" class=\"headerlink\" title=\"图像分割\"></a>图像分割</h2><p>● 选项A耗时10–20分钟，选项B耗时2–3小时</p>\n<ol start=\"7\">\n<li>执行图像分割以检测单个细胞，生成并存储为TIFF文件的细胞掩膜。细胞掩膜是与相应输入图像大小相同的单通道灰度图像，其中对应于同一细胞的像素显示相同的灰度值（背景像素的像素值为0）。</li>\n</ol>\n<p>  （A）基于深度学习的工作流<br>    （i）使用DeepCell软件包中实现的启用深度学习的Mesmer算法，基于预训练神经网络执行全自动细胞分割。在以下命令中，将根据面板文件中的“deepcell”列对通道进行最小-最大归一化和均值聚合。</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock segment deepcell --minmax</span><br></pre></td></tr></table></figure>\n\n◆ 故障排除\n</code></pre>\n<p>  （B）基于像素分类的工作流<br>    （i）为Ilastik像素分类准备图像。</p>\n<pre><code>第一步，使用CellProfiler中的“resources/pipelines/1_prepare_ilastik.cppipe”管道为像素标记和分类准备图像。在CellProfiler中导入管道后，首先执行以下步骤：\n\n• 将“analysis/ilastik”文件夹拖放到“Images”下的窗口中\n\n• 在“输出设置”中，将“analysis/crops”文件夹设置为“默认输出文件夹”\n\n管道将读取“analysis/ilastik”文件夹中所有包含“_ilastik”后缀的多通道图像。以下步骤是管道的一部分：\n\n• 计算所有通道的平均强度，乘以100以匹配实际标记的范围，并将其作为第一通道添加到ilastik堆栈中\n\n• ilastik堆栈的像素按两倍比例放大。这将使图像中的像素数量增加四倍，并便于像素标记\n\n▲ 关键提示：为便于视觉像素标记，在使用如IMC等分辨率较低的复用成像技术时，我们建议放大像素。对于基于荧光的技术，可以跳过此步骤。\n\n• 将ilastik堆栈裁剪成较小的视野。默认情况下，这些是500×500像素的裁剪图像；对于大型数据集，较小的图像裁剪即可满足需求\n\n• 将放大的ilastik堆栈以HDF5格式（文件名以_s2.h5结尾）保存到“analysis/ilastik”文件夹中，并将裁剪后的图像保存到“analysis/crops”文件夹中\n</code></pre>\n<p>  （ii）训练和应用Ilastik像素分类器。可以在<a href=\"https://zenodo.org/record/7997296%E4%B8%8A%E8%AE%BF%E9%97%AE%E5%9C%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E4%B8%8A%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84Ilastik%E5%83%8F%E7%B4%A0%E5%88%86%E7%B1%BB%E5%99%A8%E3%80%82\">https://zenodo.org/record/7997296上访问在提供的示例数据上预训练的Ilastik像素分类器。</a></p>\n<p>  打开Ilastik并按照以下步骤操作：</p>\n<p>  • 创建一个新的“Pixel Classification”（像素分类）项目</p>\n<p>  • 在“Input Data”（输入数据）下，点击“Add New…”（添加新…）&gt;“Add separate Image(s)”（添加单独的图像），并选择“analysis&#x2F;crops”文件夹中的所有.h5文件</p>\n<p>  • 特征选择：我们一般建议选择与σ ≥ 1的所有特征</p>\n<p>  • 通过基于三类（标签1为“细胞核”，标签2为“细胞质”，标签3为“背景”）标记像素来训练Ilastik分类器。使用“Live Update”（实时更新）视图观察三类的预测结果。通过点击“Uncertainty”（不确定性）旁边的眼睛符号来观察不确定性，这将显示分类不确定性最高的区域。这些区域需要重新标记</p>\n<p>  ▲ 关键提示：为了在分割过程中分离单个细胞，建议在两个靠得很近的细胞核之间绘制一条“细胞质线”，并用“细胞质”圈住细胞核。不应标记图像的大片区域，而应跨不同细胞和组织区域相对稀疏地放置像素标签。当在细胞核&#x2F;细胞质和细胞质&#x2F;背景边界处不确定性最高，而在其他位置不确定性较低时，分类器训练良好。</p>\n<p>  • 分类器训练良好后，将预测结果导出为无符号的16位TIFF图像</p>\n<p>  • 通过选择“analysis&#x2F;ilastik”文件夹中的所有_s2.h5文件来批量处理所有文件。此步骤将生成包含图像分割像素概率的三通道（细胞核、细胞质、背景）图像</p>\n<p>（iii）分割单个细胞。</p>\n<p>将‘resources&#x2F;pipelines&#x2F;2_segment_ilastik.cppipe’流程导入CellProfiler，并执行以下步骤：</p>\n<p>•\t将‘analysis&#x2F;ilastik’文件夹拖放到“Images”（图像）窗口中<br>•\t在“Output Settings”（输出设置）中，将“Default Output Folder”（默认输出文件夹）调整为‘analysis&#x2F;cpout’<br>以下步骤将作为流程的一部分自动执行：<br>•\t读取像素概率，将其缩小以匹配初始图像的尺寸，并拆分为三个通道<br>•\t将核通道和细胞质通道相加，形成一个单一通道<br>•\t根据指定的面积阈值对细胞核进行分割和过滤<br>•\t通过扩展核分割掩码到全细胞概率的边缘来分割整个细胞<br>•\t将分割掩码作为16位单通道TIFF图像写入到‘analysis&#x2F;cpout&#x2F;masks’文件夹中<br>•\t将缩小后的像素概率图像作为16位三通道TIFF图像写入到‘analysis&#x2F;cpout&#x2F;probabilities’文件夹中<br>◆ 故障排除</p>\n<h2 id=\"单细胞数据提取\"><a href=\"#单细胞数据提取\" class=\"headerlink\" title=\"单细胞数据提取\"></a>单细胞数据提取</h2><p>● 选项A耗时5分钟，选项B耗时10分钟</p>\n<ol start=\"8\">\n<li>从分割后的图像（即多通道图像和相应细胞掩码的配对）中提取空间分辨的单细胞数据。</li>\n</ol>\n<p>(A) 基于深度学习的工作流程<br>  (i) 对于每张图像，提取每个细胞和标记物的平均像素强度。得到的细胞水平的强度值以单独的CSV文件存储（每张图像一个文件）：<br>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock measure intensities</span><br></pre></td></tr></table></figure></p>\n<p>  (ii) 对于每张图像，提取每个细胞的形态学特征（面积、质心、长轴&#x2F;短轴长度、默认离心率；若要计算其他形态学特征，请参阅steinbock在线文档）。得到的细胞水平特征以单独的CSV文件存储（每张图像一个文件）：<br>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock measure regionprops</span><br></pre></td></tr></table></figure></p>\n<p>  (iii) 在每张图像中，检测空间上接近的细胞。得到的空间细胞图（框3）以单独的CSV格式有向边列表存储（每张图像一个文件）：<br>  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">steinbock measure neighbors --<span class=\"built_in\">type</span> expansion --dmax 4</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>框3</p>\n<p>空间细胞图</p>\n<p>空间细胞图（也称为“邻域图”）是有向或无向的图（网络），其中细胞对应于节点，空间上邻近的细胞通过边相连。空间细胞图可用于分析细胞表型的空间共现情况（步骤31–35）。存在多种类型的空间细胞图；此处展示的是通过像素扩展构建的无向空间细胞图，在这种图中，仅当细胞在各方向上最多扩展4个像素后“接触”时，才认为它们是相邻的。</p>\n<hr>\n<p>（B）基于像素分类的工作流程</p>\n<p>（i）测量细胞特征。</p>\n<p>“resources&#x2F;pipelines&#x2F;3_measure_mask.cppipe”流程用于测量单细胞和单图像特征。将其导入CellProfiler并执行以下步骤：</p>\n<p>•\t将“analysis&#x2F;cpout”文件夹拖放到“Images”（图像）窗口中<br>•\t在“Output Settings”（输出设置）中，将“Default Output Folder”（默认输出文件夹）调整为“analysis&#x2F;cpout”，并将“Default Input Folder”（默认输入文件夹）调整为“analysis&#x2F;cpinp”<br>以下步骤是该流程的一部分：<br>•\t以16位灰度图像的形式读取分割掩码，并在保留其原始标签的同时将其转换为对象<br>•\t通过定义的距离扩展掩码来检测每个细胞的邻居<br>•\t提取每个细胞的完整堆栈通道强度和形状特征<br>•\t提取每个细胞的概率堆栈通道强度<br>•\t提取每幅图像的完整堆栈和概率堆栈强度<br>•\t将细胞、图像和实验数据保存为CSV文件。单细胞强度值通过对应于位深度的缩放因子进行缩放。对于本方案中使用的16位无符号整数图像（uint16），这些值除以2^16 - 1 &#x3D; 65,535<br>•\t将空间细胞图导出为包含边列表的CSV文件</p>\n<p>◆ 故障排除</p>\n<h1 id=\"单细胞和空间数据分析\"><a href=\"#单细胞和空间数据分析\" class=\"headerlink\" title=\"单细胞和空间数据分析\"></a>单细胞和空间数据分析</h1><p>本节中的命令必须在R中执行，RStudio软件可以简化执行过程。</p>\n<h2 id=\"数据读取\"><a href=\"#数据读取\" class=\"headerlink\" title=\"数据读取\"></a>数据读取</h2><p>● 耗时5分钟</p>\n<ol start=\"9\">\n<li>使用imcRtools包将空间分辨的单细胞数据读入R。在本方案的其余部分，我们将继续使用下面（A）中读入的steinbock生成的数据。</li>\n</ol>\n<p>（A）读取使用steinbock工具包生成的数据</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>imcRtools<span class=\"punctuation\">)</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> read_steinbock<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（B）读取CellProfiler生成的数据</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spe2 <span class=\"operator\">&lt;-</span> read_cpout<span class=\"punctuation\">(</span><span class=\"string\">&quot;path/to/analysis/cpout/&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键操作：调整路径以指向生成的空间分辨单细胞数据所在的位置。</p>\n<ol start=\"10\">\n<li>在读取单细胞数据后，需要对SpatialExperiment对象（框4）进行进一步处理。首先，根据图像名称和细胞标识符设置列名。患者标识符和ROI标识符以及癌症类型也保存在对象中，这些信息可以从提供的“data&#x2F;sample_metadata.csv”文件中读取。为了后续方便访问，选择了包含生物变异的通道。最后，使用1作为共因子，对每个通道和细胞的平均像素强度进行arsinh变换。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>tidyverse<span class=\"punctuation\">)</span></span><br><span class=\"line\">colnames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> paste0<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>sample_id<span class=\"punctuation\">,</span> <span class=\"string\">&quot;_&quot;</span><span class=\"punctuation\">,</span> spe<span class=\"operator\">$</span>ObjectNumber<span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取患者元数据</span></span><br><span class=\"line\">meta <span class=\"operator\">&lt;-</span> read_csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/sample_metadata.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 从样本名称中提取患者ID和ROI ID</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>patient_id <span class=\"operator\">&lt;-</span> str_extract<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>sample_id<span class=\"punctuation\">,</span> <span class=\"string\">&quot;Patient[1-4]&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">spe<span class=\"operator\">$</span>ROI <span class=\"operator\">&lt;-</span> str_extract<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>sample_id<span class=\"punctuation\">,</span> <span class=\"string\">&quot;00[1-8]&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Store cancer type in SPE object</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>indication <span class=\"operator\">&lt;-</span> meta<span class=\"operator\">$</span>Indication<span class=\"punctuation\">[</span>match<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>patient_id<span class=\"punctuation\">,</span> meta<span class=\"operator\">$</span>`Sample ID`<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Specify which channels to use for downstream analysis</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel <span class=\"operator\">&lt;-</span> <span class=\"operator\">!</span>grepl<span class=\"punctuation\">(</span><span class=\"string\">&quot;DNA|Histone&quot;</span><span class=\"punctuation\">,</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Transform the counts</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> <span class=\"built_in\">asinh</span><span class=\"punctuation\">(</span>counts<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">/</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键提示 与通常使用5作为共因子的arsinh变换的CyTOF数据集相比，IMC数据集的强度通常要低得多。在这里，我们使用1作为共因子，这是对信号与噪声之间阈值的粗略估计。之前已有类似共因子值用于IMC数据9,11和MIBI数据64,65的分析。然而，对于不同类型的数据或信号强度更高&#x2F;更低的IMC数据集，需要调整这个共因子。虽然这通常是根据定性标准手动完成的，但最近已有基于细胞类型特异性标志物共表达来启发式优化共因子值的系统方法被提出66。另外，也可以在此阶段对数据应用其他数据处理方法，包括Jackson等人8所使用的对数&#x2F;平方根变换和数据截断。</p>\n<ol start=\"11\">\n<li>使用cytomapper包25将多通道图像作为CytoImageList容器读入。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>cytomapper<span class=\"punctuation\">)</span></span><br><span class=\"line\">images <span class=\"operator\">&lt;-</span> loadImages<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">channelNames<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键提示 在使用steinbock工具包时，面板文件、图像和单细胞数据中的通道顺序是相同的。但是，当使用其他框架（如基于像素分类的分割方法）时，在设置通道名称时需要格外小心。</p>\n<ol start=\"12\">\n<li>将分割掩码作为CytoImageList容器读入。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">masks <span class=\"operator\">&lt;-</span> loadImages<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/steinbock/masks/&quot;</span><span class=\"punctuation\">,</span> as.is <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键提示 除非另有配置（见“故障排除”），否则steinbock工具包会将分割掩码导出为16位图像。为了正确读取16位图像，需要设置‘as.is &#x3D; TRUE’参数。在读取32位图像时，应使用默认参数设置（‘as.is &#x3D; FALSE’）。</p>\n<p>◆ 故障排除</p>\n<hr>\n<p>框4<br>R中的单细胞数据容器<br>单细胞数据可以以SpatialExperiment（默认）或SingleCellExperiment对象17,28的形式读入。每个通道和细胞的平均像素强度存储在counts槽中。列代表细胞，行代表通道。与单个细胞相关的元数据存储在colData槽中。在初始图像处理后，这些元数据包括标签（ObjectNumber）、面积和每个细胞的形态学特征。此外，sample_id条目存储了从中提取每个细胞的图像名称。该工作流程支持SpatialExperiment和SingleCellExperiment对象。这些数据对象之间的主要区别在于存储所有细胞空间位置的方式。对于SingleCellExperiment容器，位置存储在colData槽中，而SpatialExperiment容器则将它们存储在spatialCoords槽中。steinbock等工具生成的空间细胞图被读入SpatialExperiment（或SingleCellExperiment）对象的colPair槽中。最后，与通道相关的元数据存储在rowData槽中。</p>\n<hr>\n<ol start=\"13\">\n<li>对于下游的可视化和分析任务，需要在存储多通道图像和分割掩码的CytoImageList对象中添加额外的元数据。在这里，通过sample_id条目将单个图像、分割掩码和空间实验（SpatialExperiment）对象中的条目进行匹配。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从图像名称中提取患者ID</span></span><br><span class=\"line\">patient_id <span class=\"operator\">&lt;-</span> str_extract<span class=\"punctuation\">(</span><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Patient[1-4]&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 从元数据文件中检索每位患者的癌症类型</span></span><br><span class=\"line\">indication <span class=\"operator\">&lt;-</span> meta<span class=\"operator\">$</span>Indication<span class=\"punctuation\">[</span>match<span class=\"punctuation\">(</span>patient_id<span class=\"punctuation\">,</span> meta<span class=\"operator\">$</span>`Sample ID`<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># 在elementMetadata中存储患者和图像级别的信息</span></span><br><span class=\"line\">mcols<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> mcols<span class=\"punctuation\">(</span>masks<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> DataFrame<span class=\"punctuation\">(</span>sample_id <span class=\"operator\">=</span> <span class=\"built_in\">names</span><span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> patient_id <span class=\"operator\">=</span> patient_id<span class=\"punctuation\">,</span></span><br><span class=\"line\"> indication <span class=\"operator\">=</span> indication<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"溢出校正（IMC特有）\"><a href=\"#溢出校正（IMC特有）\" class=\"headerlink\" title=\"溢出校正（IMC特有）\"></a>溢出校正（IMC特有）</h2><p>● 耗时：20分钟</p>\n<p>在IMC^(24)、MIBI^(67)和CyCIF^(68)等多重免疫荧光成像中，观察到两个通道之间存在低信号溢出（也称为串扰）。溢出被定义为在主要通道中可以检测到相邻通道信号的一小部分。由于溢出与相邻通道的信号成线性关系，因此可以通过之前描述的补偿方法^(24)进行校正。此处介绍的溢出校正是IMC特有的，如果假设已采用其他溢出最小化&#x2F;校正方法，则在使用其他多重成像技术生成的数据时，可以跳过以下部分的步骤。</p>\n<p>▲ 重要提示：如果核和细胞质通道相邻，也可以在图像分割之前进行溢出校正，以避免偏差。在这种情况下，需要将溢出校正后的图像写入“img”文件夹以供steinbock重新处理。然而，基于深度学习的分割方法对相邻通道之间的微量溢出不太敏感，而基于像素分类的分割方法则学会区分真实的核&#x2F;细胞质信号和溢出信号。尽管如此，还是建议通过视觉检查确保用于分割的通道中的溢出量最小。</p>\n<ol start=\"14\">\n<li>根据Chevrier等人24的研究，从溢出玻片中读取数据进行通道间溢出校正。创建和获取溢出玻片的实验过程可见补充说明2。根据CATALYST R&#x2F;Bioconductor包69的建议，使用5作为辅因子对像素强度进行arsinh变换。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sce <span class=\"operator\">&lt;-</span> readSCEfromTXT<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/compensation/&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> <span class=\"built_in\">asinh</span><span class=\"punctuation\">(</span>counts<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span><span class=\"operator\">/</span><span class=\"number\">5</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 重要提示：提供的溢出玻片数据是专门为此数据集获取的，不能应用于其他数据集。因此，必须为每组使用的抗体-金属螯合物以及理想情况下为每个实验获取一个溢出玻片。</p>\n<ol start=\"15\">\n<li>通过可视化每个通道和点样金属的中位像素强度来评估溢出数据的质量（图6a）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plotSpotHeatmap<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 重要提示：评估每个通道和点样金属的中位像素强度有两个目的：首先，较小的中位像素强度（~200个计数）可能会妨碍对通道溢出的稳健估计。其次，每个点样金属（行）应在其对应的通道（列）中显示出最高的中位像素强度。</p>\n<p>◆ 故障排除</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig6.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig6.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图6 | 单细胞数据和多通道图像的溢出校正。\"></p>\n<p>a，热图可视化每个通道（列）和点样金属（行）的log10转换后的中位像素强度。<br>b，热图可视化正确和错误分配给每个点样金属的像素的log10转换后的计数。x轴表示点样金属，y轴表示每个像素被分配到的金属。<br>c，通过散点图中可视化相邻通道（CD303：Yb174；Ecad：Yb173）的共检测标记强度，评估单细胞溢出校正的有效性。<br>d，图像显示了由于相邻通道溢出而产生的伪影信号。溢出校正消除了这些伪影。</p>\n<ol start=\"16\">\n<li>（可选）执行像素分箱以增加中位像素强度。这仅在像素强度过低（中位值低于约200计数）时才需要。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sce2 <span class=\"operator\">&lt;-</span> binAcrossPixels<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> bin_size <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"17\">\n<li>过滤错误分配的像素。以下步骤使用CATALYST包提供的函数对像素进行“去条形码化”处理。基于所有通道的强度分布，将像素分配给其对应的条形码，这里即为已知的金属点。此过程会识别出无法稳健分配给点样金属的像素。此类像素可视为“噪声”、“背景”或“伪影”，并应在溢出估计之前去除。需要指定点样通道（bc_key）。</li>\n</ol>\n<p>像素去条形码化的一般工作流程如下：</p>\n<p>• 为每个像素分配一个初步的金属质量<br>• 对于每个像素，估计正像素集和负像素集之间距离的截断参数<br>• 应用估计的截断值来识别真正的正像素</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>CATALYST<span class=\"punctuation\">)</span></span><br><span class=\"line\">bc_key <span class=\"operator\">&lt;-</span> <span class=\"built_in\">as.numeric</span><span class=\"punctuation\">(</span>unique<span class=\"punctuation\">(</span>sce<span class=\"operator\">$</span>sample_mass<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">bc_key <span class=\"operator\">&lt;-</span> bc_key<span class=\"punctuation\">[</span>order<span class=\"punctuation\">(</span>bc_key<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> assignPrelim<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> bc_key <span class=\"operator\">=</span> bc_key<span class=\"punctuation\">)</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> estCutoffs<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> applyCutoffs<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"18\">\n<li>观察每个点正确和错误分配的像素数量。图6b中的热图描绘了对角线上分配给每个点的像素数量、非对角线上错误分配的像素以及第一行中无法分配给特定点的像素。对于当前数据集，所有像素要么被分配给相应的点，要么被标记为未分配。在以下代码块中，我们观察到有10%到55%的像素无法分配给其对应的点，这是可以预料的，因为点样抗体在溢出玻片上的空间分布可能是异质性的。在filterPixels函数中，minevents参数指定了正确分配的像素集被排除在溢出估计之外的阈值。correct_pixels参数指示是否将分配给除点样质量以外的质量的像素排除在溢出估计之外。默认值通常足以进行足够的像素过滤；但是，如果每个点测量的像素非常少（~100），则需要降低minevents参数的值。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>pheatmap<span class=\"punctuation\">)</span></span><br><span class=\"line\">cur_table <span class=\"operator\">&lt;-</span> table<span class=\"punctuation\">(</span>sce<span class=\"operator\">$</span>bc_id<span class=\"punctuation\">,</span> sce<span class=\"operator\">$</span>sample_mass<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 可视化正确和错误分配的像素</span></span><br><span class=\"line\">pheatmap<span class=\"punctuation\">(</span>log10<span class=\"punctuation\">(</span>cur_table <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> cluster_rows <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">,</span> cluster_cols <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 计算每个点未分配像素的比例</span></span><br><span class=\"line\">cur_table<span class=\"punctuation\">[</span><span class=\"string\">&quot;0&quot;</span><span class=\"punctuation\">,</span><span class=\"punctuation\">]</span> <span class=\"operator\">/</span> colSums<span class=\"punctuation\">(</span>cur_table<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># 过滤分配给除点样质量以外的质量的像素</span></span><br><span class=\"line\">sce <span class=\"operator\">&lt;-</span> filterPixels<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">,</span> minevents <span class=\"operator\">=</span> <span class=\"number\">40</span><span class=\"punctuation\">,</span> correct_pixels <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<ol start=\"19\">\n<li>使用CATALYST包计算和存储溢出矩阵。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sce <span class=\"operator\">&lt;-</span> computeSpillmat<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span></span><br><span class=\"line\">sm <span class=\"operator\">&lt;-</span> metadata<span class=\"punctuation\">(</span>sce<span class=\"punctuation\">)</span><span class=\"operator\">$</span>spillover_matrix</span><br></pre></td></tr></table></figure>\n\n<ol start=\"20\">\n<li>使用CATALYST包执行单细胞数据补偿。compCytof函数使用先前估计的溢出矩阵直接在单细胞强度上校正通道间的溢出。CATALYST包提供的isotope_list变量需要扩展为包含不在此列表中的同位素。通过比较校正前后相邻通道（例如Yb173和Yb174）的标记强度可视化，可以评估溢出校正的有效性（图6c）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>dittoSeq<span class=\"punctuation\">)</span></span><br><span class=\"line\">library<span class=\"punctuation\">(</span>patchwork<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Specify the channel_name entry for use with CATALYST</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>channel_name <span class=\"operator\">&lt;-</span> paste0<span class=\"punctuation\">(</span>rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>channel<span class=\"punctuation\">,</span> <span class=\"string\">&quot;Di&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Add the missing metal isotope to the isotope_list variable</span></span><br><span class=\"line\">isotope_list <span class=\"operator\">&lt;-</span> CATALYST<span class=\"operator\">::</span>isotope_list</span><br><span class=\"line\">isotope_list<span class=\"operator\">$</span>Ar <span class=\"operator\">&lt;-</span> 80</span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> compCytof<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> sm<span class=\"punctuation\">,</span></span><br><span class=\"line\"> transform <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span> cofactor <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> isotope_list <span class=\"operator\">=</span> isotope_list<span class=\"punctuation\">,</span></span><br><span class=\"line\"> overwrite <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize biaxial plots before/after compensation</span></span><br><span class=\"line\">before <span class=\"operator\">&lt;-</span> dittoScatterPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> x.var <span class=\"operator\">=</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> y.var <span class=\"operator\">=</span> <span class=\"string\">&quot;CD303&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay.x <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> assay.y <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Before compensation&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">after <span class=\"operator\">&lt;-</span> dittoScatterPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> x.var <span class=\"operator\">=</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> y.var <span class=\"operator\">=</span> <span class=\"string\">&quot;CD303&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay.x <span class=\"operator\">=</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">,</span> assay.y <span class=\"operator\">=</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;After compensation&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">before <span class=\"operator\">+</span> after</span><br><span class=\"line\"><span class=\"comment\"># Replace uncompensated assays</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;counts&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compcounts&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compcounts&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> assay<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;compexprs&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> <span class=\"literal\">NULL</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"21\">\n<li>对多通道图像进行通道间溢出校正。为此，需要对先前计算得到的溢出矩阵进行调整，仅保留存储在多通道图像中的通道。通过可视化相邻通道，可以评估溢出校正的效果（图6d）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Use mass tags as channel names</span></span><br><span class=\"line\">channelNames<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>channel_name</span><br><span class=\"line\"><span class=\"comment\"># Adapt spillover matrix to retain channels contained</span></span><br><span class=\"line\"><span class=\"comment\"># in the multi-channel images</span></span><br><span class=\"line\">adapted_sm <span class=\"operator\">&lt;-</span> adaptSpillmat<span class=\"punctuation\">(</span>sm<span class=\"punctuation\">,</span> channelNames<span class=\"punctuation\">(</span>images<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> isotope_list <span class=\"operator\">=</span> isotope_list<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Perform image compensation</span></span><br><span class=\"line\">images_comp <span class=\"operator\">&lt;-</span> compImage<span class=\"punctuation\">(</span>images<span class=\"punctuation\">,</span> adapted_sm<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize neighboring channels before/after compensation</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173 (Ecad) - before&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb173Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174 (CD303) - before&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb174Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb173 (Ecad) - after&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb173Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">[</span><span class=\"number\">5</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> colour_by <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174Di&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>text <span class=\"operator\">=</span> <span class=\"string\">&quot;Yb174 (CD303) - after&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> position <span class=\"operator\">=</span> <span class=\"string\">&quot;topleft&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span> bcg <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>Yb174Di <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Switch back to using target names as channel names</span></span><br><span class=\"line\">channelNames<span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"质控\"><a href=\"#质控\" class=\"headerlink\" title=\"质控\"></a>质控</h2><p>● 时间：10分钟</p>\n<ol start=\"22\">\n<li>在组合图像上勾勒细胞轮廓，以便对分割质量进行视觉评估（图7）。为了可视化，我们从三组图像中选取子集，并在通道归一化后，在组合图像上勾勒出所有细胞的轮廓。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">20220118</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">img_ids <span class=\"operator\">&lt;-</span> sample<span class=\"punctuation\">(</span><span class=\"built_in\">seq_len</span><span class=\"punctuation\">(</span><span class=\"built_in\">length</span><span class=\"punctuation\">(</span>images_comp<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"number\">3</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">cur_images <span class=\"operator\">&lt;-</span> images_comp<span class=\"punctuation\">[</span>img_ids<span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Normalize each channel between 0 and 1</span></span><br><span class=\"line\">cur_images <span class=\"operator\">&lt;-</span> cytomapper<span class=\"operator\">::</span>normalize<span class=\"punctuation\">(</span>cur_images<span class=\"punctuation\">,</span> separateImages <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Clip channel intensities at 0 and 0.2</span></span><br><span class=\"line\">cur_images <span class=\"operator\">&lt;-</span> cytomapper<span class=\"operator\">::</span>normalize<span class=\"punctuation\">(</span>cur_images<span class=\"punctuation\">,</span> inputRange <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">0.2</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotPixels<span class=\"punctuation\">(</span>cur_images<span class=\"punctuation\">,</span></span><br><span class=\"line\"> mask <span class=\"operator\">=</span> masks<span class=\"punctuation\">[</span>img_ids<span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> missing_colour <span class=\"operator\">=</span> <span class=\"string\">&quot;white&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colour_by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;CD163&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;CD20&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;CD3&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;DNA1&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colour <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>CD163 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;yellow&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> CD20 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;red&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> CD3 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;green&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> Ecad <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;cyan&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> DNA1 <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;black&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;blue&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> image_title <span class=\"operator\">=</span> <span class=\"literal\">NULL</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> legend <span class=\"operator\">=</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>colour_by.title.cex <span class=\"operator\">=</span> <span class=\"number\">0.9</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colour_by.labels.cex <span class=\"operator\">=</span> <span class=\"number\">0.9</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p> ▲ 关键信息：这种可视化方法有助于识别图像中分割错误的细胞。建议可视化多张图像并放大以评估分割质量。如果单个细胞核由其各自的细胞掩膜勾勒出来，而没有明显的细胞聚集或分裂现象，则图像分割足够准确。如果测量的标志物定位于细胞核内或在细胞内相对均匀分布，则仅对细胞核进行分割，以减少来自相邻细胞的侧向溢出。这可以选择性地与steinbock utils的expand命令（参见steinbock在线文档）结合使用，以略微扩大细胞掩膜捕获的细胞区域11,70。</p>\n<p>◆ 故障排除</p>\n<ol start=\"23\">\n<li>可视化细胞面积的分布（图8）并过滤掉小细胞。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dittoPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;area&quot;</span><span class=\"punctuation\">,</span> group.by <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span> plots <span class=\"operator\">=</span> <span class=\"string\">&quot;boxplot&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> ylab<span class=\"punctuation\">(</span><span class=\"string\">&quot;细胞面积&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> xlab<span class=\"punctuation\">(</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>area <span class=\"operator\">&gt;=</span> <span class=\"number\">5</span><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：组织切片的多重成像通常不会捕获完整的细胞，而是测量细胞的切片。因此，可能无法准确代表相应细胞的小细胞切片应从分析中排除。所选阈值特定于数据集，应通过可视化细胞面积的分布进行微调。</p>\n<p>◆ 故障排除</p>\n<ol start=\"24\">\n<li>可视化每幅图像中细胞覆盖的图像区域（图9）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计算细胞覆盖的图像面积的比例</span></span><br><span class=\"line\">cell_density <span class=\"operator\">&lt;-</span> colData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> as.data.frame<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> group_by<span class=\"punctuation\">(</span>sample_id<span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> <span class=\"comment\"># Compute the number of pixels covered by cells and</span></span><br><span class=\"line\"> <span class=\"comment\"># the total number of pixels</span></span><br><span class=\"line\"> summarize<span class=\"punctuation\">(</span>cell_area <span class=\"operator\">=</span> <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>area<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> no_pixels <span class=\"operator\">=</span> mean<span class=\"punctuation\">(</span>width_px<span class=\"punctuation\">)</span> <span class=\"operator\">*</span> mean<span class=\"punctuation\">(</span>height_px<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> <span class=\"comment\"># Divide the total number of pixels</span></span><br><span class=\"line\"> <span class=\"comment\"># by the number of pixels covered by cells</span></span><br><span class=\"line\"> mutate<span class=\"punctuation\">(</span>covered_area <span class=\"operator\">=</span> cell_area <span class=\"operator\">/</span> no_pixels<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize the image area covered by cells per image</span></span><br><span class=\"line\">ggplot<span class=\"punctuation\">(</span>cell_density<span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> geom_point<span class=\"punctuation\">(</span>aes<span class=\"punctuation\">(</span>sample_id<span class=\"punctuation\">,</span> covered_area<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme_minimal<span class=\"punctuation\">(</span>base_size <span class=\"operator\">=</span> <span class=\"number\">15</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>axis.text.x <span class=\"operator\">=</span> element_text<span class=\"punctuation\">(</span>angle <span class=\"operator\">=</span> <span class=\"number\">90</span><span class=\"punctuation\">,</span> hjust <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">15</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ylim<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ylab<span class=\"punctuation\">(</span><span class=\"string\">&quot;% covered area&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> xlab<span class=\"punctuation\">(</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：在选择致密组织区域进行采集时，我们预期图像像素的大部分将被细胞覆盖。然而，由于稀疏组织结构（如血管）的存在或组织丢失，覆盖比例可能会降低。</p>\n<p>◆ 故障排除</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig7.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig7.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图7 | 分割质量的视觉评估。在由六种标志物（CD163，黄色，髓系细胞；CD20，红色，B细胞；CD3，绿色，T细胞；E-钙粘蛋白，青色，上皮细胞；DNA1，蓝色，细胞核）伪彩色合成的图像上勾勒出分割后的细胞轮廓。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig8.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig8.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图8 | 细胞面积分布。以箱线图的形式显示每幅图像（x轴）上的细胞面积分布（y轴）。黑条表示中位数，铰链表示分布的第一四分位数和第三四分位数。\"></p>\n<ol start=\"25\">\n<li>可视化选定标志物在样本间的染色差异。结合低维细胞可视化（步骤26），图10显示了样本间标志物表达的差异。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multi_dittoPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> vars <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;HLADR&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;CD3&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Ecad&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;PDGFRb&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> group.by <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span> plots <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;ridgeplot&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"26\">\n<li>可视化单细胞的低维嵌入。这里，我们使用scater包58来计算均匀流形近似和投影（UMAP）嵌入，并在低维空间中可视化细胞（图11a）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scater<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220225</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> runUMAP<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> subset_row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span></span><br><span class=\"line\"> exprs_values <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize the UMAP embedding and color cells by patient ID</span></span><br><span class=\"line\">dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Patient ID on UMAP&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig9.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig9.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图9 | 每幅图像中细胞覆盖的图像区域可视化。显示每幅图像（x轴）上细胞覆盖的像素比例（y轴）。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig10.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig10.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图10 | 患者间标志物分布差异的可视化。脊线图显示了数据集中每个患者选定标志物的每个细胞的arsinh转换平均像素强度分布。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig11.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig11.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图11 | 单细胞的低维表示。a，按患者标识符着色的单细胞的UMAP表示。b，经过fastMNN批次校正后按患者着色的UMAP表示。\"></p>\n<p>▲ 关键信息：在UMAP可视化（步骤25-26，图10和11a）中，标志物分布的差异或非重叠样本可能表明样本间的染色差异或生物学差异。当样本处理方式不同或使用不同批次的抗体混合物进行染色时，可能会出现染色差异。</p>\n<p>◆ 故障排除</p>\n<ol start=\"27\">\n<li>执行批次校正以消除样本间的差异（图11b）。这里，我们使用batchelor包的fastMNN方法30。在以下代码块中，为了可重复性，在设置种子后依次执行非确定性的fastMNN和runUMAP函数。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>batchelor<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220228</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Perform batch correction</span></span><br><span class=\"line\">out <span class=\"operator\">&lt;-</span> fastMNN<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> batch <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>patient_id<span class=\"punctuation\">,</span></span><br><span class=\"line\"> auto.merge <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> subset.row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay.type <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Store corrected embeddings in SPE object</span></span><br><span class=\"line\">reducedDim<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> reducedDim<span class=\"punctuation\">(</span>out<span class=\"punctuation\">,</span> <span class=\"string\">&quot;corrected&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute UMAP on corrected embeddings</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> runUMAP<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> dimred<span class=\"operator\">=</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">,</span> name <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize corrected UMAP</span></span><br><span class=\"line\">dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Patient ID on UMAP after correction&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：需要视觉评估批次校正的准确性，以估计是否除了技术变异外还消除了生物变异。这可以通过根据已知在某些细胞表型中表达的标志物对UMAP嵌入进行着色来实现。这些标志物应在UMAP嵌入中聚类的细胞中表达。可以使用其他批次效应校正方法来改进数据整合71,72。</p>\n<p>◆ 故障排除</p>\n<h2 id=\"细胞表型分析\"><a href=\"#细胞表型分析\" class=\"headerlink\" title=\"细胞表型分析\"></a>细胞表型分析</h2><p>● 时间：选项A需30分钟，选项B需1-2小时（更大数据集需要更多时间）</p>\n<ol start=\"28\">\n<li>定义细胞表型。为此，可以对单细胞进行聚类（A）或通过分类进行表型分析（B）。</li>\n</ol>\n<p>（A）通过聚类进行细胞表型分析</p>\n<p>使用bluster和scran R&#x2F;Bioconductor包59中的函数进行基于图的聚类。另外，也可以使用其他方法，如phenograph53或FlowSOM73对单细胞进行聚类。</p>\n<p>（i）在批次校正后的细胞嵌入上估计基于图的聚类的最佳聚类参数。我们遍历聚类参数的所有可能组合（图12），包括要考虑的最近邻数（k）和边权重方法（类型）。我们保持社区检测算法（cluster.fun）固定，因为Louvain方法74是基于图的聚类中最常用的算法之一。为了评估聚类的稳定性，我们计算所有细胞的平均轮廓宽度，并选择平均轮廓宽度最高的聚类参数组合。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig12.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig12.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图12 | 用于最优参数估计的聚类参数遍历。数据集使用四种聚类参数组合（x轴）进行聚类。对于每种组合，计算了所有细胞的平均轮廓宽度。较高的值表示聚类分离度更好。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>bluster<span class=\"punctuation\">)</span></span><br><span class=\"line\">library<span class=\"punctuation\">(</span>BiocParallel<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Select the corrected cell embeddings for clustering</span></span><br><span class=\"line\">mat <span class=\"operator\">&lt;-</span> reducedDim<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Perform the cluster sweep</span></span><br><span class=\"line\">combinations <span class=\"operator\">&lt;-</span> clusterSweep<span class=\"punctuation\">(</span>mat<span class=\"punctuation\">,</span> BLUSPARAM<span class=\"operator\">=</span>SNNGraphParam<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> k<span class=\"operator\">=</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">10L</span><span class=\"punctuation\">,</span> <span class=\"number\">20L</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;rank&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;jaccard&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> cluster.fun <span class=\"operator\">=</span> <span class=\"string\">&quot;louvain&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BPPARAM <span class=\"operator\">=</span> SerialParam<span class=\"punctuation\">(</span>RNGseed <span class=\"operator\">=</span> <span class=\"number\">230214</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the average silhouette width per parameter combination</span></span><br><span class=\"line\">sil <span class=\"operator\">&lt;-</span> vapply<span class=\"punctuation\">(</span>as.list<span class=\"punctuation\">(</span>combinations<span class=\"operator\">$</span>clusters<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>x<span class=\"punctuation\">)</span> mean<span class=\"punctuation\">(</span>approxSilhouette<span class=\"punctuation\">(</span>mat<span class=\"punctuation\">,</span> x<span class=\"punctuation\">)</span><span class=\"operator\">$</span>width<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"number\">0</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize the average silhouette width per parameter</span></span><br><span class=\"line\"><span class=\"comment\"># combination</span></span><br><span class=\"line\">ggplot<span class=\"punctuation\">(</span>data.frame<span class=\"punctuation\">(</span>method <span class=\"operator\">=</span> <span class=\"built_in\">names</span><span class=\"punctuation\">(</span>sil<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> sil <span class=\"operator\">=</span> sil<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> geom_point<span class=\"punctuation\">(</span>aes<span class=\"punctuation\">(</span>method<span class=\"punctuation\">,</span> sil<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">3</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme_classic<span class=\"punctuation\">(</span>base_size <span class=\"operator\">=</span> <span class=\"number\">15</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>axis.text.x <span class=\"operator\">=</span> element_text<span class=\"punctuation\">(</span>angle <span class=\"operator\">=</span> <span class=\"number\">45</span><span class=\"punctuation\">,</span> hjust <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> xlab<span class=\"punctuation\">(</span><span class=\"string\">&quot;Cluster parameter combination&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ylab<span class=\"punctuation\">(</span><span class=\"string\">&quot;Average silhouette width&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：对于每个数据集，应独立进行参数估计。对于大型数据集，该函数运行时间较长，为了近似处理，可以对数据集进行子采样以加快聚类遍历的速度。</p>\n<p>（ii）基于所选参数，使用基于图的算法对细胞进行聚类。如前所述，将参数设置为k&#x3D;20和类型“rank”应该能得到分离度较好的聚类。然后，将聚类标识符保存在SpatialExperiment对象中。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scran<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220621</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">clusters <span class=\"operator\">&lt;-</span> clusterCells<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> use.dimred <span class=\"operator\">=</span> <span class=\"string\">&quot;fastMNN&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BLUSPARAM <span class=\"operator\">=</span> SNNGraphParam<span class=\"punctuation\">(</span>k <span class=\"operator\">=</span> <span class=\"number\">20</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> cluster.fun <span class=\"operator\">=</span> <span class=\"string\">&quot;louvain&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;rank&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>nn_clusters <span class=\"operator\">&lt;-</span> clusters</span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<p>（iii）为了根据各聚类中包含的细胞表型对其进行注释，可以以热图的形式可视化每个聚类的标志物表达（图13）。为了可视化目的，从数据集中随机选择了2000个细胞。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>viridis<span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220619</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">cur_cells <span class=\"operator\">&lt;-</span> sample<span class=\"punctuation\">(</span><span class=\"built_in\">seq_len</span><span class=\"punctuation\">(</span>ncol<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"number\">2000</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">dittoHeatmap<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>cur_cells<span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> genes <span class=\"operator\">=</span> rownames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">[</span>rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> heatmap.colors <span class=\"operator\">=</span> viridis<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> annot.by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;nn_clusters&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig13.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig13.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图13 | 聚类特异性表达模式的可视化。2000个随机选取的细胞的arsinh转换后的标志物表达显示出聚类特异性的表达模式。每一列代表一个单独的细胞，每一行包含一个单独的标志物。细胞根据其所属的聚类和患者ID进行标记。\"></p>\n<p>（iv）在观察到聚类特异性表达模式后，可以对各个聚类进行注释。例如，聚类12显示出B细胞标志物CD20的高表达，因此可以标记为“Bcell”。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster_celltype <span class=\"operator\">&lt;-</span> recode<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>nn_clusters<span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;1&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tumor_proliferating&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;2&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Myeloid&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;3&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;4&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;5&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Stroma&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;6&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Proliferating&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;7&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Myeloid&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;8&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Plasma_cell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;9&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;CD8&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;10&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;CD4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;11&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Neutrophil&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;12&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Bcell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"string\">&quot;13&quot;</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Stroma&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（B）基于分类的细胞表型分析</p>\n<p>（i）使用cytomapper包中包含的cytomapperShiny函数，根据标志物的表达来界定单个细胞的表型。对于每张图像，细胞根据其标志物表达的层次结构进行界定，以定义预期的细胞表型。然后，将界定的细胞以轮廓的形式显示在伪彩色合成图像上。一旦正确标记了细胞，就可以将它们作为仅包含选定细胞的SpatialExperiment对象下载。在下载时，可以指定细胞标签，该标签存储在colData插槽的cytomapper_CellLabel条目中，以便稍后用于训练分类器（步骤28B(iv)）。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cytomapperShiny<span class=\"punctuation\">(</span>object <span class=\"operator\">=</span> spe<span class=\"punctuation\">,</span> mask <span class=\"operator\">=</span> masks<span class=\"punctuation\">,</span> image <span class=\"operator\">=</span> images_comp<span class=\"punctuation\">,</span></span><br><span class=\"line\"> cell_id <span class=\"operator\">=</span> <span class=\"string\">&quot;ObjectNumber&quot;</span><span class=\"punctuation\">,</span> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：由于分割不完全，侧向溢出会导致某些标志物的表达水平不正确。因此，我们建议仅对表达其特定细胞表型标志物的细胞进行界定。</p>\n<p>（ii）读取包含界定细胞的文件，并将它们合并成一个SpatialExperiment对象。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>SingleCellExperiment<span class=\"punctuation\">)</span></span><br><span class=\"line\">label_files <span class=\"operator\">&lt;-</span> list.files<span class=\"punctuation\">(</span><span class=\"string\">&quot;data/gated_cells&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> full.names <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span> pattern <span class=\"operator\">=</span> <span class=\"string\">&quot;.rds$&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Read in individual files containing gated cells</span></span><br><span class=\"line\">spes <span class=\"operator\">&lt;-</span> lapply<span class=\"punctuation\">(</span>label_files<span class=\"punctuation\">,</span> readRDS<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Concatenate the individual objects into one</span></span><br><span class=\"line\">concat_spe <span class=\"operator\">&lt;-</span> do.call<span class=\"punctuation\">(</span><span class=\"string\">&quot;cbind&quot;</span><span class=\"punctuation\">,</span> spes<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（iii）移除被多次标记的细胞，并重新分配肿瘤细胞。由于采用多步骤标记方法，一些细胞可能被标记了多次。在细胞同时被标记为肿瘤细胞和免疫细胞的情况下，我们保留免疫细胞标签，因为这些细胞很可能是驻留在肿瘤内的免疫细胞。所有其他被多次标记的细胞都被移除。最后，将标签存储在主要的SpatialExperiment对象中。我们首先定义一个辅助函数，该函数返回仅被标记一次的细胞的标签。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter_labels <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>object<span class=\"punctuation\">,</span></span><br><span class=\"line\"> label <span class=\"operator\">=</span> <span class=\"string\">&quot;cytomapper_CellLabel&quot;</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"> cur_tab <span class=\"operator\">&lt;-</span> <span class=\"built_in\">unclass</span><span class=\"punctuation\">(</span>table<span class=\"punctuation\">(</span>colnames<span class=\"punctuation\">(</span>object<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> object<span class=\"punctuation\">[[</span>label<span class=\"punctuation\">]</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"> cur_labels <span class=\"operator\">&lt;-</span> colnames<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">)</span><span class=\"punctuation\">[</span>apply<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">,</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> which.max<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"> <span class=\"built_in\">names</span><span class=\"punctuation\">(</span>cur_labels<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">)</span></span><br><span class=\"line\"> cur_labels <span class=\"operator\">&lt;-</span> cur_labels<span class=\"punctuation\">[</span>rowSums<span class=\"punctuation\">(</span>cur_tab<span class=\"punctuation\">)</span> <span class=\"operator\">==</span> <span class=\"number\">1</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"> <span class=\"built_in\">return</span><span class=\"punctuation\">(</span>cur_labels<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来，应用此函数来检索所有仅被标记一次的细胞。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">labels <span class=\"operator\">&lt;-</span> filter_labels<span class=\"punctuation\">(</span>concat_spe<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>再次对所有细胞应用该函数，同时排除“Tumor”标签。这种方法可以识别那些既被标记为肿瘤细胞又被标记为免疫细胞的细胞。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cur_spe <span class=\"operator\">&lt;-</span> concat_spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>concat_spe<span class=\"operator\">$</span>cytomapper_CellLabel <span class=\"operator\">!=</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">non_tumor_labels <span class=\"operator\">&lt;-</span> filter_labels<span class=\"punctuation\">(</span>cur_spe<span class=\"punctuation\">)</span></span><br><span class=\"line\">additional_cells <span class=\"operator\">&lt;-</span> setdiff<span class=\"punctuation\">(</span><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>non_tumor_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>labels<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，将两组细胞标签合并并存储在SpatialExperiment对象中。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final_labels <span class=\"operator\">&lt;-</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span>labels<span class=\"punctuation\">,</span> non_tumor_labels<span class=\"punctuation\">[</span>additional_cells<span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Transfer labels to SPE object</span></span><br><span class=\"line\">spe_labels <span class=\"operator\">&lt;-</span> <span class=\"built_in\">rep</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;unlabeled&quot;</span><span class=\"punctuation\">,</span> ncol<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>spe_labels<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> colnames<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span></span><br><span class=\"line\">spe_labels<span class=\"punctuation\">[</span><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>final_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span> <span class=\"operator\">&lt;-</span> final_labels</span><br><span class=\"line\">spe<span class=\"operator\">$</span>cell_labels <span class=\"operator\">&lt;-</span> spe_labels</span><br></pre></td></tr></table></figure>\n\n<p>（iv）为未标记细胞的表型分类训练一个随机森林分类器。首先，将细胞分为标记细胞和未标记细胞。然后，我们对标记细胞进行75&#x2F;25的划分，以分别选择训练集和测试集。基于训练集，我们进行五折交叉验证来调整随机森林模型的参数。在以下代码块中，为了可重复性，在设置随机种子后，依次执行了非确定性的createDataPartition函数和train函数。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>caret<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Split between labeled and unlabeled cells</span></span><br><span class=\"line\">lab_spe <span class=\"operator\">&lt;-</span> spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>cell_labels <span class=\"operator\">!=</span> <span class=\"string\">&quot;unlabeled&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">unlab_spe <span class=\"operator\">&lt;-</span> spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>cell_labels <span class=\"operator\">==</span> <span class=\"string\">&quot;unlabeled&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Randomly split into train and test data</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">221029</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">trainIndex <span class=\"operator\">&lt;-</span> createDataPartition<span class=\"punctuation\">(</span>factor<span class=\"punctuation\">(</span>lab_spe<span class=\"operator\">$</span>cell_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">p <span class=\"operator\">=</span> <span class=\"number\">0.75</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">train_spe <span class=\"operator\">&lt;-</span> lab_spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>trainIndex<span class=\"operator\">$</span>Resample1<span class=\"punctuation\">]</span></span><br><span class=\"line\">test_spe <span class=\"operator\">&lt;-</span> lab_spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span><span class=\"operator\">-</span>trainIndex<span class=\"operator\">$</span>Resample1<span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Define fit parameters for 5-fold cross validation</span></span><br><span class=\"line\">fitControl <span class=\"operator\">&lt;-</span> trainControl<span class=\"punctuation\">(</span>method <span class=\"operator\">=</span> <span class=\"string\">&quot;cv&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> number <span class=\"operator\">=</span> <span class=\"number\">5</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Select the arsinh-transformed counts for training</span></span><br><span class=\"line\">cur_mat <span class=\"operator\">&lt;-</span> t<span class=\"punctuation\">(</span>assay<span class=\"punctuation\">(</span>train_spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>train_spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Train a random forest classifier</span></span><br><span class=\"line\">rffit <span class=\"operator\">&lt;-</span> train<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> y <span class=\"operator\">=</span> factor<span class=\"punctuation\">(</span>train_spe<span class=\"operator\">$</span>cell_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> method <span class=\"operator\">=</span> <span class=\"string\">&quot;rf&quot;</span><span class=\"punctuation\">,</span> ntree <span class=\"operator\">=</span> <span class=\"number\">1000</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> tuneLength <span class=\"operator\">=</span> <span class=\"number\">5</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> trControl <span class=\"operator\">=</span> fitControl<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<p>（v）通过计算测试集的混淆矩阵来评估分类器的性能。confusionMatrix函数将预测的细胞标签与真实的细胞标签进行比较，并计算多个性能指标。期望每个细胞表型标签都具有高灵敏度和高特异性。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Select the arsinh-transformed counts of the test data</span></span><br><span class=\"line\">cur_mat <span class=\"operator\">&lt;-</span> t<span class=\"punctuation\">(</span>assay<span class=\"punctuation\">(</span>test_spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>test_spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Predict the cell phenotype labels of the test data</span></span><br><span class=\"line\">cur_pred <span class=\"operator\">&lt;-</span> predict<span class=\"punctuation\">(</span>rffit<span class=\"punctuation\">,</span> newdata <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the confusion matrix between predicted</span></span><br><span class=\"line\"><span class=\"comment\"># and actual labels</span></span><br><span class=\"line\">confusionMatrix<span class=\"punctuation\">(</span>data <span class=\"operator\">=</span> cur_pred<span class=\"punctuation\">,</span></span><br><span class=\"line\"> reference <span class=\"operator\">=</span> factor<span class=\"punctuation\">(</span>test_spe<span class=\"operator\">$</span>cell_labels<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> mode <span class=\"operator\">=</span> <span class=\"string\">&quot;everything&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>（vi）预测未标记细胞的标签。对于最高类别概率低于40%的细胞，将其标记为“未知”。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Select the arsinh-transformed counts of</span></span><br><span class=\"line\"><span class=\"comment\"># the unlabeled data for prediction</span></span><br><span class=\"line\">cur_mat <span class=\"operator\">&lt;-</span> t<span class=\"punctuation\">(</span>assay<span class=\"punctuation\">(</span>unlab_spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">rowData<span class=\"punctuation\">(</span>unlab_spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">,</span><span class=\"punctuation\">]</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Predict the cell phenotype labels of the unlabeled data</span></span><br><span class=\"line\">cell_class <span class=\"operator\">&lt;-</span> <span class=\"built_in\">as.character</span><span class=\"punctuation\">(</span>predict<span class=\"punctuation\">(</span>rffit<span class=\"punctuation\">,</span></span><br><span class=\"line\"> newdata <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;raw&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"built_in\">names</span><span class=\"punctuation\">(</span>cell_class<span class=\"punctuation\">)</span> <span class=\"operator\">&lt;-</span> rownames<span class=\"punctuation\">(</span>cur_mat<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Extract prediction probabilities for each cell</span></span><br><span class=\"line\">cell_prob <span class=\"operator\">&lt;-</span> predict<span class=\"punctuation\">(</span>rffit<span class=\"punctuation\">,</span></span><br><span class=\"line\"> newdata <span class=\"operator\">=</span> cur_mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;prob&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Label cells with a low prediction probability as undefined</span></span><br><span class=\"line\">cell_class<span class=\"punctuation\">[</span>rowMax<span class=\"punctuation\">(</span>as.matrix<span class=\"punctuation\">(</span>cell_prob<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">&lt;</span> <span class=\"number\">0.4</span><span class=\"punctuation\">]</span> <span class=\"operator\">&lt;-</span> <span class=\"string\">&quot;undefined&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># Store cell phenotype labels in SPE object</span></span><br><span class=\"line\">cell_labels <span class=\"operator\">&lt;-</span> spe<span class=\"operator\">$</span>cell_labels</span><br><span class=\"line\">cell_labels<span class=\"punctuation\">[</span>colnames<span class=\"punctuation\">(</span>unlab_spe<span class=\"punctuation\">)</span><span class=\"punctuation\">]</span> <span class=\"operator\">&lt;-</span> cell_class</span><br><span class=\"line\">spe<span class=\"operator\">$</span>celltype <span class=\"operator\">&lt;-</span> cell_labels</span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：将细胞标记为未定义的阈值需要根据每个数据集进行调整。当预测更多的细胞类别时，阈值可能会降低；而当预测较少的类别时，阈值可以相应提高。</p>\n<ol start=\"29\">\n<li>在UMAP嵌入上可视化细胞表型和注释后的聚类标签，以定性评估细胞表型（图14）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 <span class=\"operator\">&lt;-</span> dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> do.label <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Cell types on UMAP, integrated cells&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">p2 <span class=\"operator\">&lt;-</span> dittoDimPlot<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> var <span class=\"operator\">=</span> <span class=\"string\">&quot;cluster_celltype&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> reduction.use <span class=\"operator\">=</span> <span class=\"string\">&quot;UMAP_mnnCorrected&quot;</span><span class=\"punctuation\">,</span> size <span class=\"operator\">=</span> <span class=\"number\">0.2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> do.label <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> ggtitle<span class=\"punctuation\">(</span><span class=\"string\">&quot;Cluster cell types on UMAP, integrated cells&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">p1 <span class=\"operator\">+</span> p2</span><br></pre></td></tr></table></figure>\n\n<ol start=\"30\">\n<li>以热图的形式可视化每个细胞表型和每个注释后的聚类的平均标志物表达（图15）。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scuttle<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Calculate the mean of the arsinh-transformed counts per cell phenotype</span></span><br><span class=\"line\">celltype_mean <span class=\"operator\">&lt;-</span> aggregateAcrossCells<span class=\"punctuation\">(</span>as<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;SingleCellExperiment&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> ids <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>celltype<span class=\"punctuation\">,</span></span><br><span class=\"line\">  statistics <span class=\"operator\">=</span> <span class=\"string\">&quot;mean&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> use.assay.type <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> subset_row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">)</span></span><br><span class=\"line\">dittoHeatmap<span class=\"punctuation\">(</span>celltype_mean<span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> cluster_cols <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> heatmap.colors <span class=\"operator\">=</span> viridis<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> annot.by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ncells&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Calculate the mean of the arsinh-transformed counts per annotated </span></span><br><span class=\"line\"><span class=\"comment\"># cluster</span></span><br><span class=\"line\"> cluster_mean <span class=\"operator\">&lt;-</span> aggregateAcrossCells<span class=\"punctuation\">(</span>as<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> <span class=\"string\">&quot;SingleCellExperiment&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> ids <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>cluster_celltype<span class=\"punctuation\">,</span></span><br><span class=\"line\"> statistics <span class=\"operator\">=</span> <span class=\"string\">&quot;mean&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> use.assay.type <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> subset_row <span class=\"operator\">=</span> rowData<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">)</span><span class=\"operator\">$</span>use_channel<span class=\"punctuation\">)</span></span><br><span class=\"line\">dittoHeatmap<span class=\"punctuation\">(</span>cluster_mean<span class=\"punctuation\">,</span></span><br><span class=\"line\"> assay <span class=\"operator\">=</span> <span class=\"string\">&quot;exprs&quot;</span><span class=\"punctuation\">,</span> cluster_cols <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> heatmap.colors <span class=\"operator\">=</span> viridis<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> annot.by <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;cluster_celltype&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;ncells&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键信息：我们期望单个细胞表型能够显示出其特异性标志物的最高平均表达。此外，在如UMAP这样的低维嵌入中，细胞表型应能在视觉上被区分开来。</p>\n<p>◆ 故障排除</p>\n<h2 id=\"空间分析\"><a href=\"#空间分析\" class=\"headerlink\" title=\"空间分析\"></a>空间分析</h2><p>● 预计时间：20分钟</p>\n<p>本方案介绍了一系列空间分析方法，旨在研究细胞在组织环境中的分布情况。如需概览，请见图16。</p>\n<ol start=\"31\">\n<li>使用Jackson等人提出的空间群落分析方法8（图17），并借助imcRtools软件包提供的detectCommunity函数。该方法通过先前构建的空间细胞图，仅根据细胞在组织中的位置对细胞进行分组。我们分别对肿瘤细胞和非肿瘤细胞进行了群落检测。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig14.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig14.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14 | UMAP嵌入上展示的细胞表型。a，细胞在低维UMAP空间中展示，并根据通过细胞分类确定的表型进行着色。b，UMAP空间中的细胞根据其注释的聚类标识符进行着色。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig15.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig15.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图15 | 平均标志物表达热图。a，热图可视化了通过细胞分类定义的每个细胞表型的平均arsinh转换后的标志物表达。b，热图展示了每个注释聚类的平均arsinh转换后的标志物表达。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define if cells are part of the tumor or stroma</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>tumor_stroma <span class=\"operator\">&lt;-</span> ifelse<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>celltype <span class=\"operator\">==</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Stroma&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Detect spatial communities</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> detectCommunity<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;neighborhood&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> size_threshold <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;tumor_stroma&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BPPARAM <span class=\"operator\">=</span> SerialParam<span class=\"punctuation\">(</span>RNGseed <span class=\"operator\">=</span> <span class=\"number\">220819</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize spatial tumor communities</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span>spe<span class=\"operator\">$</span>celltype <span class=\"operator\">==</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_community&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>legend.position <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_manual<span class=\"punctuation\">(</span>values <span class=\"operator\">=</span> rev<span class=\"punctuation\">(</span>colors<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>在检测到空间群落之后，可以进行一系列下游分析。这些分析包括（i）计算用于元聚类的每个群落的细胞表型比例，（ii）识别样本间的共享群落以进行比较分析，以及（iii）计算单个群落的大小以估计组织分隔。</p>\n<ol start=\"32\">\n<li>按照Schürch等人10和Goltsev等人5的提议执行拷贝数（CN）分析（图18）。拷贝数是具有特征细胞表型组成的组织区域，它们代表了独特的局部生物过程和相互作用的位点。我们首先基于细胞的质心构建一个空间20近邻图，与先前使用steinbock构建的空间细胞图相比，该图包含了更多的邻居。然后，使用imcRtools包的aggregateNeighbors函数计算每个细胞在其20近邻中的细胞表型比例。接着，使用k均值聚类对细胞进行聚类以检测拷贝数。最后，可以根据细胞的拷贝数对其进行空间可视化和着色，并计算每个拷贝数的细胞表型比例。在图18中，拷贝数3代表B细胞的空间聚集，而拷贝数1主要包含肿瘤组织。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig16.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig16.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图16 | 空间分析方法的输入、可解释性和输出。本方案强调了一系列用于研究组织结构的空间分析方法。所提供的函数需要SpatialExperiment或SingleCellExperiment对象作为输入，并在内部使用存储在对象的colData、spatialCoords和colPairs槽中的信息。每个任务下的示例图像下方展示了一些可以解决的生物学问题。各个分析方法的输出要么是添加了额外colData条目的SpatialExperiment对象，要么是数据框。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Construct a 20-nearest neighbor graph</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> buildSpatialGraph<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span> type <span class=\"operator\">=</span> <span class=\"string\">&quot;knn&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">k <span class=\"operator\">=</span> <span class=\"number\">20</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the fraction of cell phenotypes in each cells neighborhood</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> aggregateNeighbors<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;knn_interaction_graph&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> aggregate_by <span class=\"operator\">=</span> <span class=\"string\">&quot;metadata&quot;</span><span class=\"punctuation\">,</span> count_by <span class=\"operator\">=</span> <span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">set.seed<span class=\"punctuation\">(</span><span class=\"number\">220705</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Cluster cells based on cell phenotype fractions</span></span><br><span class=\"line\">cn_1 <span class=\"operator\">&lt;-</span> kmeans<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>aggregatedNeighbors<span class=\"punctuation\">,</span> centers <span class=\"operator\">=</span> <span class=\"number\">6</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">spe<span class=\"operator\">$</span>cn_celltypes <span class=\"operator\">&lt;-</span> as.factor<span class=\"punctuation\">(</span>cn_1<span class=\"operator\">$</span>cluster<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize cellular neighborhoods</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;cn_celltypes&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_brewer<span class=\"punctuation\">(</span>palette <span class=\"operator\">=</span> <span class=\"string\">&quot;Set3&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the fraction of cell phenotypes in each cellular </span></span><br><span class=\"line\"><span class=\"comment\"># neighborhood</span></span><br><span class=\"line\">mat <span class=\"operator\">&lt;-</span> prop.table<span class=\"punctuation\">(</span>table<span class=\"punctuation\">(</span>spe<span class=\"operator\">$</span>cn_celltypes<span class=\"punctuation\">,</span> spe<span class=\"operator\">$</span>celltype<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> margin <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize cell phenotype fractions in each cellular neighborhood</span></span><br><span class=\"line\">pheatmap<span class=\"punctuation\">(</span>mat<span class=\"punctuation\">,</span></span><br><span class=\"line\"> color <span class=\"operator\">=</span> colorRampPalette<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;dark blue&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;white&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;dark red&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> scale <span class=\"operator\">=</span> <span class=\"string\">&quot;column&quot;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>▲ 关键步骤：与第28步类似，应通过参数扫描来估计k的最优值。但是，如果事先了解要检测的组织结构，则可以相应地设置k值。或者，也可以根据细胞邻域内细胞的平均标志物表达来对细胞进行聚类。此外，lisaClust R&#x2F;Bioconductor包还提供了检测拷贝数（CNs）的其他策略75。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig17.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig17.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图17 | 空间肿瘤群落。使用先前构建的空间细胞图，根据肿瘤细胞的空间位置将其聚类成群落，并根据其空间群落标识符进行着色。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig18.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig18.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图18 | 细胞邻域检测。a，根据细胞20个最近邻中的细胞表型频率对细胞进行聚类，并根据其细胞邻域进行着色。b，热图展示了每个细胞邻域内的细胞表型比例。列数据已进行z分数标准化。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig19.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig19.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图19 | 空间背景检测。a，根据细胞的空间背景进行着色，空间背景定义为可在每个细胞邻域中找到的拷贝数（CNs）的组合（例如，处于SC 1_6中的细胞是位于CN 1和CN 6之间的细胞）。b，空间背景图显示了哪些空间背景存在相互作用。节点的颜色由每个空间背景中的细胞数量决定。\"></p>\n<ol start=\"33\">\n<li>按照Bhate等人19的提议执行空间背景（SC）分析（图19）。空间背景建立在拷贝数（CNs）的概念之上，是拷贝数的局部生物过程相互作用并发生特殊生物事件的区域。我们构建了第二个k近邻图，其中k值较大（k&#x3D;40），以包含可在生物信号交换的长度尺度上的细胞。对于每个细胞，aggregateNeighbors函数计算其40个最近邻中拷贝数的比例。detectSpatialContext函数将拷贝数比例从高到低排序，并将每个细胞的空间背景分配为累积超过用户定义阈值（此处为0.9）的最小拷贝数组合。在过滤检测到的空间背景后，我们可以对其进行空间可视化，并将空间背景相互作用表示为分层图。我们观察到，SC 1（以肿瘤为主）、SC 1_6（肿瘤与肿瘤-间质界面）和SC 4_5（浆细胞&#x2F;T细胞和髓系细胞&#x2F;中性粒细胞界面）是该数据集中最常见的空间背景。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Construct a 40-nearest neighbor graph</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> buildSpatialGraph<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> type <span class=\"operator\">=</span> <span class=\"string\">&quot;knn&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;knn_spatialcontext_graph&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> k <span class=\"operator\">=</span> <span class=\"number\">40</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Compute the fraction of cellular neighborhoods around each cell</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> aggregateNeighbors<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;knn_spatialcontext_graph&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> aggregate_by <span class=\"operator\">=</span> <span class=\"string\">&quot;metadata&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> count_by <span class=\"operator\">=</span> <span class=\"string\">&quot;cn_celltypes&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;aggregatedNeighborhood&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Detect spatial contexts</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> detectSpatialContext<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> entry <span class=\"operator\">=</span> <span class=\"string\">&quot;aggregatedNeighborhood&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> threshold <span class=\"operator\">=</span> <span class=\"number\">0.90</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Filter out small and infrequent spatial contexts</span></span><br><span class=\"line\">spe <span class=\"operator\">&lt;-</span> filterSpatialContext<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> entry <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;patient_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_threshold <span class=\"operator\">=</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> cells_threshold <span class=\"operator\">=</span> <span class=\"number\">100</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> name <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context_filtered&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize cell location colored by their spatial context</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context_filtered&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize spatial contexts as graph</span></span><br><span class=\"line\">plotSpatialContext<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> entry <span class=\"operator\">=</span> <span class=\"string\">&quot;spatial_context_filtered&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;n_cells&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_by <span class=\"operator\">=</span> <span class=\"string\">&quot;n_group&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_label_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;n_cells&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_viridis<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"34\">\n<li>按照Hoch等人11的提议执行斑块检测分析（图20）。imcRtools包的patchDetection函数检测感兴趣细胞的完全连接成分，在每个成分周围构造凹包，并将此凹包扩展以包含相邻细胞。在下文中，我们检测包含至少十个细胞的连接肿瘤成分，并稍微扩展凹包以包含斑块内的细胞。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spe <span class=\"operator\">&lt;-</span> patchDetection<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> patch_cells <span class=\"operator\">=</span> spe<span class=\"operator\">$</span>celltype <span class=\"operator\">==</span> <span class=\"string\">&quot;Tumor&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> expand_by <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> min_patch_size <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;neighborhood&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">plotSpatial<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_color_by <span class=\"operator\">=</span> <span class=\"string\">&quot;patch_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> img_id <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> node_size_fix <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>legend.position <span class=\"operator\">=</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_color_manual<span class=\"punctuation\">(</span>values <span class=\"operator\">=</span> rev<span class=\"punctuation\">(</span>colors<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"35\">\n<li>按照Schapiro等人18的提议执行相互作用分析（图21）。该方法检测与细胞表型的随机分布相比表现出更强（“相互作用”）或更弱（“避免”）共定位的细胞表型对。使用先前构建的空间细胞图（此处为使用steinbock创建的图），imcRtools包的testInteraction函数计算每幅图像中每对细胞表型的平均相互作用次数，并将其与通过随机置换所有细胞标签获得的经验空分布进行比较。返回的数据框包含每幅图像中每对细胞表型的一个条目，指示经验P值和统计显著性（相互作用：1；无显著性：0；避免：-1）。这些显著性值可以跨所有图像求和，并以热图的形式可视化。我们观察到，肿瘤细胞大多被分隔开，并与其他细胞类型相互避免，而调节性T细胞则位于CD4+ T细胞和CD8+ T细胞旁边。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig20.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig20.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图20 | 空间斑块检测。检测出肿瘤细胞的完全连接成分以及位于肿瘤斑块内的细胞。每个细胞根据其斑块标识符进行着色。\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig21.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/images/post/287e/fig21.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图21 | 细胞-细胞相互作用测试。热图显示了所有图像中每对细胞表型的显著性值之和。每幅图像和每对细胞表型的显著性值定义如下：1表示相互作用的细胞表型（红色）；0表示无相互作用或避免（白色）；-1表示细胞表型之间的避免（蓝色）。这些显著性值在所有14幅图像中相加，得出的可能范围在-14到14之间。\"></p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>scales<span class=\"punctuation\">)</span></span><br><span class=\"line\">out <span class=\"operator\">&lt;-</span> testInteractions<span class=\"punctuation\">(</span>spe<span class=\"punctuation\">,</span></span><br><span class=\"line\"> group_by <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> label <span class=\"operator\">=</span> <span class=\"string\">&quot;celltype&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> colPairName <span class=\"operator\">=</span> <span class=\"string\">&quot;neighborhood&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> BPPARAM <span class=\"operator\">=</span> SerialParam<span class=\"punctuation\">(</span>RNGseed <span class=\"operator\">=</span> <span class=\"number\">221029</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Sum interaction values across all images</span></span><br><span class=\"line\">summed_sigvals <span class=\"operator\">&lt;-</span> out <span class=\"operator\">%&gt;%</span> as_tibble<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> group_by<span class=\"punctuation\">(</span>from_label<span class=\"punctuation\">,</span> to_label<span class=\"punctuation\">)</span> <span class=\"operator\">%&gt;%</span></span><br><span class=\"line\"> summarize<span class=\"punctuation\">(</span>sum_sigval <span class=\"operator\">=</span> <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>sigval<span class=\"punctuation\">,</span> na.rm <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\"># Visualize summed interaction values in form of a heatmap</span></span><br><span class=\"line\">ggplot<span class=\"punctuation\">(</span>summed_sigvals<span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> geom_tile<span class=\"punctuation\">(</span>aes<span class=\"punctuation\">(</span>from_label<span class=\"punctuation\">,</span> to_label<span class=\"punctuation\">,</span> fill <span class=\"operator\">=</span> sum_sigval<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> scale_fill_gradient2<span class=\"punctuation\">(</span>low <span class=\"operator\">=</span> muted<span class=\"punctuation\">(</span><span class=\"string\">&quot;blue&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> mid <span class=\"operator\">=</span> <span class=\"string\">&quot;white&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> high <span class=\"operator\">=</span> muted<span class=\"punctuation\">(</span><span class=\"string\">&quot;red&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span></span><br><span class=\"line\"> theme<span class=\"punctuation\">(</span>axis.text.x <span class=\"operator\">=</span> element_text<span class=\"punctuation\">(</span>angle <span class=\"operator\">=</span> <span class=\"number\">45</span><span class=\"punctuation\">,</span> hjust <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>◆ 故障排除</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>Windhager J , Zanotelli V R T , Schulz D ,et al.An end-to-end workflow for multiplexed image processing and analysis[J].Nature Protocols, 2023, 18(11).DOI:10.1038&#x2F;s41596-023-00881-0.</li>\n</ul>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n","raw":null,"categories":[{"name":"生物信息","path":"api/categories/生物信息.json"}],"tags":[{"name":"图像识别","path":"api/tags/图像识别.json"},{"name":"单细胞测序","path":"api/tags/单细胞测序.json"}]},{"title":"Shiny从入门到入定——16-Escaping the graph","slug":"Shiny从入门到入定——16-Escaping-the-graph","date":"2024-09-26T14:05:28.000Z","updated":"2024-09-26T14:29:29.863Z","comments":true,"path":"api/articles/Shiny从入门到入定——16-Escaping-the-graph.json","excerpt":null,"keywords":null,"cover":"https://d33wubrfki0l68.cloudfront.net/df8aa242946fb586f90d40d735dd0ea497a56b4d/0d739/diagrams/reactivity-tracking/invalidate-1.png","content":"<h1 id=\"跳出反应式图\"><a href=\"#跳出反应式图\" class=\"headerlink\" title=\"跳出反应式图\"></a>跳出反应式图</h1><h2 id=\"16-1-引言\"><a href=\"#16-1-引言\" class=\"headerlink\" title=\"16.1 引言\"></a>16.1 引言</h2><p>Shiny的反应式编程框架极其有用，因为它能自动确定在输入变化时更新所有输出所需的最小计算集。但这个框架也故意施加了一些限制，有时你需要摆脱这些限制去做一些有风险但必要的事情。</p>\n<p>在本章中，你将学习如何结合<a href=\"https://rdrr.io/pkg/shiny/man/reactiveValues.html\">reactiveValues()</a>和<code>observe()</code>&#x2F;<code>observeEvent()</code>将反应式图的右侧连接到左侧。这些技术之所以强大，是因为它们让你能够手动控制图的一部分。但它们也很危险，因为它们会让你的应用做不必要的工作。最重要的是，你现在可以创建无限循环，让你的应用陷入永无止境的更新循环中。</p>\n<p>如果你发现本章中探讨的想法很有趣，你可能还想看看<a href=\"https://github.com/hadley/shinySignals/\">shinySignals</a>和<a href=\"https://github.com/jcheng5/rxtools\">rxtools</a>包。这两个都是实验性包，旨在探索“高阶”反应式，即通过其他反应式编程创建的反应式。我不建议你在“真实”应用中使用它们，但阅读源代码可能会很有启发性。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>shiny<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-2-反应式图没有捕获什么？\"><a href=\"#16-2-反应式图没有捕获什么？\" class=\"headerlink\" title=\"16.2 反应式图没有捕获什么？\"></a>16.2 反应式图没有捕获什么？</h2><p>在第14.4节中，我们讨论了当用户导致输入失效时会发生什么。作为应用开发者，你可能还有两个重要的情况需要使输入失效：</p>\n<ul>\n<li><p>你调用一个更新函数并设置值参数。这会向浏览器发送消息以更改输入的值，然后通知R输入值已更改。</p>\n</li>\n<li><p>你修改了一个反应式值（使用<code>reactiveVal()</code>或<code>reactiveValues()</code>创建）的值。</p>\n</li>\n</ul>\n<p>重要的是要理解，在这两种情况下，反应式值和观察者之间并没有创建反应式依赖关系。虽然这些操作会导致图失效，但它们并没有通过新的连接被记录下来。</p>\n<p>为了具体说明这个想法，请考虑以下简单的应用，其反应式图如图16.1所示。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  textInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;nm&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;clr&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Clear&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;hi&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  hi <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>paste0<span class=\"punctuation\">(</span><span class=\"string\">&quot;Hi &quot;</span><span class=\"punctuation\">,</span> input<span class=\"operator\">$</span>nm<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>hi <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span>hi<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>clr<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    updateTextInput<span class=\"punctuation\">(</span>session<span class=\"punctuation\">,</span> <span class=\"string\">&quot;nm&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/df8aa242946fb586f90d40d735dd0ea497a56b4d/0d739/diagrams/reactivity-tracking/invalidate-1.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/df8aa242946fb586f90d40d735dd0ea497a56b4d/0d739/diagrams/reactivity-tracking/invalidate-1.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图16.1 反应式图没有记录未命名观察者和nm输入之间的连接；这种依赖关系超出了它的范围\"></p>\n<p>当你按下清除按钮时会发生什么？</p>\n<ul>\n<li><code>input$clr</code>失效，然后观察者也会失效。</li>\n<li>观察者重新计算，重新建立对<code>input$clr</code>的依赖，并告诉浏览器更改输入控件的值。</li>\n<li>浏览器更改nm的值。</li>\n<li><code>input$nm</code>失效，导致<code>hi()</code>失效，然后是<code>output$hi</code>。</li>\n<li><code>output$hi</code>重新计算，强制<code>hi()</code>重新计算。</li>\n</ul>\n<p>这些操作都没有改变反应式图，所以它仍然如图16.1所示，并且图没有捕获从观察者到<code>input$nm</code>的连接。</p>\n<h2 id=\"16-3-案例研究\"><a href=\"#16-3-案例研究\" class=\"headerlink\" title=\"16.3 案例研究\"></a>16.3 案例研究</h2><p>接下来，让我们看一些有用的案例，在这些案例中，你可能需要结合<code>reactiveValues()</code>和<code>observeEvent()</code>或<code>observe()</code>来解决一些非常具有挑战性（甚至不可能）的问题。这些是你的应用中有用的模板。</p>\n<h3 id=\"16-3-1-多个输入修改一个输出\"><a href=\"#16-3-1-多个输入修改一个输出\" class=\"headerlink\" title=\"16.3.1 多个输入修改一个输出\"></a>16.3.1 多个输入修改一个输出</h3><p>首先，我们将解决一个非常简单的问题：我希望有一个文本框，它可以由多个事件更新。</p>\n<figure class=\"highlight plaintext\"><figcaption><span><- fluidPage(</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  actionButton(&quot;drink&quot;, &quot;drink me&quot;),</span><br><span class=\"line\">  actionButton(&quot;eat&quot;, &quot;eat me&quot;),</span><br><span class=\"line\">  textOutput(&quot;notice&quot;)</span><br><span class=\"line\">)</span><br><span class=\"line\">server &lt;- function(input, output, session) &#123;</span><br><span class=\"line\">  r &lt;- reactiveValues(notice = &quot;&quot;)</span><br><span class=\"line\">  observeEvent(input$drink, &#123;</span><br><span class=\"line\">    r$notice &lt;- &quot;You are no longer thirsty&quot;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  observeEvent(input$eat, &#123;</span><br><span class=\"line\">    r$notice &lt;- &quot;You are no longer hungry&quot;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  output$notice &lt;- renderText(r$notice)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在下一个例子中，事情会变得稍微复杂一些，我们有一个应用，其中有两个按钮，分别用于增加和减少值。我们使用<code>reactiveValues()</code>来存储当前值，然后使用<code>observeEvent()</code>在按下相应的按钮时增加或减少该值。这里的主要额外复杂性在于，<code>r$n</code>的新值取决于之前的值。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;up&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;up&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;down&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;down&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;n&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>n <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>up<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span>n <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>n <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>down<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span>n <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>n <span class=\"operator\">-</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  output<span class=\"operator\">$</span>n <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>n<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>图16.2显示了此示例的反应式图。再次注意，反应式图不包括从观察者到反应式值<code>n</code>的任何连接。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/11c52cd6c1484323dcac858b7e003cc437ed83ae/3dcbe/diagrams/reactivity-components/button.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/11c52cd6c1484323dcac858b7e003cc437ed83ae/3dcbe/diagrams/reactivity-components/button.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图16.2 反应式图不捕获从观察者到输入值的连接\"></p>\n<h3 id=\"16-3-2-累加输入\"><a href=\"#16-3-2-累加输入\" class=\"headerlink\" title=\"16.3.2 累加输入\"></a>16.3.2 累加输入</h3><p>如果你想通过累加数据来支持数据输入，那么这也是一个类似的模式。这里的主要区别在于，我们使用<a href=\"https://rdrr.io/pkg/shiny/man/updateTextInput.html\">updateTextInput()</a>在用户点击添加按钮后重置文本框。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  textInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;add&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;add&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;names&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span><span class=\"built_in\">names</span> <span class=\"operator\">=</span> character<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>add<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span><span class=\"built_in\">names</span> <span class=\"operator\">&lt;-</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>name<span class=\"punctuation\">,</span> r<span class=\"operator\">$</span><span class=\"built_in\">names</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    updateTextInput<span class=\"punctuation\">(</span>session<span class=\"punctuation\">,</span> <span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  output<span class=\"operator\">$</span><span class=\"built_in\">names</span> <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span><span class=\"built_in\">names</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以让这个应用更加实用，方法是提供一个删除按钮，并确保添加按钮不会创建重复的名称：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  textInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;add&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;add&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;del&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;delete&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;names&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span><span class=\"built_in\">names</span> <span class=\"operator\">=</span> character<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>add<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span><span class=\"built_in\">names</span> <span class=\"operator\">&lt;-</span> union<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span><span class=\"built_in\">names</span><span class=\"punctuation\">,</span> input<span class=\"operator\">$</span>name<span class=\"punctuation\">)</span></span><br><span class=\"line\">    updateTextInput<span class=\"punctuation\">(</span>session<span class=\"punctuation\">,</span> <span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>del<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span><span class=\"built_in\">names</span> <span class=\"operator\">&lt;-</span> setdiff<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span><span class=\"built_in\">names</span><span class=\"punctuation\">,</span> input<span class=\"operator\">$</span>name<span class=\"punctuation\">)</span></span><br><span class=\"line\">    updateTextInput<span class=\"punctuation\">(</span>session<span class=\"punctuation\">,</span> <span class=\"string\">&quot;name&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  output<span class=\"operator\">$</span><span class=\"built_in\">names</span> <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span><span class=\"built_in\">names</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-3-3-暂停动画\"><a href=\"#16-3-3-暂停动画\" class=\"headerlink\" title=\"16.3.3 暂停动画\"></a>16.3.3 暂停动画</h3><p>另一个常见的用例是提供一个开始和停止按钮，以便你控制一些重复发生的事件。此示例使用运行中的反应式值来控制数字是否递增，并使用<code>invalidateLater()</code>来确保在运行时每250毫秒使观察者失效一次。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;start&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;start&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;stop&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;stop&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;n&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>running <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">,</span> n <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>start<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span>running <span class=\"operator\">&lt;-</span> <span class=\"literal\">TRUE</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observeEvent<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>stop<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span>running <span class=\"operator\">&lt;-</span> <span class=\"literal\">FALSE</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>running<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      r<span class=\"operator\">$</span>n <span class=\"operator\">&lt;-</span> isolate<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>n<span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">      invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">250</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>n <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>n<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，在这种情况下，我们不能轻松地使用<code>observeEvent()</code>，因为我们需要根据<code>running()</code>是TRUE还是FALSE来执行不同的操作。由于我们不能使用<code>observeEvent()</code>，因此我们必须使用<code>isolate()</code>——如果我们不使用它，这个观察者还会对<code>n</code>产生反应式依赖，而<code>n</code>正是它更新的对象，因此它会陷入无限循环。</p>\n<p>希望这些示例能让你对使用<code>reactiveValues()</code>和<code>observe()</code>进行编程有所感受。它非常直观：当发生这种情况时，执行那个操作；当发生那种情况时，执行另一个操作。这在小范围内更容易理解，但当更大的部分开始交互时就更难理解了。因此，一般来说，你会希望尽可能少地使用它，并将其隔离开来，以便尽可能少的观察者修改反应式值。</p>\n<h3 id=\"16-3-4-练习\"><a href=\"#16-3-4-练习\" class=\"headerlink\" title=\"16.3.4 练习\"></a>16.3.4 练习</h3><p>提供一个服务器函数，当点击“normal”时，绘制100个正态分布的随机数的直方图，当点击“uniform”时，绘制100个均匀分布的随机数。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;rnorm&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Normal&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;runif&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Uniform&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  plotOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;plot&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>修改你上面的代码以使其与以下UI一起工作：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  selectInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;type&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;type&quot;</span><span class=\"punctuation\">,</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;Normal&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;Uniform&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;go&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;go&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  plotOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;plot&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>根据你之前的答案重写代码，以消除对<code>observe()</code>&#x2F;<code>observeEvent()</code>的使用，而仅使用<code>reactive()</code>。为什么你可以在第二个UI中这样做，而在第一个UI中却不能？</p>\n<h2 id=\"16-4-反模式-Anti-patterns\"><a href=\"#16-4-反模式-Anti-patterns\" class=\"headerlink\" title=\"16.4 反模式 (Anti-patterns)\"></a>16.4 反模式 (Anti-patterns)</h2><p>一旦你掌握了这种模式，就很容易养成坏习惯：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>df <span class=\"operator\">=</span> cars<span class=\"punctuation\">)</span></span><br><span class=\"line\">  observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    r<span class=\"operator\">$</span>df <span class=\"operator\">&lt;-</span> head<span class=\"punctuation\">(</span>cars<span class=\"punctuation\">,</span> input<span class=\"operator\">$</span>nrows<span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  output<span class=\"operator\">$</span>plot <span class=\"operator\">&lt;-</span> renderPlot<span class=\"punctuation\">(</span>plot<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>df<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>table <span class=\"operator\">&lt;-</span> renderTable<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>df<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个简单的例子中，与使用<code>reactive()</code>的替代方案相比，这段代码并没有做太多额外的工作：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  df <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>head<span class=\"punctuation\">(</span>cars<span class=\"punctuation\">,</span> input<span class=\"operator\">$</span>nrows<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  output<span class=\"operator\">$</span>plot <span class=\"operator\">&lt;-</span> renderPlot<span class=\"punctuation\">(</span>plot<span class=\"punctuation\">(</span>df<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>table <span class=\"operator\">&lt;-</span> renderTable<span class=\"punctuation\">(</span>df<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>但仍然存在两个缺点：</p>\n<ul>\n<li><p>如果表格或图表位于当前不可见的标签页中，观察者仍然会绘制&#x2F;显示它们。</p>\n</li>\n<li><p>如果<code>head()</code>函数出错，<code>observe()</code>将终止应用，但<code>reactive()</code>会传播错误，以便显示。然而，如果<code>reactive()</code>抛出错误，它不会被传播。</p>\n</li>\n</ul>\n<p>随着应用变得越来越复杂，情况会逐渐变得更糟。很容易退回到第13.2.3节中描述的事件驱动编程情况。你最终会花费大量精力来分析应用中的事件流，而不是依赖Shiny自动为你处理。</p>\n<p>比较这两个反应式图是有启发性的。图16.3显示了第一个示例的图。这是误导性的，因为它看起来不像<code>nrows</code>与<code>df()</code>有连接。使用如图16.4所示的反应式，可以很容易地看到它们之间的精确连接。拥有一个尽可能简单的反应式图对于人类和Shiny来说都很重要。简单的图对人类来说更容易理解，对Shiny来说也更容易优化。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/f86c5d20efbea98c76a10026851060db8cbede2d/d2245/diagrams/reactivity-components/danger.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/f86c5d20efbea98c76a10026851060db8cbede2d/d2245/diagrams/reactivity-components/danger.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图16.3 使用响应式值和观察者会导致图表的一部分断开连接\"></p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/216ca90acb1508ba9e1d7ee23d9db15becdb2ef2/ced9f/diagrams/reactivity-components/danger-2.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/216ca90acb1508ba9e1d7ee23d9db15becdb2ef2/ced9f/diagrams/reactivity-components/danger-2.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图16.4 使用响应式编程使得组件之间的依赖关系非常清晰\"></p>\n<h2 id=\"16-5-总结\"><a href=\"#16-5-总结\" class=\"headerlink\" title=\"16.5 总结\"></a>16.5 总结</h2><p>在过去的四章中，您深入了解了Shiny使用的响应式编程模型。您学习了为什么响应式编程很重要（它允许Shiny仅完成所需的工作，不多也不少），以及响应式图的细节。您还稍微了解了一些基本构建块在内部的工作原理，以及如何在需要时利用它们来摆脱响应式图的限制。</p>\n<p>在接下来的七章中，您将学习如何保持Shiny应用程序的可维护性、性能和安全性，随着其规模和影响力的不断增长。</p>\n<h1 id=\"代码获取\"><a href=\"#代码获取\" class=\"headerlink\" title=\"代码获取\"></a>代码获取</h1><p>关注公众号“生信之巅”，聊天窗口回复“85d7”获取下载链接。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n\n\n<p><font color=\"#FF0000\"><ruby><b>敬告</b>：使用文中脚本请引用本文网址，请尊重本人的劳动成果，谢谢！<rt><b>Notice</b>: When you use the scripts in this article, please cite the link of this webpage. Thank you!</rt></ruby></font></p>\n","raw":null,"categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"编程","path":"api/tags/编程.json"},{"name":"Shiny入门系列","path":"api/tags/Shiny入门系列.json"}]},{"title":"Shiny从入门到入定——15-Reactive building blocks","slug":"Shiny从入门到入定——15-Reactive-building-blocks","date":"2024-09-26T14:00:23.000Z","updated":"2024-09-26T14:29:29.863Z","comments":true,"path":"api/articles/Shiny从入门到入定——15-Reactive-building-blocks.json","excerpt":null,"keywords":null,"cover":"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","content":"<h1 id=\"15-反应式构建块\"><a href=\"#15-反应式构建块\" class=\"headerlink\" title=\"15 反应式构建块\"></a>15 反应式构建块</h1><p>既然你已经理解了反应式图背后的理论，并且有了一些实践经验，那么现在是时候更详细地讨论反应式如何融入R编程语言中了。反应式编程有三个基本构建块：<code>反应式值</code>、<code>反应式表达式</code>和<code>观察者</code>。你已经看到了反应式值和表达式的大部分重要部分，所以本章将花更多时间讨论观察者和输出（你将了解到输出是一种特殊的观察者）。你还将学习控制反应式图的另外两个工具：<code>隔离</code>和<code>定时无效化</code>。</p>\n<p>本章将再次使用反应式控制台，这样我们就可以直接在控制台中试验反应式，而无需每次都启动一个Shiny应用程序。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>shiny<span class=\"punctuation\">)</span></span><br><span class=\"line\">reactiveConsole<span class=\"punctuation\">(</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-1-反应式值\"><a href=\"#15-1-反应式值\" class=\"headerlink\" title=\"15.1 反应式值\"></a>15.1 反应式值</h2><p>反应式值有两种类型：</p>\n<ul>\n<li><p>使用<a href=\"https://rdrr.io/pkg/shiny/man/reactiveVal.html\">reactiveVal()</a>创建的单个反应式值。</p>\n</li>\n<li><p>使用<a href=\"https://rdrr.io/pkg/shiny/man/reactiveValues.html\">reactiveValues()</a>创建的反应式值列表。</p>\n</li>\n</ul>\n<p>它们在获取和设置值时的接口略有不同：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">20</span><span class=\"punctuation\">)</span>     <span class=\"comment\"># set</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br><span class=\"line\"></span><br><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 20 <span class=\"comment\"># set</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br></pre></td></tr></table></figure>\n\n<p>不幸的是，这两个类似的对象有着截然不同的接口，但没有办法将它们标准化。然而，尽管它们看起来不同，但行为是相同的，所以你可以根据自己的语法偏好来选择使用哪一个。在本书中，我使用<code>reactiveValues()</code>，因为它的语法一目了然，但在我的代码中，我倾向于使用<code>reactiveVal()</code>，因为它的语法清楚地表明正在发生一些不寻常的事情。</p>\n<p>重要的是要注意，这两种类型的反应式值都具有所谓的引用语义。大多数R对象在修改时具有复制语义，这意味着如果你将相同的值赋给两个名称，一旦你修改了其中一个，连接就会断开：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1 <span class=\"operator\">&lt;-</span> a2 <span class=\"operator\">&lt;-</span> 10</span><br><span class=\"line\">a2 <span class=\"operator\">&lt;-</span> 20</span><br><span class=\"line\">a1 <span class=\"comment\"># 未改变</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br></pre></td></tr></table></figure>\n\n<p>但反应式值则不是这样——它们总是保持对相同值的引用，因此修改任何副本都会修改所有值：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b1 <span class=\"operator\">&lt;-</span> b2 <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">b1<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 20</span><br><span class=\"line\">b2<span class=\"operator\">$</span>x</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br></pre></td></tr></table></figure>\n\n<p>我们将在第16章中讨论为什么你可能需要创建自己的反应式值。否则，你将遇到的大多数反应式值都将来自<code>server</code>函数的输入参数。这些与你自己创建的<code>reactiveValues()</code>略有不同，因为它们是只读的：你不能修改这些值，因为Shiny会根据浏览器中的用户操作自动更新它们。</p>\n<h3 id=\"15-1-1-练习\"><a href=\"#15-1-1-练习\" class=\"headerlink\" title=\"15.1.1 练习\"></a>15.1.1 练习</h3><ul>\n<li><p>这两个反应式值列表之间有什么区别？比较获取和设置单个反应式值的语法。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l1 <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>a <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">l2 <span class=\"operator\">&lt;-</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>a <span class=\"operator\">=</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> b <span class=\"operator\">=</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设计并执行一个小实验，以验证<code>reactiveVal()</code>也具有引用语义。</p>\n</li>\n</ul>\n<h2 id=\"15-2-反应式表达式\"><a href=\"#15-2-反应式表达式\" class=\"headerlink\" title=\"15.2 反应式表达式\"></a>15.2 反应式表达式</h2><p>回忆一下，反应式有两个重要特性：它是<code>惰性</code>的并且具有<code>缓存</code>。这意味着它只有在真正需要时才会工作，如果连续调用两次，它会返回之前的值。</p>\n<p>我们还没有涵盖两个重要的细节：反应式表达式如何处理错误，以及为什么<code>on.exit()</code>在它们内部有效。</p>\n<h3 id=\"15-2-1-错误\"><a href=\"#15-2-1-错误\" class=\"headerlink\" title=\"15.2.1 错误\"></a>15.2.1 错误</h3><p>反应式表达式以与缓存值完全相同的方式缓存错误。例如，考虑这个反应式：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>stop<span class=\"punctuation\">(</span><span class=\"string\">&quot;Error occured at &quot;</span><span class=\"punctuation\">,</span> Sys.time<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> call. <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; Error: Error occured at 2022-08-23 23:10:12</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们等待一两秒钟，我们可以看到我们得到了与之前相同的错误：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; Error: Error occured at 2022-08-23 23:10:12</span></span><br></pre></td></tr></table></figure>\n\n<p>在反应式图中，错误的处理方式与值相同：错误通过反应式图传播的方式与常规值完全相同。唯一的区别是当错误遇到输出或观察者时会发生什么：</p>\n<ul>\n<li>输出中的错误将在应用程序中显示。</li>\n<li>观察者中的错误将导致当前会话终止。如果你不希望发生这种情况，你需要将代码包装在<code>try()</code>或<code>tryCatch()</code>中。</li>\n</ul>\n<p>这个相同的系统还支持<code>req()</code>（第8.1.2节），它发出一种特殊类型的错误。这种特殊错误会导致观察者和输出停止它们正在做的事情，但不会导致失败。默认情况下，它会使输出重置为其初始空白状态，但如果你使用<code>req(..., cancelOutput = TRUE)</code>，它们将保留其当前显示。</p>\n<h3 id=\"15-2-2-on-exit\"><a href=\"#15-2-2-on-exit\" class=\"headerlink\" title=\"15.2.2 on.exit()\"></a>15.2.2 on.exit()</h3><p>你可以将<code>reactive(x())</code>视为<code>function() x()</code>的快捷方式，它自动添加了惰性和缓存。这主要在你想要了解Shiny是如何实现的时候很重要，但这也意味着你可以使用那些只能在函数内部工作的函数。其中最有用的是<code>on.exit()</code>，它允许你在反应式表达式完成时运行代码，无论反应式是否成功返回错误或失败。这就是<code>on.exit()</code>在第8.2.2节中工作的原因。</p>\n<h3 id=\"15-2-3-练习\"><a href=\"#15-2-3-练习\" class=\"headerlink\" title=\"15.2.3 练习\"></a>15.2.3 练习</h3><ul>\n<li><p>使用<code>reactlog</code>包来观察以下应用程序中错误通过反应式传播的情况，确认它遵循与值传播相同的规则。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  checkboxInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;error&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;error?&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;result&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  a <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>error<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      stop<span class=\"punctuation\">(</span><span class=\"string\">&quot;Error!&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span> <span class=\"keyword\">else</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  b <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>a<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"built_in\">c</span> <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>b<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>result <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改上述应用程序，使用<code>req()</code>代替<code>stop()</code>。验证事件是否仍然以相同的方式传播。当你使用<code>cancelOutput</code>参数时会发生什么？</p>\n</li>\n</ul>\n<h2 id=\"15-3-观察者和输出\"><a href=\"#15-3-观察者和输出\" class=\"headerlink\" title=\"15.3 观察者和输出\"></a>15.3 观察者和输出</h2><p>观察者和输出是反应式图中的终端节点。它们在两个重要方面与反应式表达式不同：</p>\n<ul>\n<li><p>它们是急切的且健忘的——它们尽可能快地运行，并且不记得之前的操作。这种急切性是“传染性的”，因为如果它们使用了一个反应式表达式，那么该反应式表达式也将被评估。</p>\n</li>\n<li><p>观察者返回的值被忽略，因为它们被设计为与称为副作用的函数一起工作，如<code>cat()</code>或<code>write.csv()</code>。</p>\n</li>\n</ul>\n<p>观察者和输出由同一个底层工具提供支持：<code>observe()</code>。这设置了一个代码块，每次它使用的反应式值或表达式更新时，该代码块就会运行。请注意，当你创建观察者时，它会立即运行——它必须这样做才能确定其反应式依赖项。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  message<span class=\"punctuation\">(</span><span class=\"string\">&quot;`y` is &quot;</span><span class=\"punctuation\">,</span> y<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">y<span class=\"punctuation\">(</span><span class=\"number\">5</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 5</span></span><br><span class=\"line\">y<span class=\"punctuation\">(</span><span class=\"number\">4</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 4</span></span><br></pre></td></tr></table></figure>\n\n<p>在这本书中，我很少使用<a href=\"https://rdrr.io/pkg/shiny/man/observe.html\">observe()</a>，因为它是为用户友好的<a href=\"https://rdrr.io/pkg/shiny/man/observeEvent.html\">observeEvent()</a>提供动力的底层工具。通常，你应该坚持使用<code>observeEvent()</code>，除非它无法实现你想要的功能。在本书中，我只会向你展示一个必须使用<code>observe()</code>的案例，即第16.3.3节。</p>\n<p><code>observe()</code>也为响应式输出提供动力。响应式输出是一种特殊的观察者，它们具有两个重要属性：</p>\n<ul>\n<li><p>当你将它们赋值给输出时，它们就会被定义，即<code>output$text &lt;- ...</code>会创建观察者。</p>\n</li>\n<li><p>它们具有一些有限的检测能力，可以检测到自己是否不可见（即它们位于非活动标签页中），因此不必重新计算。</p>\n</li>\n</ul>\n<p>重要的是要注意，<code>observe()</code>和响应式输出并不“执行”某些操作，而是“创建”某些东西（然后根据需要采取行动）。这种思维方式有助于你理解这个例子中的情况：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">y <span class=\"operator\">&lt;-</span> observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observe<span class=\"punctuation\">(</span>print<span class=\"punctuation\">(</span>x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 1</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">3</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br></pre></td></tr></table></figure>\n\n<p>每当<code>x</code>发生变化时，观察者就会被触发。观察者本身会调用<code>observe()</code>来设置另一个观察者。因此，每次<code>x</code>发生变化时，都会获得另一个观察者，从而导致其值再次被打印。</p>\n<p>作为一般规则，你应该只在服务器函数的顶层创建观察者或输出。如果你发现自己试图嵌套它们或在输出内部创建观察者，那么你应该坐下来，画出你想要创建的响应式图表的草图——几乎可以肯定存在更好的方法。在更复杂的应用程序中，这个错误可能更难直接发现，但你可以始终使用<code>reactlog</code>：只需查找观察者（或输出）中意外的变化，然后追踪到是什么导致了这些变化。</p>\n<h2 id=\"15-4-代码隔离\"><a href=\"#15-4-代码隔离\" class=\"headerlink\" title=\"15.4 代码隔离\"></a>15.4 代码隔离</h2><p>为了结束本章，我将讨论两个重要的工具，用于精确控制响应式图表的失效方式和时间。在本节中，我将讨论<a href=\"https://rdrr.io/pkg/shiny/man/isolate.html\">isolate()</a>，这是<code>observeEvent()</code>和<a href=\"https://rdrr.io/pkg/shiny/man/observeEvent.html\">eventReactive()</a>的底层工具，它允许你在不需要时避免创建响应式依赖。在下一节中，你将学习<a href=\"https://rdrr.io/pkg/shiny/man/invalidateLater.html\">invalidateLater()</a>，它允许你按计划生成响应式失效。</p>\n<h3 id=\"15-4-1-isolate\"><a href=\"#15-4-1-isolate\" class=\"headerlink\" title=\"15.4.1 isolate()\"></a>15.4.1 isolate()</h3><p>观察者通常与响应式值结合使用，以便跟踪状态随时间的变化。例如，考虑以下代码，它跟踪<code>x</code>发生变化的次数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>count <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> x <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r<span class=\"operator\">$</span>x</span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>count <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你运行这段代码，你会立即陷入无限循环，因为观察者会对<code>x</code>和<code>count</code>产生响应式依赖；由于观察者修改了<code>count</code>，它会立即重新运行。</p>\n<p>幸运的是，Shiny提供了<code>isolate()</code>来解决这个问题。此函数允许你访问响应式值或表达式的当前值，而不会产生对它的依赖：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>count <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> x <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"built_in\">class</span><span class=\"punctuation\">(</span>r<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] &quot;rv_flush_on_write&quot; &quot;reactivevalues&quot;</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r<span class=\"operator\">$</span>x</span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> isolate<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>count<span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 1</span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 2</span><br><span class=\"line\">r<span class=\"operator\">$</span>count</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 3</span><br><span class=\"line\">r<span class=\"operator\">$</span>count</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br></pre></td></tr></table></figure>\n\n<p>和<code>observe()</code>一样，很多时候你不需要直接使用<code>isolate()</code>，因为有两个有用的函数封装了最常见的用法：<code>observeEvent()</code>和<code>eventReactive()</code>。</p>\n<h3 id=\"15-4-2-observeEvent-和-eventReactive\"><a href=\"#15-4-2-observeEvent-和-eventReactive\" class=\"headerlink\" title=\"15.4.2 observeEvent() 和 eventReactive()\"></a>15.4.2 observeEvent() 和 eventReactive()</h3><p>当你看到上面的代码时，你可能会想起第3.6节，并好奇为什么我没有使用<code>observeEvent()</code>：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observeEvent<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>x<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>count <span class=\"operator\">+</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，我本可以使用它，因为<code>observeEvent(x, y)</code>等价于<code>observe(&#123;x; isolate(y)&#125;)</code>。它优雅地将你想要监听的内容与你想要执行的操作分离开来。而<code>eventReactive()</code>则为响应式值执行类似的任务：<code>eventReactive(x, y)</code>等价于<code>reactive(&#123;x; isolate(y)&#125;)</code>。</p>\n<p><code>observeEvent()</code>和<code>eventReactive()</code>都有额外的参数，允许你控制它们的操作细节：</p>\n<ul>\n<li>默认情况下，这两个函数都会忽略产生NULL的任何事件（或在操作按钮的特殊情况下为0）。使用<code>ignoreNULL = FALSE</code>来处理NULL值。</li>\n<li>默认情况下，当你创建这两个函数时，它们都会运行一次。使用<code>ignoreInit = TRUE</code>来跳过这次运行。</li>\n<li>仅对于<code>observeEvent()</code>，你可以使用<code>once = TRUE</code>来使处理程序仅运行一次。</li>\n</ul>\n<p>这些参数很少需要，但知道它们的存在是很有用的，这样你就可以在需要时从文档中查找详细信息。</p>\n<h3 id=\"15-4-3-练习\"><a href=\"#15-4-3-练习\" class=\"headerlink\" title=\"15.4.3 练习\"></a>15.4.3 练习</h3><p>使用服务器函数完成下面的应用程序，该函数仅在按钮被按下时更新<code>out</code>的值为<code>x</code>的值。</p>\n<p>（注意：由于这是一个练习，我不会直接给出完整的代码，但你可以按照以下思路编写：</p>\n<ol>\n<li>在UI中定义一个动作按钮和一个用于显示结果的文本输出。</li>\n<li>在服务器函数中，使用<code>observeEvent()</code>监听按钮点击事件。</li>\n<li>在<code>observeEvent()</code>的回调函数中，更新文本输出的值。）</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;x&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;x&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"number\">50</span><span class=\"punctuation\">,</span> <span class=\"built_in\">min</span> <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"built_in\">max</span> <span class=\"operator\">=</span> <span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;capture&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;capture&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;out&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-5-定时失效\"><a href=\"#15-5-定时失效\" class=\"headerlink\" title=\"15.5 定时失效\"></a>15.5 定时失效</h2><p><code>isolate()</code> 减少了响应式图被失效的时间。而本节的主题 <code>invalidateLater()</code> 则做相反的事情：它允许你在数据没有变化时使响应式图失效。在 3.5.1 节中，你通过 <a href=\"https://rdrr.io/pkg/shiny/man/reactiveTimer.html\">reactiveTimer()</a> 看到了它的一个例子，但现在是时候讨论它背后的底层工具了：<code>invalidateLater()</code>。</p>\n<p><code>invalidateLater(ms)</code> 会导致任何响应式消费者在将来的某个时间点（<code>ms</code> 毫秒后）失效。这对于创建动画和连接到 Shiny 响应式框架之外可能随时间变化的数据源非常有用。例如，以下响应式表达式将每半秒自动生成 10 个新的随机正态分布数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  rnorm<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>而这个观察者将使用一个随机数增加累积和：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sum</span> <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">300</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>isolate<span class=\"punctuation\">(</span><span class=\"built_in\">sum</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> runif<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>在后续部分中，你将学习如何使用 <code>invalidateLater()</code> 从磁盘读取变化的数据，如何避免 <code>invalidateLater()</code> 陷入无限循环，以及关于失效确切发生时间的偶尔重要的细节。</p>\n<h3 id=\"15-5-1-轮询\"><a href=\"#15-5-1-轮询\" class=\"headerlink\" title=\"15.5.1 轮询\"></a>15.5.1 轮询</h3><p><code>invalidateLater()</code> 的一个有用应用是将 Shiny 连接到 R 外部变化的数据。例如，你可以使用以下响应式表达式每秒重新读取一次 CSV 文件：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">on.exit</span><span class=\"punctuation\">(</span>invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  read.csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>这会将变化的数据连接到 Shiny 的响应式图中，但它有一个严重的缺点：当你使响应式失效时，你也会使所有下游消费者失效，因此即使数据相同，所有下游工作也必须重做。</p>\n<p>为了避免这个问题，Shiny 提供了 <a href=\"https://rdrr.io/pkg/shiny/man/reactivePoll.html\">reactivePoll()</a>，它接受两个函数：一个执行相对便宜的检查以查看数据是否已更改，另一个更昂贵的函数实际执行计算。我们可以使用 <code>reactivePoll()</code> 重写前面的响应式，如下所示。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  data <span class=\"operator\">&lt;-</span> reactivePoll<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">,</span> session<span class=\"punctuation\">,</span> </span><br><span class=\"line\">    <span class=\"keyword\">function</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> file.mtime<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> read.csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我们使用了 <a href=\"https://rdrr.io/r/base/file.info.html\">file.mtime()</a>，它返回文件最后一次修改的时间，作为是否需要重新加载文件的廉价检查。</p>\n<p>当文件变化时读取文件是一个常见任务，因此 Shiny 提供了一个更具体的辅助函数，它只需要文件名和读取函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  data <span class=\"operator\">&lt;-</span> reactiveFileReader<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">,</span> session<span class=\"punctuation\">,</span> <span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">,</span> read.csv<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你需要从其他来源（例如数据库）读取变化的数据，你需要自己编写 <code>reactivePoll()</code> 代码。</p>\n<h3 id=\"15-5-2-长时间运行的响应式\"><a href=\"#15-5-2-长时间运行的响应式\" class=\"headerlink\" title=\"15.5.2 长时间运行的响应式\"></a>15.5.2 长时间运行的响应式</h3><p>如果你正在执行长时间的计算，你需要考虑一个重要问题：何时执行 <code>invalidateLater()</code>？例如，考虑以下响应式：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>假设Shiny在0时刻开始反应式运行，它将在500毫秒时请求失效。反应式运行需要1000毫秒，所以现在时间到了1000毫秒，它立即失效并需要重新计算，这又会触发另一次失效：我们陷入了一个无限循环。</p>\n<p>另一方面，如果你在末尾运行<code>invalidateLater()</code>，它将在完成后500毫秒失效，所以反应式将每1500毫秒重新运行一次。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">on.exit</span><span class=\"punctuation\">(</span>invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> add <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n<p>这是选择<code>invalidateLater()</code>而不是我们之前使用的更简单的<code>reactiveTimer()</code>的主要原因：它让你对失效发生的确切时间有更大的控制权。</p>\n<h3 id=\"15-5-3-定时器准确性\"><a href=\"#15-5-3-定时器准确性\" class=\"headerlink\" title=\"15.5.3 定时器准确性\"></a>15.5.3 定时器准确性</h3><p><code>invalidateLater()</code>中指定的毫秒数是一个礼貌的请求，而不是一个强制要求。当你请求失效发生时，R可能正在做其他事情，所以你的请求必须等待。这实际上意味着这个数值是一个最小值，失效可能会比你预期的时间更长。在大多数情况下，这并不重要，因为小的差异不太可能影响用户对应用程序的感知。然而，在许多小错误会累积的情况下，你应该计算实际经过的时间并使用它来调整你的计算。</p>\n<p>例如，以下代码根据速度和经过的时间计算距离。而不是假设<code>invalidateLater(100)</code>总是精确延迟100毫秒，我计算经过的时间并在计算位置时使用它。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">velocity <span class=\"operator\">&lt;-</span> 3</span><br><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>distance <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">last <span class=\"operator\">&lt;-</span> <span class=\"built_in\">proc.time</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[[</span><span class=\"number\">3</span><span class=\"punctuation\">]</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  cur <span class=\"operator\">&lt;-</span> <span class=\"built_in\">proc.time</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[[</span><span class=\"number\">3</span><span class=\"punctuation\">]</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">  time <span class=\"operator\">&lt;-</span> last <span class=\"operator\">-</span> cur</span><br><span class=\"line\">  last <span class=\"operator\">&lt;&lt;-</span> cur</span><br><span class=\"line\">  </span><br><span class=\"line\">  r<span class=\"operator\">$</span>distance <span class=\"operator\">&lt;-</span> isolate<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>distance<span class=\"punctuation\">)</span> <span class=\"operator\">+</span> velocity <span class=\"operator\">*</span> time</span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你不是在仔细做动画，那么请随意忽略<code>invalidateLater()</code>中固有的变化。只需记住，它是一个礼貌的请求，而不是一个要求。</p>\n<h3 id=\"15-5-4-练习\"><a href=\"#15-5-4-练习\" class=\"headerlink\" title=\"15.5.4 练习\"></a>15.5.4 练习</h3><p>为什么这个反应式表达式永远不会被执行？你的解释应该涉及反应式图和失效机制。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    rnorm<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span>  </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你熟悉SQL，请使用<code>reactivePoll()</code>来仅当新行被添加时才重新读取一个虚构的“Results”表。你可以假设Results表有一个时间戳字段，该字段包含记录被添加的日期和时间。</p>\n<h3 id=\"15-6-总结\"><a href=\"#15-6-总结\" class=\"headerlink\" title=\"15.6 总结\"></a>15.6 总结</h3><p>在本章中，你深入了解了使Shiny工作的基石：反应式值、反应式表达式、观察者和定时评估。现在，我们将注意力转向反应式值和观察者的特定组合，这种组合使我们能够摆脱反应式图的一些约束（无论好坏）。</p>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n\n\n<p><font color=\"#FF0000\"><ruby><b>敬告</b>：使用文中脚本请引用本文网址，请尊重本人的劳动成果，谢谢！<rt><b>Notice</b>: When you use the scripts in this article, please cite the link of this webpage. Thank you!</rt></ruby></font></p>\n","raw":null,"categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"编程","path":"api/tags/编程.json"},{"name":"Shiny入门系列","path":"api/tags/Shiny入门系列.json"}]},{"title":"Shiny从入门到入定——14-The reactive graph","slug":"Shiny从入门到入定——14-The-reactive-graph","date":"2024-09-26T13:56:01.000Z","updated":"2024-09-26T14:29:29.863Z","comments":true,"path":"api/articles/Shiny从入门到入定——14-The-reactive-graph.json","excerpt":null,"keywords":null,"cover":"https://d33wubrfki0l68.cloudfront.net/9f65da9e6e5066eb409030bd85c465aa0c787e0c/7fce6/diagrams/reactivity-tracking/08.png","content":"<h1 id=\"反应图\"><a href=\"#反应图\" class=\"headerlink\" title=\"反应图\"></a>反应图</h1><h2 id=\"14-1-引言\"><a href=\"#14-1-引言\" class=\"headerlink\" title=\"14.1 引言\"></a>14.1 引言</h2><p>为了理解反应式计算，首先需要理解反应图。在本章中，我们将深入探讨反应图的细节，尤其关注事情发生的精确顺序。特别是，你将了解无效化的重要性，这是一个确保Shiny进行最少工作的关键过程。你还将了解<code>reactlog</code>包，它可以自动为实际应用程序绘制反应图。</p>\n<p>如果你有一段时间没有查看<a href=\"https://www.liaochenlanruo.fun/post/41c3.html\">第3章</a>了，我强烈建议你在继续之前重新熟悉一下。它为我们将在这里更详细探讨的概念奠定了基础。</p>\n<h2 id=\"14-2-反应式执行的逐步介绍\"><a href=\"#14-2-反应式执行的逐步介绍\" class=\"headerlink\" title=\"14.2 反应式执行的逐步介绍\"></a>14.2 反应式执行的逐步介绍</h2><p>为了解释反应式执行的过程，我们将使用图14.1中显示的图形。它包含三个反应式输入、三个反应式表达式和三个输出。请记住，反应式输入和表达式统称为<code>反应式生产者</code>；反应式表达式和输出是<code>反应式消费者</code>。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/9f65da9e6e5066eb409030bd85c465aa0c787e0c/7fce6/diagrams/reactivity-tracking/08.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/9f65da9e6e5066eb409030bd85c465aa0c787e0c/7fce6/diagrams/reactivity-tracking/08.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.1 包含三个输入、三个反应式表达式和三个输出的虚构应用程序的完整反应图\"></p>\n<p>组件之间的连接是有方向的，箭头表示反应的方向。这个方向可能会让你感到惊讶，因为很容易想到一个消费者依赖于一个或多个生产者。然而，很快你就会看到，反应流更准确地被建模为相反的方向。</p>\n<p>底层应用程序并不重要，但如果你需要一些具体的东西来帮助你理解，你可以假设它源自这个不太有用的应用程序。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;a&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;a&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;b&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;b&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;c&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;c&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  plotOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;x&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  tableOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;y&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;z&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  rng <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>a <span class=\"operator\">*</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  smp <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>sample<span class=\"punctuation\">(</span>rng<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> input<span class=\"operator\">$</span>b<span class=\"punctuation\">,</span> replace <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  bc <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>b <span class=\"operator\">*</span> input<span class=\"operator\">$</span><span class=\"built_in\">c</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  output<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> renderPlot<span class=\"punctuation\">(</span>hist<span class=\"punctuation\">(</span>smp<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>y <span class=\"operator\">&lt;-</span> renderTable<span class=\"punctuation\">(</span><span class=\"built_in\">max</span><span class=\"punctuation\">(</span>smp<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>z <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span>bc<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-3-会话开始\"><a href=\"#14-3-会话开始\" class=\"headerlink\" title=\"14.3 会话开始\"></a>14.3 会话开始</h2><p>图14.2展示了应用程序启动后且服务器函数首次执行完毕时的反应图。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/df8d3e4488102866bed17e0ac822adb0228c298e/621da/diagrams/reactivity-tracking/01.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/df8d3e4488102866bed17e0ac822adb0228c298e/621da/diagrams/reactivity-tracking/01.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.2 应用程序加载后的初始状态。对象之间没有连接，所有反应式表达式都被标记为无效（灰色）。有六个反应式消费者和六个反应式生产者\"></p>\n<p>该图中有三个重要信息：</p>\n<ul>\n<li>元素之间没有连接，因为Shiny没有反应式之间关系的先验知识。</li>\n<li>所有反应式表达式和输出都处于起始状态，即无效（灰色），意味着它们尚未运行。</li>\n<li>反应式输入已就绪（绿色），表明它们的值可用于计算。</li>\n</ul>\n<h3 id=\"14-3-1-执行开始\"><a href=\"#14-3-1-执行开始\" class=\"headerlink\" title=\"14.3.1 执行开始\"></a>14.3.1 执行开始</h3><p>现在我们开始执行阶段，如图14.3所示。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/2c6395ada69f84b77a5bf1b273994aa077958640/b1089/diagrams/reactivity-tracking/02.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/2c6395ada69f84b77a5bf1b273994aa077958640/b1089/diagrams/reactivity-tracking/02.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.3 Shiny开始执行任意的观察者/输出，标记为橙色\"></p>\n<p>在这个阶段，Shiny选择一个无效的输出并开始执行（橙色）。你可能会好奇Shiny是如何决定执行哪个无效输出的。简而言之，你应该假设它是随机的：你的观察者和输出不应该关心它们执行的顺序，因为它们被设计为独立运行。</p>\n<h3 id=\"14-3-2-读取反应式表达式\"><a href=\"#14-3-2-读取反应式表达式\" class=\"headerlink\" title=\"14.3.2 读取反应式表达式\"></a>14.3.2 读取反应式表达式</h3><p>执行输出可能需要从反应式中获取值，如图14.4所示。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/e31822819269ca1d29979b1776625198cbc6f434/246f1/diagrams/reactivity-tracking/03.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/e31822819269ca1d29979b1776625198cbc6f434/246f1/diagrams/reactivity-tracking/03.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.4 输出需要反应式表达式的值，因此它开始执行该表达式\"></p>\n<p>读取反应式会以两种方式改变图形：</p>\n<ul>\n<li>反应式表达式也需要开始计算其值（变为橙色）。请注意，输出仍在计算中：它正在等待反应式表达式返回其值，以便自己的执行可以继续进行，就像在R中进行常规函数调用一样。</li>\n<li>Shiny在输出和反应式表达式之间建立关系（即我们绘制一个箭头）。箭头的方向很重要：表达式记录它被输出使用；输出不记录它使用表达式。这是一个微妙的区别，但当你学习无效化时会更加清楚其重要性。</li>\n</ul>\n<h3 id=\"14-3-3-读取输入\"><a href=\"#14-3-3-读取输入\" class=\"headerlink\" title=\"14.3.3 读取输入\"></a>14.3.3 读取输入</h3><p>这个特定的反应式表达式碰巧读取了一个反应式输入。同样，建立了依赖&#x2F;被依赖的关系，所以在图14.5中我们添加了另一个箭头。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/1d51f64be17e3f140ee874bb2ad0a2990fc613b6/06ad6/diagrams/reactivity-tracking/04.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/1d51f64be17e3f140ee874bb2ad0a2990fc613b6/06ad6/diagrams/reactivity-tracking/04.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.5 反应式表达式也从反应式值中读取，因此我们添加了另一个箭头\"></p>\n<p>与反应式表达式和输出不同，反应式输入没有要执行的内容，因此可以立即返回。</p>\n<h3 id=\"14-3-4-反应式表达式完成\"><a href=\"#14-3-4-反应式表达式完成\" class=\"headerlink\" title=\"14.3.4 反应式表达式完成\"></a>14.3.4 反应式表达式完成</h3><p>在我们的示例中，反应式表达式读取了另一个反应式表达式，而后者又读取了另一个输入。我们将跳过对这些步骤的逐一描述，因为它们是我们已经描述过的内容的重复，并直接跳转到图14.6。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/1f35d954406c03d863cff5dc78775d5cab72f9f6/c0fa9/diagrams/reactivity-tracking/05.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/1f35d954406c03d863cff5dc78775d5cab72f9f6/c0fa9/diagrams/reactivity-tracking/05.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.6 反应式表达式已完成计算，因此变为绿色\"></p>\n<p>现在，反应式表达式已完成执行并变为绿色，表示它已就绪。它缓存了结果，因此除非其输入发生变化，否则不需要重新计算。</p>\n<h3 id=\"14-3-5-输出完成\"><a href=\"#14-3-5-输出完成\" class=\"headerlink\" title=\"14.3.5 输出完成\"></a>14.3.5 输出完成</h3><p>现在，反应式表达式已返回其值，输出可以完成执行，并变为绿色，如图14.7所示。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/0cd132c9390e1368118f5b80724ba1e8f8ae54c1/c0265/diagrams/reactivity-tracking/06.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/0cd132c9390e1368118f5b80724ba1e8f8ae54c1/c0265/diagrams/reactivity-tracking/06.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.7 输出已完成执行并变为绿色\"></p>\n<h3 id=\"14-3-6-执行下一个输出\"><a href=\"#14-3-6-执行下一个输出\" class=\"headerlink\" title=\"14.3.6 执行下一个输出\"></a>14.3.6 执行下一个输出</h3><p>现在第一个输出已完成，Shiny 会选择另一个来执行。这个输出会变成橙色（如图14.8所示），并开始从响应式生产者读取值。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/59a70dfa5486abed0124ebe23148bf25f0965237/b17bf/diagrams/reactivity-tracking/07.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/59a70dfa5486abed0124ebe23148bf25f0965237/b17bf/diagrams/reactivity-tracking/07.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.8 下一个输出开始计算，变为橙色\"></p>\n<p>已完成的响应式对象可以立即返回它们的值；无效的响应式对象将启动它们自己的执行图。这个循环将重复进行，直到每个无效的输出进入完成（绿色）状态。</p>\n<h3 id=\"14-3-7-执行完成，输出刷新\"><a href=\"#14-3-7-执行完成，输出刷新\" class=\"headerlink\" title=\"14.3.7 执行完成，输出刷新\"></a>14.3.7 执行完成，输出刷新</h3><p>现在所有的输出都已完成执行并处于空闲状态（如图14.9所示）。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/9f65da9e6e5066eb409030bd85c465aa0c787e0c/7fce6/diagrams/reactivity-tracking/08.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/9f65da9e6e5066eb409030bd85c465aa0c787e0c/7fce6/diagrams/reactivity-tracking/08.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.9 所有输出和响应式表达式都已完成并变为绿色\"></p>\n<p>这一轮响应式执行已完成，除非系统受到某种外部作用（例如，Shiny 应用程序的用户在用户界面中移动滑块），否则不会进行更多工作。从响应式的角度来看，这个会话现在处于静止状态。</p>\n<p>让我们先暂停一下，思考一下我们所做的事情。我们读取了一些输入，计算了一些值，并生成了一些输出。但更重要的是，我们还发现了响应式对象之间的关系。当一个响应式输入发生变化时，我们知道需要更新哪些响应式对象。</p>\n<h2 id=\"14-4-输入发生变化\"><a href=\"#14-4-输入发生变化\" class=\"headerlink\" title=\"14.4 输入发生变化\"></a>14.4 输入发生变化</h2><p>上一步结束时，我们的Shiny会话处于完全空闲状态。现在假设应用程序的用户更改了滑块的值。这会导致浏览器向服务器函数发送一条消息，指示Shiny更新相应的响应式输入。这将启动一个无效化阶段，该阶段包含三个部分：<code>无效化输入</code>、<code>通知依赖项</code>，然后<code>移除现有的连接</code>。</p>\n<h3 id=\"14-4-1-无效化输入\"><a href=\"#14-4-1-无效化输入\" class=\"headerlink\" title=\"14.4.1 无效化输入\"></a>14.4.1 无效化输入</h3><p>无效化阶段从已更改的输入&#x2F;值开始，我们将其填充为灰色，这是我们通常用于无效化的颜色（如图14.10所示）。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/df849130469d68302afd959a483194fe5715330d/72fad/diagrams/reactivity-tracking/09.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/df849130469d68302afd959a483194fe5715330d/72fad/diagrams/reactivity-tracking/09.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.10 用户与应用程序交互，使一个输入无效\"></p>\n<h3 id=\"14-4-2-通知依赖项\"><a href=\"#14-4-2-通知依赖项\" class=\"headerlink\" title=\"14.4.2 通知依赖项\"></a>14.4.2 通知依赖项</h3><p>现在，我们按照之前绘制的箭头方向，将每个节点着色为灰色，并将我们跟随的箭头着色为浅灰色。这产生了图14.11。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/265498cff697785cf8458453b4c316b2cb739002/4df87/diagrams/reactivity-tracking/10.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/265498cff697785cf8458453b4c316b2cb739002/4df87/diagrams/reactivity-tracking/10.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.11 无效化从输入开始，按照从左到右的每个箭头流动。在无效化过程中，Shiny 跟随的箭头被着色为较浅的灰色\"></p>\n<h3 id=\"14-4-3-移除关系\"><a href=\"#14-4-3-移除关系\" class=\"headerlink\" title=\"14.4.3 移除关系\"></a>14.4.3 移除关系</h3><p>接下来，每个无效的响应式表达式和输出都会“擦除”所有进入和离开它的箭头，从而得到图14.12，并完成无效化阶段。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/2cc1585580182ea1a8c6b7feaa570763c7114f2a/82889/diagrams/reactivity-tracking/11.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/2cc1585580182ea1a8c6b7feaa570763c7114f2a/82889/diagrams/reactivity-tracking/11.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.12：无效的节点会忘记它们之前的所有关系，以便重新发现它们\"></p>\n<p>从一个节点发出的箭头是一次性通知，它们将在下一次值发生变化时触发。现在它们已经触发了，完成了它们的使命，我们可以将它们擦除。</p>\n<p>为什么我们要擦除进入无效节点的箭头，即使它们来自的节点并未无效化，这一点可能不太明显。虽然这些箭头代表尚未触发的通知，但无效的节点不再关心它们：响应式消费者只关心通知以使自己无效化，而这已经发生了。</p>\n<p>我们如此重视这些关系，但现在却把它们抛弃了，这似乎有点反常！但这是Shiny响应式编程模型的关键部分：<font color=#FF0000>虽然这些特定的箭头很重要，但它们现在已经过时了</font>。确保我们的图保持准确性的唯一方法是，在它们变得陈旧时擦除箭头，并让Shiny在重新执行时重新发现这些节点周围的关系。我们将在第14.5节中再次讨论这个重要话题。</p>\n<h3 id=\"14-4-4-重新执行\"><a href=\"#14-4-4-重新执行\" class=\"headerlink\" title=\"14.4.4 重新执行\"></a>14.4.4 重新执行</h3><p>现在，我们处于与执行第二个输出时非常相似的情况，此时既有有效也有无效的反应式。是时候做我们之前做过的事情了：执行无效的输出，每次执行一个，从图14.13开始。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/4dadc6829acfaf4b05bbb2564904b30446287d8c/76119/diagrams/reactivity-tracking/12.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/4dadc6829acfaf4b05bbb2564904b30446287d8c/76119/diagrams/reactivity-tracking/12.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.13 现在，重新执行的过程与执行过程相同，但因为我们不是从零开始，所以要做的工作就少了很多\"></p>\n<p>同样，我不会展示具体细节，但最终结果将是一个所有节点都被标记为绿色的静止反应式图。这个过程的巧妙之处在于，Shiny只做了最小量的工作——我们只做了更新那些实际受输入变化影响的输出所需的工作。</p>\n<h3 id=\"14-4-5-练习\"><a href=\"#14-4-5-练习\" class=\"headerlink\" title=\"14.4.5 练习\"></a>14.4.5 练习</h3><ol>\n<li>为以下服务器函数绘制反应式图，并解释为什么反应式没有运行。</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">sum</span> <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>x <span class=\"operator\">+</span> input<span class=\"operator\">$</span>y <span class=\"operator\">+</span> input<span class=\"operator\">$</span>z<span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"built_in\">prod</span> <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>x <span class=\"operator\">*</span> input<span class=\"operator\">$</span>y <span class=\"operator\">*</span> input<span class=\"operator\">$</span>z<span class=\"punctuation\">)</span></span><br><span class=\"line\">  division <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"built_in\">prod</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">/</span> <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>以下反应式图通过使用Sys.sleep()模拟长时间运行的计算：</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">x2 <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">x3 <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">3</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">y1 <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  x1<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">y2 <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  x2<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">y3 <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  x2<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> x3<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> y2<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> y2<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  print<span class=\"punctuation\">(</span>y1<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  print<span class=\"punctuation\">(</span>y2<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  print<span class=\"punctuation\">(</span>y3<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果<code>x1</code>改变，图重新计算需要多长时间？<code>x2</code>或<code>x3</code>呢？</p>\n<ol start=\"3\">\n<li>如果你尝试创建一个带有循环的反应式图，会发生什么？</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">y <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>x <span class=\"operator\">+</span> y<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">y<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-5-动态性\"><a href=\"#14-5-动态性\" class=\"headerlink\" title=\"14.5 动态性\"></a>14.5 动态性</h2><p>在第14.4.3节中，你了解到Shiny“忘记”了它在记录时花费大量精力建立的反应式组件之间的连接。这使得Shiny的反应式具有动态性，因为它可以在你的应用程序运行时发生变化。这种动态性非常重要，我想用一个简单的例子来强调它：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  selectInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;choice&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;A or B?&quot;</span><span class=\"punctuation\">,</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;a&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;b&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;a&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;a&quot;</span><span class=\"punctuation\">,</span> <span class=\"number\">0</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;b&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;b&quot;</span><span class=\"punctuation\">,</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;out&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>out <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>choice <span class=\"operator\">==</span> <span class=\"string\">&quot;a&quot;</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      input<span class=\"operator\">$</span>a</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span> <span class=\"keyword\">else</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      input<span class=\"operator\">$</span>b</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>你可能会期望反应式图看起来如图14.14所示。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/3aa4c110444589f5a2be4ea81ad573315d9cf899/eb8e6/diagrams/reactivity-tracking/dynamic.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/3aa4c110444589f5a2be4ea81ad573315d9cf899/eb8e6/diagrams/reactivity-tracking/dynamic.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.14 如果Shiny静态地分析反应式，那么反应式图总是会将`choice`、`a`和`b`连接到`out`\"></p>\n<p>但是，由于Shiny在输出被标记为无效后会动态地重建图，因此它实际上看起来会像图14.15中的任何一个图，这取决于<code>input$choice</code>的值。这确保了当输入被标记为无效时，Shiny会做最少量的工作。在这种情况下，如果<code>input$choice</code>被设置为“b”，那么<code>input$a</code>的值不会影响<code>output$out</code>，因此没有必要重新计算它。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/e06cc554ebc90037aed6cbaaf28cc970d31c594a/63c0d/diagrams/reactivity-tracking/dynamic2.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/e06cc554ebc90037aed6cbaaf28cc970d31c594a/63c0d/diagrams/reactivity-tracking/dynamic2.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.15 但是，Shiny的反应式图是动态的，所以图要么将`out`连接到`choice`和`a`（左图），要么连接到`choice`和`b`（右图）\"></p>\n<p>值得注意的是（正如Yindeng Jiang在他们的博客中所做的那样），一个微小的更改将导致输出始终依赖于<code>a</code>和<code>b</code>：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output<span class=\"operator\">$</span>out <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  a <span class=\"operator\">&lt;-</span> input<span class=\"operator\">$</span>a</span><br><span class=\"line\">  b <span class=\"operator\">&lt;-</span> input<span class=\"operator\">$</span>b</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>choice <span class=\"operator\">==</span> <span class=\"string\">&quot;a&quot;</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    a</span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span> <span class=\"keyword\">else</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    b</span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span> </span><br></pre></td></tr></table></figure>\n\n<p>这对正常的R代码输出没有影响，但在这里却有所不同，因为反应式依赖是在你从输入中读取值时建立的，而不是在你使用该值时建立的。</p>\n<h2 id=\"14-6-reactlog包\"><a href=\"#14-6-reactlog包\" class=\"headerlink\" title=\"14.6 reactlog包\"></a>14.6 reactlog包</h2><p>手动绘制反应式图是一种强大的技术，可以帮助你理解简单的应用程序，并构建出反应式编程的准确心理模型。但对于拥有许多动态部分的实际应用程序来说，这样做很痛苦。如果我们能使用Shiny对其了解的内容自动绘制图形，那岂不是太好了？这就是<code>reactlog</code>包的工作，它生成所谓的反应日志（reactlog），展示了反应式图如何随时间演变。</p>\n<p>要查看反应日志，你首先需要安装reactlog包，使用<code>reactlog::reactlog_enable()</code>启用它，然后启动你的应用程序。你有两个选项：</p>\n<ul>\n<li><p>在应用程序运行时，按Cmd + F3（在Windows上是Ctrl + F3），以显示到目前为止生成的反应日志。</p>\n</li>\n<li><p>在应用程序关闭后，运行<code>shiny::reactlogShow()</code>以查看整个会话的日志。</p>\n</li>\n</ul>\n<p>reactlog使用与本章相同的图形约定，因此你应该会立即感到熟悉。最大的不同是，reactlog绘制了所有依赖项，即使它们当前未被使用，以保持自动布局的稳定性。当前不活跃的连接（但过去或将来会活跃）被绘制为细虚线。</p>\n<p>图14.16展示了reactlog为我们上面使用的应用程序绘制的反应式图。截图中有一个惊喜：有三个额外的反应式输入（<code>clientData$output_x_height</code>、<code>clientData$output_x_width</code>和<code>clientData$pixelratio</code>）没有出现在源代码中。这些存在是因为图表对输出的大小有隐式依赖；每当输出大小改变时，图表都需要重新绘制。</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/f5c46b4a728eb6b329549c5156a299c3fe28fb21/6b5cb/images/reactivity-graph/reactlog.png\" class=\"lazyload placeholder\" data-srcset=\"https://d33wubrfki0l68.cloudfront.net/f5c46b4a728eb6b329549c5156a299c3fe28fb21/6b5cb/images/reactivity-graph/reactlog.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"图14.16 由reactlog绘制的假设应用程序的反应式图\"></p>\n<p>请注意，虽然反应式输入和输出有名称，但反应式表达式和观察者没有，因此它们用其内容标记。为了更容易理解，你可能想使用<a href=\"https://rdrr.io/pkg/shiny/man/reactive.html\">reactive()</a>和<a href=\"https://rdrr.io/pkg/shiny/man/observe.html\">observe()</a>的<code>label</code>参数，这样它们就会出现在反应日志中。你可以使用表情符号来使特别重要的反应式在视觉上脱颖而出。</p>\n<h2 id=\"14-7-总结\"><a href=\"#14-7-总结\" class=\"headerlink\" title=\"14.7 总结\"></a>14.7 总结</h2><p>在本章中，你精确地学习了反应式图是如何工作的。特别是，你首次了解了无效化阶段，它不会立即导致重新计算，而是将反应式消费者标记为无效，以便在需要时重新计算。无效化周期也很重要，因为它清除了之前发现的依赖项，以便它们可以自动重新发现，从而使反应式图具有动态性。</p>\n<p>现在你已经掌握了全局，下一章将提供一些关于支持反应式值、表达式和输出的底层数据结构的额外细节，并讨论与定时无效化相关的概念。</p>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n\n\n<p><font color=\"#FF0000\"><ruby><b>敬告</b>：使用文中脚本请引用本文网址，请尊重本人的劳动成果，谢谢！<rt><b>Notice</b>: When you use the scripts in this article, please cite the link of this webpage. Thank you!</rt></ruby></font></p>\n","raw":null,"categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"编程","path":"api/tags/编程.json"},{"name":"Shiny入门系列","path":"api/tags/Shiny入门系列.json"}]}]}