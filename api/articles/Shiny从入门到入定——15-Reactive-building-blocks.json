{"title":"Shiny从入门到入定——15-Reactive building blocks","slug":"Shiny从入门到入定——15-Reactive-building-blocks","date":"2024-09-26T14:00:23.000Z","updated":"2024-09-26T14:28:52.313Z","comments":true,"path":"api/articles/Shiny从入门到入定——15-Reactive-building-blocks.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg","https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png"],"content":"<h1 id=\"15-反应式构建块\"><a href=\"#15-反应式构建块\" class=\"headerlink\" title=\"15 反应式构建块\"></a>15 反应式构建块</h1><p>既然你已经理解了反应式图背后的理论，并且有了一些实践经验，那么现在是时候更详细地讨论反应式如何融入R编程语言中了。反应式编程有三个基本构建块：<code>反应式值</code>、<code>反应式表达式</code>和<code>观察者</code>。你已经看到了反应式值和表达式的大部分重要部分，所以本章将花更多时间讨论观察者和输出（你将了解到输出是一种特殊的观察者）。你还将学习控制反应式图的另外两个工具：<code>隔离</code>和<code>定时无效化</code>。</p>\n<p>本章将再次使用反应式控制台，这样我们就可以直接在控制台中试验反应式，而无需每次都启动一个Shiny应用程序。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>shiny<span class=\"punctuation\">)</span></span><br><span class=\"line\">reactiveConsole<span class=\"punctuation\">(</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-1-反应式值\"><a href=\"#15-1-反应式值\" class=\"headerlink\" title=\"15.1 反应式值\"></a>15.1 反应式值</h2><p>反应式值有两种类型：</p>\n<ul>\n<li><p>使用<a href=\"https://rdrr.io/pkg/shiny/man/reactiveVal.html\">reactiveVal()</a>创建的单个反应式值。</p>\n</li>\n<li><p>使用<a href=\"https://rdrr.io/pkg/shiny/man/reactiveValues.html\">reactiveValues()</a>创建的反应式值列表。</p>\n</li>\n</ul>\n<p>它们在获取和设置值时的接口略有不同：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">20</span><span class=\"punctuation\">)</span>     <span class=\"comment\"># set</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br><span class=\"line\"></span><br><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 20 <span class=\"comment\"># set</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br></pre></td></tr></table></figure>\n\n<p>不幸的是，这两个类似的对象有着截然不同的接口，但没有办法将它们标准化。然而，尽管它们看起来不同，但行为是相同的，所以你可以根据自己的语法偏好来选择使用哪一个。在本书中，我使用<code>reactiveValues()</code>，因为它的语法一目了然，但在我的代码中，我倾向于使用<code>reactiveVal()</code>，因为它的语法清楚地表明正在发生一些不寻常的事情。</p>\n<p>重要的是要注意，这两种类型的反应式值都具有所谓的引用语义。大多数R对象在修改时具有复制语义，这意味着如果你将相同的值赋给两个名称，一旦你修改了其中一个，连接就会断开：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1 <span class=\"operator\">&lt;-</span> a2 <span class=\"operator\">&lt;-</span> 10</span><br><span class=\"line\">a2 <span class=\"operator\">&lt;-</span> 20</span><br><span class=\"line\">a1 <span class=\"comment\"># 未改变</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br></pre></td></tr></table></figure>\n\n<p>但反应式值则不是这样——它们总是保持对相同值的引用，因此修改任何副本都会修改所有值：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b1 <span class=\"operator\">&lt;-</span> b2 <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">b1<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 20</span><br><span class=\"line\">b2<span class=\"operator\">$</span>x</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br></pre></td></tr></table></figure>\n\n<p>我们将在第16章中讨论为什么你可能需要创建自己的反应式值。否则，你将遇到的大多数反应式值都将来自<code>server</code>函数的输入参数。这些与你自己创建的<code>reactiveValues()</code>略有不同，因为它们是只读的：你不能修改这些值，因为Shiny会根据浏览器中的用户操作自动更新它们。</p>\n<h3 id=\"15-1-1-练习\"><a href=\"#15-1-1-练习\" class=\"headerlink\" title=\"15.1.1 练习\"></a>15.1.1 练习</h3><ul>\n<li><p>这两个反应式值列表之间有什么区别？比较获取和设置单个反应式值的语法。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l1 <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>a <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">l2 <span class=\"operator\">&lt;-</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>a <span class=\"operator\">=</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> b <span class=\"operator\">=</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设计并执行一个小实验，以验证<code>reactiveVal()</code>也具有引用语义。</p>\n</li>\n</ul>\n<h2 id=\"15-2-反应式表达式\"><a href=\"#15-2-反应式表达式\" class=\"headerlink\" title=\"15.2 反应式表达式\"></a>15.2 反应式表达式</h2><p>回忆一下，反应式有两个重要特性：它是<code>惰性</code>的并且具有<code>缓存</code>。这意味着它只有在真正需要时才会工作，如果连续调用两次，它会返回之前的值。</p>\n<p>我们还没有涵盖两个重要的细节：反应式表达式如何处理错误，以及为什么<code>on.exit()</code>在它们内部有效。</p>\n<h3 id=\"15-2-1-错误\"><a href=\"#15-2-1-错误\" class=\"headerlink\" title=\"15.2.1 错误\"></a>15.2.1 错误</h3><p>反应式表达式以与缓存值完全相同的方式缓存错误。例如，考虑这个反应式：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>stop<span class=\"punctuation\">(</span><span class=\"string\">&quot;Error occured at &quot;</span><span class=\"punctuation\">,</span> Sys.time<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> call. <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; Error: Error occured at 2022-08-23 23:10:12</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们等待一两秒钟，我们可以看到我们得到了与之前相同的错误：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; Error: Error occured at 2022-08-23 23:10:12</span></span><br></pre></td></tr></table></figure>\n\n<p>在反应式图中，错误的处理方式与值相同：错误通过反应式图传播的方式与常规值完全相同。唯一的区别是当错误遇到输出或观察者时会发生什么：</p>\n<ul>\n<li>输出中的错误将在应用程序中显示。</li>\n<li>观察者中的错误将导致当前会话终止。如果你不希望发生这种情况，你需要将代码包装在<code>try()</code>或<code>tryCatch()</code>中。</li>\n</ul>\n<p>这个相同的系统还支持<code>req()</code>（第8.1.2节），它发出一种特殊类型的错误。这种特殊错误会导致观察者和输出停止它们正在做的事情，但不会导致失败。默认情况下，它会使输出重置为其初始空白状态，但如果你使用<code>req(..., cancelOutput = TRUE)</code>，它们将保留其当前显示。</p>\n<h3 id=\"15-2-2-on-exit\"><a href=\"#15-2-2-on-exit\" class=\"headerlink\" title=\"15.2.2 on.exit()\"></a>15.2.2 on.exit()</h3><p>你可以将<code>reactive(x())</code>视为<code>function() x()</code>的快捷方式，它自动添加了惰性和缓存。这主要在你想要了解Shiny是如何实现的时候很重要，但这也意味着你可以使用那些只能在函数内部工作的函数。其中最有用的是<code>on.exit()</code>，它允许你在反应式表达式完成时运行代码，无论反应式是否成功返回错误或失败。这就是<code>on.exit()</code>在第8.2.2节中工作的原因。</p>\n<h3 id=\"15-2-3-练习\"><a href=\"#15-2-3-练习\" class=\"headerlink\" title=\"15.2.3 练习\"></a>15.2.3 练习</h3><ul>\n<li><p>使用<code>reactlog</code>包来观察以下应用程序中错误通过反应式传播的情况，确认它遵循与值传播相同的规则。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  checkboxInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;error&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;error?&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;result&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  a <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>error<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      stop<span class=\"punctuation\">(</span><span class=\"string\">&quot;Error!&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span> <span class=\"keyword\">else</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  b <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>a<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"built_in\">c</span> <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>b<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>result <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改上述应用程序，使用<code>req()</code>代替<code>stop()</code>。验证事件是否仍然以相同的方式传播。当你使用<code>cancelOutput</code>参数时会发生什么？</p>\n</li>\n</ul>\n<h2 id=\"15-3-观察者和输出\"><a href=\"#15-3-观察者和输出\" class=\"headerlink\" title=\"15.3 观察者和输出\"></a>15.3 观察者和输出</h2><p>观察者和输出是反应式图中的终端节点。它们在两个重要方面与反应式表达式不同：</p>\n<ul>\n<li><p>它们是急切的且健忘的——它们尽可能快地运行，并且不记得之前的操作。这种急切性是“传染性的”，因为如果它们使用了一个反应式表达式，那么该反应式表达式也将被评估。</p>\n</li>\n<li><p>观察者返回的值被忽略，因为它们被设计为与称为副作用的函数一起工作，如<code>cat()</code>或<code>write.csv()</code>。</p>\n</li>\n</ul>\n<p>观察者和输出由同一个底层工具提供支持：<code>observe()</code>。这设置了一个代码块，每次它使用的反应式值或表达式更新时，该代码块就会运行。请注意，当你创建观察者时，它会立即运行——它必须这样做才能确定其反应式依赖项。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  message<span class=\"punctuation\">(</span><span class=\"string\">&quot;`y` is &quot;</span><span class=\"punctuation\">,</span> y<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">y<span class=\"punctuation\">(</span><span class=\"number\">5</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 5</span></span><br><span class=\"line\">y<span class=\"punctuation\">(</span><span class=\"number\">4</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 4</span></span><br></pre></td></tr></table></figure>\n\n<p>在这本书中，我很少使用<a href=\"https://rdrr.io/pkg/shiny/man/observe.html\">observe()</a>，因为它是为用户友好的<a href=\"https://rdrr.io/pkg/shiny/man/observeEvent.html\">observeEvent()</a>提供动力的底层工具。通常，你应该坚持使用<code>observeEvent()</code>，除非它无法实现你想要的功能。在本书中，我只会向你展示一个必须使用<code>observe()</code>的案例，即第16.3.3节。</p>\n<p><code>observe()</code>也为响应式输出提供动力。响应式输出是一种特殊的观察者，它们具有两个重要属性：</p>\n<ul>\n<li><p>当你将它们赋值给输出时，它们就会被定义，即<code>output$text &lt;- ...</code>会创建观察者。</p>\n</li>\n<li><p>它们具有一些有限的检测能力，可以检测到自己是否不可见（即它们位于非活动标签页中），因此不必重新计算。</p>\n</li>\n</ul>\n<p>重要的是要注意，<code>observe()</code>和响应式输出并不“执行”某些操作，而是“创建”某些东西（然后根据需要采取行动）。这种思维方式有助于你理解这个例子中的情况：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">y <span class=\"operator\">&lt;-</span> observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observe<span class=\"punctuation\">(</span>print<span class=\"punctuation\">(</span>x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 1</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">3</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br></pre></td></tr></table></figure>\n\n<p>每当<code>x</code>发生变化时，观察者就会被触发。观察者本身会调用<code>observe()</code>来设置另一个观察者。因此，每次<code>x</code>发生变化时，都会获得另一个观察者，从而导致其值再次被打印。</p>\n<p>作为一般规则，你应该只在服务器函数的顶层创建观察者或输出。如果你发现自己试图嵌套它们或在输出内部创建观察者，那么你应该坐下来，画出你想要创建的响应式图表的草图——几乎可以肯定存在更好的方法。在更复杂的应用程序中，这个错误可能更难直接发现，但你可以始终使用<code>reactlog</code>：只需查找观察者（或输出）中意外的变化，然后追踪到是什么导致了这些变化。</p>\n<h2 id=\"15-4-代码隔离\"><a href=\"#15-4-代码隔离\" class=\"headerlink\" title=\"15.4 代码隔离\"></a>15.4 代码隔离</h2><p>为了结束本章，我将讨论两个重要的工具，用于精确控制响应式图表的失效方式和时间。在本节中，我将讨论<a href=\"https://rdrr.io/pkg/shiny/man/isolate.html\">isolate()</a>，这是<code>observeEvent()</code>和<a href=\"https://rdrr.io/pkg/shiny/man/observeEvent.html\">eventReactive()</a>的底层工具，它允许你在不需要时避免创建响应式依赖。在下一节中，你将学习<a href=\"https://rdrr.io/pkg/shiny/man/invalidateLater.html\">invalidateLater()</a>，它允许你按计划生成响应式失效。</p>\n<h3 id=\"15-4-1-isolate\"><a href=\"#15-4-1-isolate\" class=\"headerlink\" title=\"15.4.1 isolate()\"></a>15.4.1 isolate()</h3><p>观察者通常与响应式值结合使用，以便跟踪状态随时间的变化。例如，考虑以下代码，它跟踪<code>x</code>发生变化的次数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>count <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> x <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r<span class=\"operator\">$</span>x</span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>count <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你运行这段代码，你会立即陷入无限循环，因为观察者会对<code>x</code>和<code>count</code>产生响应式依赖；由于观察者修改了<code>count</code>，它会立即重新运行。</p>\n<p>幸运的是，Shiny提供了<code>isolate()</code>来解决这个问题。此函数允许你访问响应式值或表达式的当前值，而不会产生对它的依赖：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>count <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> x <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"built_in\">class</span><span class=\"punctuation\">(</span>r<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] &quot;rv_flush_on_write&quot; &quot;reactivevalues&quot;</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r<span class=\"operator\">$</span>x</span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> isolate<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>count<span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 1</span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 2</span><br><span class=\"line\">r<span class=\"operator\">$</span>count</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 3</span><br><span class=\"line\">r<span class=\"operator\">$</span>count</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br></pre></td></tr></table></figure>\n\n<p>和<code>observe()</code>一样，很多时候你不需要直接使用<code>isolate()</code>，因为有两个有用的函数封装了最常见的用法：<code>observeEvent()</code>和<code>eventReactive()</code>。</p>\n<h3 id=\"15-4-2-observeEvent-和-eventReactive\"><a href=\"#15-4-2-observeEvent-和-eventReactive\" class=\"headerlink\" title=\"15.4.2 observeEvent() 和 eventReactive()\"></a>15.4.2 observeEvent() 和 eventReactive()</h3><p>当你看到上面的代码时，你可能会想起第3.6节，并好奇为什么我没有使用<code>observeEvent()</code>：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observeEvent<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>x<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>count <span class=\"operator\">+</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，我本可以使用它，因为<code>observeEvent(x, y)</code>等价于<code>observe(&#123;x; isolate(y)&#125;)</code>。它优雅地将你想要监听的内容与你想要执行的操作分离开来。而<code>eventReactive()</code>则为响应式值执行类似的任务：<code>eventReactive(x, y)</code>等价于<code>reactive(&#123;x; isolate(y)&#125;)</code>。</p>\n<p><code>observeEvent()</code>和<code>eventReactive()</code>都有额外的参数，允许你控制它们的操作细节：</p>\n<ul>\n<li>默认情况下，这两个函数都会忽略产生NULL的任何事件（或在操作按钮的特殊情况下为0）。使用<code>ignoreNULL = FALSE</code>来处理NULL值。</li>\n<li>默认情况下，当你创建这两个函数时，它们都会运行一次。使用<code>ignoreInit = TRUE</code>来跳过这次运行。</li>\n<li>仅对于<code>observeEvent()</code>，你可以使用<code>once = TRUE</code>来使处理程序仅运行一次。</li>\n</ul>\n<p>这些参数很少需要，但知道它们的存在是很有用的，这样你就可以在需要时从文档中查找详细信息。</p>\n<h3 id=\"15-4-3-练习\"><a href=\"#15-4-3-练习\" class=\"headerlink\" title=\"15.4.3 练习\"></a>15.4.3 练习</h3><p>使用服务器函数完成下面的应用程序，该函数仅在按钮被按下时更新<code>out</code>的值为<code>x</code>的值。</p>\n<p>（注意：由于这是一个练习，我不会直接给出完整的代码，但你可以按照以下思路编写：</p>\n<ol>\n<li>在UI中定义一个动作按钮和一个用于显示结果的文本输出。</li>\n<li>在服务器函数中，使用<code>observeEvent()</code>监听按钮点击事件。</li>\n<li>在<code>observeEvent()</code>的回调函数中，更新文本输出的值。）</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;x&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;x&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"number\">50</span><span class=\"punctuation\">,</span> <span class=\"built_in\">min</span> <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"built_in\">max</span> <span class=\"operator\">=</span> <span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;capture&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;capture&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;out&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-5-定时失效\"><a href=\"#15-5-定时失效\" class=\"headerlink\" title=\"15.5 定时失效\"></a>15.5 定时失效</h2><p><code>isolate()</code> 减少了响应式图被失效的时间。而本节的主题 <code>invalidateLater()</code> 则做相反的事情：它允许你在数据没有变化时使响应式图失效。在 3.5.1 节中，你通过 <a href=\"https://rdrr.io/pkg/shiny/man/reactiveTimer.html\">reactiveTimer()</a> 看到了它的一个例子，但现在是时候讨论它背后的底层工具了：<code>invalidateLater()</code>。</p>\n<p><code>invalidateLater(ms)</code> 会导致任何响应式消费者在将来的某个时间点（<code>ms</code> 毫秒后）失效。这对于创建动画和连接到 Shiny 响应式框架之外可能随时间变化的数据源非常有用。例如，以下响应式表达式将每半秒自动生成 10 个新的随机正态分布数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  rnorm<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>而这个观察者将使用一个随机数增加累积和：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sum</span> <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">300</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>isolate<span class=\"punctuation\">(</span><span class=\"built_in\">sum</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> runif<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>在后续部分中，你将学习如何使用 <code>invalidateLater()</code> 从磁盘读取变化的数据，如何避免 <code>invalidateLater()</code> 陷入无限循环，以及关于失效确切发生时间的偶尔重要的细节。</p>\n<h3 id=\"15-5-1-轮询\"><a href=\"#15-5-1-轮询\" class=\"headerlink\" title=\"15.5.1 轮询\"></a>15.5.1 轮询</h3><p><code>invalidateLater()</code> 的一个有用应用是将 Shiny 连接到 R 外部变化的数据。例如，你可以使用以下响应式表达式每秒重新读取一次 CSV 文件：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">on.exit</span><span class=\"punctuation\">(</span>invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  read.csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>这会将变化的数据连接到 Shiny 的响应式图中，但它有一个严重的缺点：当你使响应式失效时，你也会使所有下游消费者失效，因此即使数据相同，所有下游工作也必须重做。</p>\n<p>为了避免这个问题，Shiny 提供了 <a href=\"https://rdrr.io/pkg/shiny/man/reactivePoll.html\">reactivePoll()</a>，它接受两个函数：一个执行相对便宜的检查以查看数据是否已更改，另一个更昂贵的函数实际执行计算。我们可以使用 <code>reactivePoll()</code> 重写前面的响应式，如下所示。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  data <span class=\"operator\">&lt;-</span> reactivePoll<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">,</span> session<span class=\"punctuation\">,</span> </span><br><span class=\"line\">    <span class=\"keyword\">function</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> file.mtime<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> read.csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我们使用了 <a href=\"https://rdrr.io/r/base/file.info.html\">file.mtime()</a>，它返回文件最后一次修改的时间，作为是否需要重新加载文件的廉价检查。</p>\n<p>当文件变化时读取文件是一个常见任务，因此 Shiny 提供了一个更具体的辅助函数，它只需要文件名和读取函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  data <span class=\"operator\">&lt;-</span> reactiveFileReader<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">,</span> session<span class=\"punctuation\">,</span> <span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">,</span> read.csv<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你需要从其他来源（例如数据库）读取变化的数据，你需要自己编写 <code>reactivePoll()</code> 代码。</p>\n<h3 id=\"15-5-2-长时间运行的响应式\"><a href=\"#15-5-2-长时间运行的响应式\" class=\"headerlink\" title=\"15.5.2 长时间运行的响应式\"></a>15.5.2 长时间运行的响应式</h3><p>如果你正在执行长时间的计算，你需要考虑一个重要问题：何时执行 <code>invalidateLater()</code>？例如，考虑以下响应式：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>假设Shiny在0时刻开始反应式运行，它将在500毫秒时请求失效。反应式运行需要1000毫秒，所以现在时间到了1000毫秒，它立即失效并需要重新计算，这又会触发另一次失效：我们陷入了一个无限循环。</p>\n<p>另一方面，如果你在末尾运行<code>invalidateLater()</code>，它将在完成后500毫秒失效，所以反应式将每1500毫秒重新运行一次。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">on.exit</span><span class=\"punctuation\">(</span>invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> add <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n<p>这是选择<code>invalidateLater()</code>而不是我们之前使用的更简单的<code>reactiveTimer()</code>的主要原因：它让你对失效发生的确切时间有更大的控制权。</p>\n<h3 id=\"15-5-3-定时器准确性\"><a href=\"#15-5-3-定时器准确性\" class=\"headerlink\" title=\"15.5.3 定时器准确性\"></a>15.5.3 定时器准确性</h3><p><code>invalidateLater()</code>中指定的毫秒数是一个礼貌的请求，而不是一个强制要求。当你请求失效发生时，R可能正在做其他事情，所以你的请求必须等待。这实际上意味着这个数值是一个最小值，失效可能会比你预期的时间更长。在大多数情况下，这并不重要，因为小的差异不太可能影响用户对应用程序的感知。然而，在许多小错误会累积的情况下，你应该计算实际经过的时间并使用它来调整你的计算。</p>\n<p>例如，以下代码根据速度和经过的时间计算距离。而不是假设<code>invalidateLater(100)</code>总是精确延迟100毫秒，我计算经过的时间并在计算位置时使用它。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">velocity <span class=\"operator\">&lt;-</span> 3</span><br><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>distance <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">last <span class=\"operator\">&lt;-</span> <span class=\"built_in\">proc.time</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[[</span><span class=\"number\">3</span><span class=\"punctuation\">]</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  cur <span class=\"operator\">&lt;-</span> <span class=\"built_in\">proc.time</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[[</span><span class=\"number\">3</span><span class=\"punctuation\">]</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">  time <span class=\"operator\">&lt;-</span> last <span class=\"operator\">-</span> cur</span><br><span class=\"line\">  last <span class=\"operator\">&lt;&lt;-</span> cur</span><br><span class=\"line\">  </span><br><span class=\"line\">  r<span class=\"operator\">$</span>distance <span class=\"operator\">&lt;-</span> isolate<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>distance<span class=\"punctuation\">)</span> <span class=\"operator\">+</span> velocity <span class=\"operator\">*</span> time</span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你不是在仔细做动画，那么请随意忽略<code>invalidateLater()</code>中固有的变化。只需记住，它是一个礼貌的请求，而不是一个要求。</p>\n<h3 id=\"15-5-4-练习\"><a href=\"#15-5-4-练习\" class=\"headerlink\" title=\"15.5.4 练习\"></a>15.5.4 练习</h3><p>为什么这个反应式表达式永远不会被执行？你的解释应该涉及反应式图和失效机制。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    rnorm<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span>  </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你熟悉SQL，请使用<code>reactivePoll()</code>来仅当新行被添加时才重新读取一个虚构的“Results”表。你可以假设Results表有一个时间戳字段，该字段包含记录被添加的日期和时间。</p>\n<h3 id=\"15-6-总结\"><a href=\"#15-6-总结\" class=\"headerlink\" title=\"15.6 总结\"></a>15.6 总结</h3><p>在本章中，你深入了解了使Shiny工作的基石：反应式值、反应式表达式、观察者和定时评估。现在，我们将注意力转向反应式值和观察者的特定组合，这种组合使我们能够摆脱反应式图的一些约束（无论好坏）。</p>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" class=\"lazyload placeholder\" data-srcset=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" srcset=\"https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n\n\n<p><font color=\"#FF0000\"><ruby><b>敬告</b>：使用文中脚本请引用本文网址，请尊重本人的劳动成果，谢谢！<rt><b>Notice</b>: When you use the scripts in this article, please cite the link of this webpage. Thank you!</rt></ruby></font></p>\n","more":"<h1 id=\"15-反应式构建块\"><a href=\"#15-反应式构建块\" class=\"headerlink\" title=\"15 反应式构建块\"></a>15 反应式构建块</h1><p>既然你已经理解了反应式图背后的理论，并且有了一些实践经验，那么现在是时候更详细地讨论反应式如何融入R编程语言中了。反应式编程有三个基本构建块：<code>反应式值</code>、<code>反应式表达式</code>和<code>观察者</code>。你已经看到了反应式值和表达式的大部分重要部分，所以本章将花更多时间讨论观察者和输出（你将了解到输出是一种特殊的观察者）。你还将学习控制反应式图的另外两个工具：<code>隔离</code>和<code>定时无效化</code>。</p>\n<p>本章将再次使用反应式控制台，这样我们就可以直接在控制台中试验反应式，而无需每次都启动一个Shiny应用程序。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>shiny<span class=\"punctuation\">)</span></span><br><span class=\"line\">reactiveConsole<span class=\"punctuation\">(</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-1-反应式值\"><a href=\"#15-1-反应式值\" class=\"headerlink\" title=\"15.1 反应式值\"></a>15.1 反应式值</h2><p>反应式值有两种类型：</p>\n<ul>\n<li><p>使用<a href=\"https://rdrr.io/pkg/shiny/man/reactiveVal.html\">reactiveVal()</a>创建的单个反应式值。</p>\n</li>\n<li><p>使用<a href=\"https://rdrr.io/pkg/shiny/man/reactiveValues.html\">reactiveValues()</a>创建的反应式值列表。</p>\n</li>\n</ul>\n<p>它们在获取和设置值时的接口略有不同：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">20</span><span class=\"punctuation\">)</span>     <span class=\"comment\"># set</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br><span class=\"line\"></span><br><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 20 <span class=\"comment\"># set</span></span><br><span class=\"line\">r<span class=\"operator\">$</span>x       <span class=\"comment\"># get</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br></pre></td></tr></table></figure>\n\n<p>不幸的是，这两个类似的对象有着截然不同的接口，但没有办法将它们标准化。然而，尽管它们看起来不同，但行为是相同的，所以你可以根据自己的语法偏好来选择使用哪一个。在本书中，我使用<code>reactiveValues()</code>，因为它的语法一目了然，但在我的代码中，我倾向于使用<code>reactiveVal()</code>，因为它的语法清楚地表明正在发生一些不寻常的事情。</p>\n<p>重要的是要注意，这两种类型的反应式值都具有所谓的引用语义。大多数R对象在修改时具有复制语义，这意味着如果你将相同的值赋给两个名称，一旦你修改了其中一个，连接就会断开：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1 <span class=\"operator\">&lt;-</span> a2 <span class=\"operator\">&lt;-</span> 10</span><br><span class=\"line\">a2 <span class=\"operator\">&lt;-</span> 20</span><br><span class=\"line\">a1 <span class=\"comment\"># 未改变</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 10</span></span><br></pre></td></tr></table></figure>\n\n<p>但反应式值则不是这样——它们总是保持对相同值的引用，因此修改任何副本都会修改所有值：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b1 <span class=\"operator\">&lt;-</span> b2 <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>x <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">b1<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 20</span><br><span class=\"line\">b2<span class=\"operator\">$</span>x</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 20</span></span><br></pre></td></tr></table></figure>\n\n<p>我们将在第16章中讨论为什么你可能需要创建自己的反应式值。否则，你将遇到的大多数反应式值都将来自<code>server</code>函数的输入参数。这些与你自己创建的<code>reactiveValues()</code>略有不同，因为它们是只读的：你不能修改这些值，因为Shiny会根据浏览器中的用户操作自动更新它们。</p>\n<h3 id=\"15-1-1-练习\"><a href=\"#15-1-1-练习\" class=\"headerlink\" title=\"15.1.1 练习\"></a>15.1.1 练习</h3><ul>\n<li><p>这两个反应式值列表之间有什么区别？比较获取和设置单个反应式值的语法。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l1 <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>a <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">l2 <span class=\"operator\">&lt;-</span> <span class=\"built_in\">list</span><span class=\"punctuation\">(</span>a <span class=\"operator\">=</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> b <span class=\"operator\">=</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设计并执行一个小实验，以验证<code>reactiveVal()</code>也具有引用语义。</p>\n</li>\n</ul>\n<h2 id=\"15-2-反应式表达式\"><a href=\"#15-2-反应式表达式\" class=\"headerlink\" title=\"15.2 反应式表达式\"></a>15.2 反应式表达式</h2><p>回忆一下，反应式有两个重要特性：它是<code>惰性</code>的并且具有<code>缓存</code>。这意味着它只有在真正需要时才会工作，如果连续调用两次，它会返回之前的值。</p>\n<p>我们还没有涵盖两个重要的细节：反应式表达式如何处理错误，以及为什么<code>on.exit()</code>在它们内部有效。</p>\n<h3 id=\"15-2-1-错误\"><a href=\"#15-2-1-错误\" class=\"headerlink\" title=\"15.2.1 错误\"></a>15.2.1 错误</h3><p>反应式表达式以与缓存值完全相同的方式缓存错误。例如，考虑这个反应式：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>stop<span class=\"punctuation\">(</span><span class=\"string\">&quot;Error occured at &quot;</span><span class=\"punctuation\">,</span> Sys.time<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> call. <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; Error: Error occured at 2022-08-23 23:10:12</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们等待一两秒钟，我们可以看到我们得到了与之前相同的错误：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">r<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; Error: Error occured at 2022-08-23 23:10:12</span></span><br></pre></td></tr></table></figure>\n\n<p>在反应式图中，错误的处理方式与值相同：错误通过反应式图传播的方式与常规值完全相同。唯一的区别是当错误遇到输出或观察者时会发生什么：</p>\n<ul>\n<li>输出中的错误将在应用程序中显示。</li>\n<li>观察者中的错误将导致当前会话终止。如果你不希望发生这种情况，你需要将代码包装在<code>try()</code>或<code>tryCatch()</code>中。</li>\n</ul>\n<p>这个相同的系统还支持<code>req()</code>（第8.1.2节），它发出一种特殊类型的错误。这种特殊错误会导致观察者和输出停止它们正在做的事情，但不会导致失败。默认情况下，它会使输出重置为其初始空白状态，但如果你使用<code>req(..., cancelOutput = TRUE)</code>，它们将保留其当前显示。</p>\n<h3 id=\"15-2-2-on-exit\"><a href=\"#15-2-2-on-exit\" class=\"headerlink\" title=\"15.2.2 on.exit()\"></a>15.2.2 on.exit()</h3><p>你可以将<code>reactive(x())</code>视为<code>function() x()</code>的快捷方式，它自动添加了惰性和缓存。这主要在你想要了解Shiny是如何实现的时候很重要，但这也意味着你可以使用那些只能在函数内部工作的函数。其中最有用的是<code>on.exit()</code>，它允许你在反应式表达式完成时运行代码，无论反应式是否成功返回错误或失败。这就是<code>on.exit()</code>在第8.2.2节中工作的原因。</p>\n<h3 id=\"15-2-3-练习\"><a href=\"#15-2-3-练习\" class=\"headerlink\" title=\"15.2.3 练习\"></a>15.2.3 练习</h3><ul>\n<li><p>使用<code>reactlog</code>包来观察以下应用程序中错误通过反应式传播的情况，确认它遵循与值传播相同的规则。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  checkboxInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;error&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;error?&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;result&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  a <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"punctuation\">(</span>input<span class=\"operator\">$</span>error<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      stop<span class=\"punctuation\">(</span><span class=\"string\">&quot;Error!&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span> <span class=\"keyword\">else</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  b <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>a<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"built_in\">c</span> <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span>b<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  output<span class=\"operator\">$</span>result <span class=\"operator\">&lt;-</span> renderText<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改上述应用程序，使用<code>req()</code>代替<code>stop()</code>。验证事件是否仍然以相同的方式传播。当你使用<code>cancelOutput</code>参数时会发生什么？</p>\n</li>\n</ul>\n<h2 id=\"15-3-观察者和输出\"><a href=\"#15-3-观察者和输出\" class=\"headerlink\" title=\"15.3 观察者和输出\"></a>15.3 观察者和输出</h2><p>观察者和输出是反应式图中的终端节点。它们在两个重要方面与反应式表达式不同：</p>\n<ul>\n<li><p>它们是急切的且健忘的——它们尽可能快地运行，并且不记得之前的操作。这种急切性是“传染性的”，因为如果它们使用了一个反应式表达式，那么该反应式表达式也将被评估。</p>\n</li>\n<li><p>观察者返回的值被忽略，因为它们被设计为与称为副作用的函数一起工作，如<code>cat()</code>或<code>write.csv()</code>。</p>\n</li>\n</ul>\n<p>观察者和输出由同一个底层工具提供支持：<code>observe()</code>。这设置了一个代码块，每次它使用的反应式值或表达式更新时，该代码块就会运行。请注意，当你创建观察者时，它会立即运行——它必须这样做才能确定其反应式依赖项。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  message<span class=\"punctuation\">(</span><span class=\"string\">&quot;`y` is &quot;</span><span class=\"punctuation\">,</span> y<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">y<span class=\"punctuation\">(</span><span class=\"number\">5</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 5</span></span><br><span class=\"line\">y<span class=\"punctuation\">(</span><span class=\"number\">4</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; `y` is 4</span></span><br></pre></td></tr></table></figure>\n\n<p>在这本书中，我很少使用<a href=\"https://rdrr.io/pkg/shiny/man/observe.html\">observe()</a>，因为它是为用户友好的<a href=\"https://rdrr.io/pkg/shiny/man/observeEvent.html\">observeEvent()</a>提供动力的底层工具。通常，你应该坚持使用<code>observeEvent()</code>，除非它无法实现你想要的功能。在本书中，我只会向你展示一个必须使用<code>observe()</code>的案例，即第16.3.3节。</p>\n<p><code>observe()</code>也为响应式输出提供动力。响应式输出是一种特殊的观察者，它们具有两个重要属性：</p>\n<ul>\n<li><p>当你将它们赋值给输出时，它们就会被定义，即<code>output$text &lt;- ...</code>会创建观察者。</p>\n</li>\n<li><p>它们具有一些有限的检测能力，可以检测到自己是否不可见（即它们位于非活动标签页中），因此不必重新计算。</p>\n</li>\n</ul>\n<p>重要的是要注意，<code>observe()</code>和响应式输出并不“执行”某些操作，而是“创建”某些东西（然后根据需要采取行动）。这种思维方式有助于你理解这个例子中的情况：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">y <span class=\"operator\">&lt;-</span> observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  observe<span class=\"punctuation\">(</span>print<span class=\"punctuation\">(</span>x<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 1</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\">x<span class=\"punctuation\">(</span><span class=\"number\">3</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br></pre></td></tr></table></figure>\n\n<p>每当<code>x</code>发生变化时，观察者就会被触发。观察者本身会调用<code>observe()</code>来设置另一个观察者。因此，每次<code>x</code>发生变化时，都会获得另一个观察者，从而导致其值再次被打印。</p>\n<p>作为一般规则，你应该只在服务器函数的顶层创建观察者或输出。如果你发现自己试图嵌套它们或在输出内部创建观察者，那么你应该坐下来，画出你想要创建的响应式图表的草图——几乎可以肯定存在更好的方法。在更复杂的应用程序中，这个错误可能更难直接发现，但你可以始终使用<code>reactlog</code>：只需查找观察者（或输出）中意外的变化，然后追踪到是什么导致了这些变化。</p>\n<h2 id=\"15-4-代码隔离\"><a href=\"#15-4-代码隔离\" class=\"headerlink\" title=\"15.4 代码隔离\"></a>15.4 代码隔离</h2><p>为了结束本章，我将讨论两个重要的工具，用于精确控制响应式图表的失效方式和时间。在本节中，我将讨论<a href=\"https://rdrr.io/pkg/shiny/man/isolate.html\">isolate()</a>，这是<code>observeEvent()</code>和<a href=\"https://rdrr.io/pkg/shiny/man/observeEvent.html\">eventReactive()</a>的底层工具，它允许你在不需要时避免创建响应式依赖。在下一节中，你将学习<a href=\"https://rdrr.io/pkg/shiny/man/invalidateLater.html\">invalidateLater()</a>，它允许你按计划生成响应式失效。</p>\n<h3 id=\"15-4-1-isolate\"><a href=\"#15-4-1-isolate\" class=\"headerlink\" title=\"15.4.1 isolate()\"></a>15.4.1 isolate()</h3><p>观察者通常与响应式值结合使用，以便跟踪状态随时间的变化。例如，考虑以下代码，它跟踪<code>x</code>发生变化的次数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>count <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> x <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r<span class=\"operator\">$</span>x</span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>count <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你运行这段代码，你会立即陷入无限循环，因为观察者会对<code>x</code>和<code>count</code>产生响应式依赖；由于观察者修改了<code>count</code>，它会立即重新运行。</p>\n<p>幸运的是，Shiny提供了<code>isolate()</code>来解决这个问题。此函数允许你访问响应式值或表达式的当前值，而不会产生对它的依赖：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>count <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> x <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"built_in\">class</span><span class=\"punctuation\">(</span>r<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] &quot;rv_flush_on_write&quot; &quot;reactivevalues&quot;</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  r<span class=\"operator\">$</span>x</span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> isolate<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>count<span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 1</span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 2</span><br><span class=\"line\">r<span class=\"operator\">$</span>count</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">r<span class=\"operator\">$</span>x <span class=\"operator\">&lt;-</span> 3</span><br><span class=\"line\">r<span class=\"operator\">$</span>count</span><br><span class=\"line\"><span class=\"comment\">#&gt; [1] 3</span></span><br></pre></td></tr></table></figure>\n\n<p>和<code>observe()</code>一样，很多时候你不需要直接使用<code>isolate()</code>，因为有两个有用的函数封装了最常见的用法：<code>observeEvent()</code>和<code>eventReactive()</code>。</p>\n<h3 id=\"15-4-2-observeEvent-和-eventReactive\"><a href=\"#15-4-2-observeEvent-和-eventReactive\" class=\"headerlink\" title=\"15.4.2 observeEvent() 和 eventReactive()\"></a>15.4.2 observeEvent() 和 eventReactive()</h3><p>当你看到上面的代码时，你可能会想起第3.6节，并好奇为什么我没有使用<code>observeEvent()</code>：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observeEvent<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>x<span class=\"punctuation\">,</span> <span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  r<span class=\"operator\">$</span>count <span class=\"operator\">&lt;-</span> r<span class=\"operator\">$</span>count <span class=\"operator\">+</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，我本可以使用它，因为<code>observeEvent(x, y)</code>等价于<code>observe(&#123;x; isolate(y)&#125;)</code>。它优雅地将你想要监听的内容与你想要执行的操作分离开来。而<code>eventReactive()</code>则为响应式值执行类似的任务：<code>eventReactive(x, y)</code>等价于<code>reactive(&#123;x; isolate(y)&#125;)</code>。</p>\n<p><code>observeEvent()</code>和<code>eventReactive()</code>都有额外的参数，允许你控制它们的操作细节：</p>\n<ul>\n<li>默认情况下，这两个函数都会忽略产生NULL的任何事件（或在操作按钮的特殊情况下为0）。使用<code>ignoreNULL = FALSE</code>来处理NULL值。</li>\n<li>默认情况下，当你创建这两个函数时，它们都会运行一次。使用<code>ignoreInit = TRUE</code>来跳过这次运行。</li>\n<li>仅对于<code>observeEvent()</code>，你可以使用<code>once = TRUE</code>来使处理程序仅运行一次。</li>\n</ul>\n<p>这些参数很少需要，但知道它们的存在是很有用的，这样你就可以在需要时从文档中查找详细信息。</p>\n<h3 id=\"15-4-3-练习\"><a href=\"#15-4-3-练习\" class=\"headerlink\" title=\"15.4.3 练习\"></a>15.4.3 练习</h3><p>使用服务器函数完成下面的应用程序，该函数仅在按钮被按下时更新<code>out</code>的值为<code>x</code>的值。</p>\n<p>（注意：由于这是一个练习，我不会直接给出完整的代码，但你可以按照以下思路编写：</p>\n<ol>\n<li>在UI中定义一个动作按钮和一个用于显示结果的文本输出。</li>\n<li>在服务器函数中，使用<code>observeEvent()</code>监听按钮点击事件。</li>\n<li>在<code>observeEvent()</code>的回调函数中，更新文本输出的值。）</li>\n</ol>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui <span class=\"operator\">&lt;-</span> fluidPage<span class=\"punctuation\">(</span></span><br><span class=\"line\">  numericInput<span class=\"punctuation\">(</span><span class=\"string\">&quot;x&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;x&quot;</span><span class=\"punctuation\">,</span> value <span class=\"operator\">=</span> <span class=\"number\">50</span><span class=\"punctuation\">,</span> <span class=\"built_in\">min</span> <span class=\"operator\">=</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"built_in\">max</span> <span class=\"operator\">=</span> <span class=\"number\">100</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  actionButton<span class=\"punctuation\">(</span><span class=\"string\">&quot;capture&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;capture&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  textOutput<span class=\"punctuation\">(</span><span class=\"string\">&quot;out&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-5-定时失效\"><a href=\"#15-5-定时失效\" class=\"headerlink\" title=\"15.5 定时失效\"></a>15.5 定时失效</h2><p><code>isolate()</code> 减少了响应式图被失效的时间。而本节的主题 <code>invalidateLater()</code> 则做相反的事情：它允许你在数据没有变化时使响应式图失效。在 3.5.1 节中，你通过 <a href=\"https://rdrr.io/pkg/shiny/man/reactiveTimer.html\">reactiveTimer()</a> 看到了它的一个例子，但现在是时候讨论它背后的底层工具了：<code>invalidateLater()</code>。</p>\n<p><code>invalidateLater(ms)</code> 会导致任何响应式消费者在将来的某个时间点（<code>ms</code> 毫秒后）失效。这对于创建动画和连接到 Shiny 响应式框架之外可能随时间变化的数据源非常有用。例如，以下响应式表达式将每半秒自动生成 10 个新的随机正态分布数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  rnorm<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>而这个观察者将使用一个随机数增加累积和：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sum</span> <span class=\"operator\">&lt;-</span> reactiveVal<span class=\"punctuation\">(</span><span class=\"number\">0</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">300</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>isolate<span class=\"punctuation\">(</span><span class=\"built_in\">sum</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> runif<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>在后续部分中，你将学习如何使用 <code>invalidateLater()</code> 从磁盘读取变化的数据，如何避免 <code>invalidateLater()</code> 陷入无限循环，以及关于失效确切发生时间的偶尔重要的细节。</p>\n<h3 id=\"15-5-1-轮询\"><a href=\"#15-5-1-轮询\" class=\"headerlink\" title=\"15.5.1 轮询\"></a>15.5.1 轮询</h3><p><code>invalidateLater()</code> 的一个有用应用是将 Shiny 连接到 R 外部变化的数据。例如，你可以使用以下响应式表达式每秒重新读取一次 CSV 文件：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">on.exit</span><span class=\"punctuation\">(</span>invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  read.csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>这会将变化的数据连接到 Shiny 的响应式图中，但它有一个严重的缺点：当你使响应式失效时，你也会使所有下游消费者失效，因此即使数据相同，所有下游工作也必须重做。</p>\n<p>为了避免这个问题，Shiny 提供了 <a href=\"https://rdrr.io/pkg/shiny/man/reactivePoll.html\">reactivePoll()</a>，它接受两个函数：一个执行相对便宜的检查以查看数据是否已更改，另一个更昂贵的函数实际执行计算。我们可以使用 <code>reactivePoll()</code> 重写前面的响应式，如下所示。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  data <span class=\"operator\">&lt;-</span> reactivePoll<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">,</span> session<span class=\"punctuation\">,</span> </span><br><span class=\"line\">    <span class=\"keyword\">function</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> file.mtime<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> read.csv<span class=\"punctuation\">(</span><span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我们使用了 <a href=\"https://rdrr.io/r/base/file.info.html\">file.mtime()</a>，它返回文件最后一次修改的时间，作为是否需要重新加载文件的廉价检查。</p>\n<p>当文件变化时读取文件是一个常见任务，因此 Shiny 提供了一个更具体的辅助函数，它只需要文件名和读取函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  data <span class=\"operator\">&lt;-</span> reactiveFileReader<span class=\"punctuation\">(</span><span class=\"number\">1000</span><span class=\"punctuation\">,</span> session<span class=\"punctuation\">,</span> <span class=\"string\">&quot;data.csv&quot;</span><span class=\"punctuation\">,</span> read.csv<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你需要从其他来源（例如数据库）读取变化的数据，你需要自己编写 <code>reactivePoll()</code> 代码。</p>\n<h3 id=\"15-5-2-长时间运行的响应式\"><a href=\"#15-5-2-长时间运行的响应式\" class=\"headerlink\" title=\"15.5.2 长时间运行的响应式\"></a>15.5.2 长时间运行的响应式</h3><p>如果你正在执行长时间的计算，你需要考虑一个重要问题：何时执行 <code>invalidateLater()</code>？例如，考虑以下响应式：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>假设Shiny在0时刻开始反应式运行，它将在500毫秒时请求失效。反应式运行需要1000毫秒，所以现在时间到了1000毫秒，它立即失效并需要重新计算，这又会触发另一次失效：我们陷入了一个无限循环。</p>\n<p>另一方面，如果你在末尾运行<code>invalidateLater()</code>，它将在完成后500毫秒失效，所以反应式将每1500毫秒重新运行一次。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">on.exit</span><span class=\"punctuation\">(</span>invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> add <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  Sys.sleep<span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n<p>这是选择<code>invalidateLater()</code>而不是我们之前使用的更简单的<code>reactiveTimer()</code>的主要原因：它让你对失效发生的确切时间有更大的控制权。</p>\n<h3 id=\"15-5-3-定时器准确性\"><a href=\"#15-5-3-定时器准确性\" class=\"headerlink\" title=\"15.5.3 定时器准确性\"></a>15.5.3 定时器准确性</h3><p><code>invalidateLater()</code>中指定的毫秒数是一个礼貌的请求，而不是一个强制要求。当你请求失效发生时，R可能正在做其他事情，所以你的请求必须等待。这实际上意味着这个数值是一个最小值，失效可能会比你预期的时间更长。在大多数情况下，这并不重要，因为小的差异不太可能影响用户对应用程序的感知。然而，在许多小错误会累积的情况下，你应该计算实际经过的时间并使用它来调整你的计算。</p>\n<p>例如，以下代码根据速度和经过的时间计算距离。而不是假设<code>invalidateLater(100)</code>总是精确延迟100毫秒，我计算经过的时间并在计算位置时使用它。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">velocity <span class=\"operator\">&lt;-</span> 3</span><br><span class=\"line\">r <span class=\"operator\">&lt;-</span> reactiveValues<span class=\"punctuation\">(</span>distance <span class=\"operator\">=</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">last <span class=\"operator\">&lt;-</span> <span class=\"built_in\">proc.time</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[[</span><span class=\"number\">3</span><span class=\"punctuation\">]</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">observe<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  cur <span class=\"operator\">&lt;-</span> <span class=\"built_in\">proc.time</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">[[</span><span class=\"number\">3</span><span class=\"punctuation\">]</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">  time <span class=\"operator\">&lt;-</span> last <span class=\"operator\">-</span> cur</span><br><span class=\"line\">  last <span class=\"operator\">&lt;&lt;-</span> cur</span><br><span class=\"line\">  </span><br><span class=\"line\">  r<span class=\"operator\">$</span>distance <span class=\"operator\">&lt;-</span> isolate<span class=\"punctuation\">(</span>r<span class=\"operator\">$</span>distance<span class=\"punctuation\">)</span> <span class=\"operator\">+</span> velocity <span class=\"operator\">*</span> time</span><br><span class=\"line\">  invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你不是在仔细做动画，那么请随意忽略<code>invalidateLater()</code>中固有的变化。只需记住，它是一个礼貌的请求，而不是一个要求。</p>\n<h3 id=\"15-5-4-练习\"><a href=\"#15-5-4-练习\" class=\"headerlink\" title=\"15.5.4 练习\"></a>15.5.4 练习</h3><p>为什么这个反应式表达式永远不会被执行？你的解释应该涉及反应式图和失效机制。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>input<span class=\"punctuation\">,</span> output<span class=\"punctuation\">,</span> session<span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  x <span class=\"operator\">&lt;-</span> reactive<span class=\"punctuation\">(</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    invalidateLater<span class=\"punctuation\">(</span><span class=\"number\">500</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    rnorm<span class=\"punctuation\">(</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">)</span>  </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你熟悉SQL，请使用<code>reactivePoll()</code>来仅当新行被添加时才重新读取一个虚构的“Results”表。你可以假设Results表有一个时间戳字段，该字段包含记录被添加的日期和时间。</p>\n<h3 id=\"15-6-总结\"><a href=\"#15-6-总结\" class=\"headerlink\" title=\"15.6 总结\"></a>15.6 总结</h3><p>在本章中，你深入了解了使Shiny工作的基石：反应式值、反应式表达式、观察者和定时评估。现在，我们将注意力转向反应式值和观察者的特定组合，这种组合使我们能够摆脱反应式图的一些约束（无论好坏）。</p>\n<h1 id=\"加关注\"><a href=\"#加关注\" class=\"headerlink\" title=\"加关注\"></a>加关注</h1><p>关注公众号“生信之巅”。</p>\n<table align=\"center\"><tr>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/生信之巅公众号.jpg\" alt=\"生信之巅微信公众号\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-right: 0px;margin-bottom: 5px;align: center;\"></td>\n  <td align=\"center\"><img src=\"https://cdn.jsdelivr.net/gh/liaochenlanruo/cdn@master/img/social/小程序码.png\" alt=\"生信之巅小程序码\" style=\"width: 100px;height: 100px;vertical-align: -20px;border-radius: 0%;margin-left: 0px;margin-bottom: 5px;align: center\"></td>\n</tr></table>\n\n\n<p><font color=\"#FF0000\"><ruby><b>敬告</b>：使用文中脚本请引用本文网址，请尊重本人的劳动成果，谢谢！<rt><b>Notice</b>: When you use the scripts in this article, please cite the link of this webpage. Thank you!</rt></ruby></font></p>\n","categories":[{"name":"IT","path":"api/categories/IT.json"}],"tags":[{"name":"编程","path":"api/tags/编程.json"},{"name":"Shiny入门系列","path":"api/tags/Shiny入门系列.json"}]}